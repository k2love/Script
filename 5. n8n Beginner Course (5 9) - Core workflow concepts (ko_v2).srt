1
00:00:00,000 --> 00:00:05,100
안녕하세요, n8n 초급 강좌의
5번째 비디오에 오신 것을 환영합니다.

2
00:00:05,360 --> 00:00:08,892
이번 비디오에서는 몇 가지 핵심 워크플로 개념을 다루고,

3
00:00:08,893 --> 00:00:13,120
함께 첫 워크플로를 계속해서 만들어 보겠습니다.

4
00:00:14,990 --> 00:00:20,880
자신만의 워크플로를 만들기 전에 이해해야 할
중요한 핵심 워크플로 개념부터 시작해 보겠습니다.

5
00:00:20,881 --> 00:00:23,600
우선 워크플로를 구축하기 위한 기본 개념들을 살펴보죠.

6
00:00:25,440 --> 00:00:27,680
여기 보이는 곳이 캔버스입니다.

7
00:00:27,920 --> 00:00:31,940
캔버스에서는 주요 워크플로 요소를 확인할 수 있습니다.

8
00:00:32,320 --> 00:00:38,700
상단에는 워크플로 메뉴, 이름, 해당
워크플로와 관련된 태그가 있습니다.

9
00:00:39,000 --> 00:00:42,380
여기에는 워크플로 활성화 설정이 있습니다.

10
00:00:42,700 --> 00:00:47,236
또한 오른쪽 상단에서 버전 기록 및 워크플로

11
00:00:47,237 --> 00:00:50,921
관련 설정을 확인할 수 있습니다.

12
00:00:51,600 --> 00:00:55,740
가운데에는 해당 워크플로의 노드들이 있습니다.

13
00:00:56,140 --> 00:00:59,500
왼쪽 하단에는 줌 설정이 있습니다.

14
00:01:00,800 --> 00:01:06,380
워크플로를 활성화하면 워크플로를
프로덕션 환경으로 푸시할 수 있습니다.

15
00:01:06,780 --> 00:01:11,600
실제로 워크플로를 자동으로 사용할 수 있게 됩니다.

16
00:01:12,480 --> 00:01:16,140
n8n에서 워크플로 활성화는
조금 뒤에 더 자세히 다루겠습니다.

17
00:01:16,940 --> 00:01:21,580
물론 캔버스에는 노드가 있는데,
이것들이 주요 노드가 될 것입니다.

18
00:01:21,581 --> 00:01:27,814
그리고 주요 워크플로 메뉴에서는
여러분의 A&N 인스턴스에 있는

19
00:01:27,815 --> 00:01:31,501
모든 워크플로를 찾을 수 있습니다.

20
00:01:32,260 --> 00:01:36,360
필터링할 수 있는 태그와 소유자와
같은 정보를 찾을 수 있습니다.

21
00:01:36,780 --> 00:01:43,040
또한 아래의 "내 워크플로"를 클릭하여
자신이 만든 모든 워크플로를 찾을 수 있습니다.

22
00:01:43,041 --> 00:01:48,420
자신이 소유한 워크플로만 볼 수 있게 됩니다.

23
00:01:48,421 --> 00:01:51,901
워크플로를 만들 때마다,

24
00:01:51,902 --> 00:01:55,480
당신이 기본 소유자로 지정됩니다.

25
00:01:57,440 --> 00:02:03,720
캔버스 오른쪽 상단에 있는
워크플로 설정에서 워크플로 접근성과

26
00:02:03,721 --> 00:02:08,720
오류 워크플로, 워크플로 실행 저장
방식 등 모든 것을 관리할 수 있습니다.

27
00:02:08,721 --> 00:02:11,760
오류 워크플로와 저장된 실행에 대해서는

28
00:02:12,320 --> 00:02:18,320
7번 비디오에서 자세히 다루도록 하겠습니다.

29
00:02:18,420 --> 00:02:19,420
7번 비디오에서요.

30
00:02:21,420 --> 00:02:26,180
이제 노드가 어떻게 연결되는지, 실제로
워크플로를 어떻게 만드는지 살펴보겠습니다.

31
00:02:27,820 --> 00:02:30,800
모든 워크플로는 트리거 노드로 시작합니다.

32
00:02:31,100 --> 00:02:35,580
출력 분기만 있다는 사실로
트리거 노드를 알아볼 수 있습니다.

33
00:02:35,840 --> 00:02:36,840
여기 보시는 것처럼요.

34
00:02:37,920 --> 00:02:42,780
그리고 옆에 주황색 번개 아이콘이 있습니다.

35
00:02:43,300 --> 00:02:46,420
워크플로에는 여러 개의 다른 트리거가 있을 수 있습니다.

36
00:02:46,421 --> 00:02:49,108
같은 트리거를 여러 개 사용하거나

37
00:02:49,109 --> 00:02:53,181
더 복잡한 사용 사례를 위해 여러 개의
다른 트리거를 사용할 수도 있습니다.

38
00:02:53,240 --> 00:02:56,100
트리거는 워크플로를 시작하는 역할을 합니다.

39
00:02:56,380 --> 00:03:00,045
워크플로를 테스트할 때를 제외하고는,

40
00:03:00,046 --> 00:03:03,301
트리거가 실제로 작동하려면 활성화해야 합니다.

41
00:03:05,620 --> 00:03:09,958
캔버스에서 노드를 더블 클릭하면 해당 노드의

42
00:03:09,959 --> 00:03:13,640
전후 노드를 확인할 수 있습니다.

43
00:03:13,641 --> 00:03:19,420
이 작은 아이콘을 사용하여 워크플로를
구축하는 동안 이동할 수 있습니다.

44
00:03:19,720 --> 00:03:24,222
여기에 매우 간단한 예가
있습니다. "워크플로 실행"을 클릭하면

45
00:03:24,302 --> 00:03:29,200
Google Sheets, 필터, 그리고
필드 편집 노드가 나타납니다.

46
00:03:29,440 --> 00:03:33,059
필터 노드를 더블 클릭하면
왼쪽에는 Google Sheets가,

47
00:03:33,099 --> 00:03:36,400
오른쪽에는 필터 편집 노드가 있는 것을 볼 수 있습니다.

48
00:03:39,710 --> 00:03:43,890
또 다른 핵심 주제는 분기입니다.

49
00:03:43,891 --> 00:03:48,730
분기는 복잡한 워크플로를 구축할 때 매우 중요합니다.

50
00:03:49,090 --> 00:03:54,869
분기는 서로 다른 조건에 따라 서로 다른 경로 또는

51
00:03:54,870 --> 00:03:58,391
다른 작업 세트를 만드는 방법입니다.

52
00:03:59,470 --> 00:04:05,850
분기를 사용하면 하나의 워크플로가 단일 사례뿐만 아니라

53
00:04:05,851 --> 00:04:11,550
다양한 사례를 처리할 수 있는
복잡한 워크플로를 만들 수 있습니다.

54
00:04:12,750 --> 00:04:13,870
다양한 방법으로 사용할 수 있습니다.

55
00:04:13,871 --> 00:04:15,890
분기를 만드는 방법은 두 가지가 있습니다.

56
00:04:16,450 --> 00:04:21,350
첫 번째 방법은 여러 개의 출력
옵션이 있는 노드를 사용하는 것입니다.

57
00:04:21,830 --> 00:04:27,550
이 경우 각 항목은 여러 경로 중 하나만 따릅니다.

58
00:04:28,070 --> 00:04:33,350
예를 들어 여기에는 if 노드가 있고
if 노드에는 두 개의 출력이 있습니다.

59
00:04:33,550 --> 00:04:34,550
참과 거짓입니다.

60
00:04:35,050 --> 00:04:38,210
보시다시피 세 개의 입력 항목이 있습니다.

61
00:04:38,470 --> 00:04:43,770
그리고 하나의 항목만 참으로 갑니다.

62
00:04:43,870 --> 00:04:46,410
그리고 두 개의 항목은 거짓으로 갑니다.

63
00:04:46,610 --> 00:04:50,390
즉, 각 항목은 하나의 특정 경로만 따릅니다.

64
00:04:51,370 --> 00:04:55,921
분기를 만드는 또 다른 방법은 하나의 노드에서

65
00:04:55,922 --> 00:04:59,530
둘 이상의 출력 라인을 드래그하는 것입니다.

66
00:04:59,750 --> 00:05:04,352
이는 모든 항목이 모든 경로를 따르고

67
00:05:04,353 --> 00:05:08,190
경로 수만큼 복제되어 출력됨을 의미합니다.

68
00:05:08,410 --> 00:05:12,710
잠시 후에 이것이 어떻게 보이는지 살펴보겠습니다.

69
00:05:14,470 --> 00:05:20,110
여러 개의 출력 분기가 있는 노드에는 서로
다른 출력 항목 세트가 있을 것입니다. 물론이죠.

70
00:05:20,470 --> 00:05:27,170
그리고 이것들은 해당 노드의
출력 데이터에서 접근할 수 있습니다.

71
00:05:27,350 --> 00:05:33,650
예를 들어 여기에서 if 노드는 조건을 충족하는 항목과

72
00:05:33,651 --> 00:05:38,350
조건을 충족하지 않는 항목에
대한 출력 항목을 가지고 있습니다.

73
00:05:40,230 --> 00:05:43,710
이제 n8n으로 넘어가서 이 모든
것이 어떻게 보이는지 살펴봅시다.

74
00:05:45,450 --> 00:05:48,110
자, 여기 n8n으로 다시 돌아왔습니다.

75
00:05:48,510 --> 00:05:53,210
먼저 보여드리고 싶은 것은 트리거와 활성화입니다.

76
00:05:53,630 --> 00:05:57,781
우리가 구축하기 시작한 이 워크플로는

77
00:05:57,782 --> 00:06:01,510
이전에 Google 시트에서 일부
정보를 읽을 때 수동으로 실행했습니다.

78
00:06:01,670 --> 00:06:07,750
만약 이 워크플로를 매일 아침 8시에 실행하고 싶다면,

79
00:06:07,970 --> 00:06:11,550
스케줄 트리거를 사용할 수 있습니다.

80
00:06:11,551 --> 00:06:18,790
이를 통해 트리거 간격, 각 트리거 간의

81
00:06:18,791 --> 00:06:23,150
간격 일수, 트리거할 시간을 설정할 수 있습니다.

82
00:06:23,350 --> 00:06:30,970
이 경우 간격을 1일로 하여 매일 트리거하고 싶습니다.

83
00:06:31,230 --> 00:06:33,710
그리고 오전 8시에 트리거할 것입니다.

84
00:06:34,650 --> 00:06:39,590
여기에서 주어진 워크플로에 여러
개의 트리거가 있음을 볼 수 있습니다.

85
00:06:39,591 --> 00:06:43,840
그리고 여기서 이 단계를 테스트하고 싶다면,

86
00:06:43,841 --> 00:06:50,170
특정 날짜의 오전 8시가 아니더라도 실행됩니다.

87
00:06:51,490 --> 00:06:56,810
하지만 이 워크플로를 다 만들고 나서
실제로 매일 오전 8시에 실행하고 싶다면,

88
00:06:56,811 --> 00:07:02,870
워크플로가 활성화되었는지 확인해야 합니다.

89
00:07:03,210 --> 00:07:06,710
워크플로가 활성화되면 확인 메시지가 표시됩니다.

90
00:07:06,711 --> 00:07:11,691
이제 스케줄 트리거가 정의한
스케줄에 따라 실행을 트리거합니다.

91
00:07:11,830 --> 00:07:17,390
이제 이 수동 단계를 제거할 수 있습니다.

92
00:07:19,390 --> 00:07:23,210
워크플로를 활성화할 때마다 자동으로 저장됩니다.

93
00:07:23,550 --> 00:07:26,750
따라서 활성화하기 전에

94
00:07:26,751 --> 00:07:30,130
워크플로가 활성화될 준비가 되었는지 확인하십시오.

95
00:07:31,210 --> 00:07:33,910
자, 이 워크플로를 계속 만들어보겠습니다.

96
00:07:34,910 --> 00:07:38,910
Google Sheets 이후에 노드를 추가해 보겠습니다.

97
00:07:38,970 --> 00:07:42,350
먼저 데이터를 가져오기 위해 실행해 보겠습니다.

98
00:07:42,710 --> 00:07:47,552
상기시켜 드리자면, 여기에는

99
00:07:47,592 --> 00:07:50,850
이름, 성, 이메일, 회사 정보가
포함된 연락처 목록이 있습니다.

100
00:07:51,570 --> 00:07:55,043
여기서 하고 싶은 첫 번째 일은,

101
00:07:55,044 --> 00:07:57,930
이메일이 없는 사람들을 모두 제거하는 것입니다.

102
00:07:58,450 --> 00:08:00,850
이 모든 사람에게 이메일을
보내고 싶다고 가정해 보겠습니다.

103
00:08:01,150 --> 00:08:03,430
만약 이메일이 없는 사람이 있다면,

104
00:08:03,910 --> 00:08:06,250
그들에게 할 수 있는 것은 아무것도 없습니다.

105
00:08:06,390 --> 00:08:10,937
따라서 이메일이 없는 모든 연락처를

106
00:08:10,938 --> 00:08:14,711
필터링하기 위해 필터 노드를 사용하겠습니다.

107
00:08:15,810 --> 00:08:19,530
여기 필터 노드에는 조건이 있습니다.

108
00:08:19,910 --> 00:08:27,110
여기서 이메일이 문자열, 즉 일련의
문자와 특수 문자임을 확인하고 싶습니다.

109
00:08:27,290 --> 00:08:29,870
일련의 글자와 문자가 될 것임을 확인하고 싶습니다.

110
00:08:30,470 --> 00:08:33,410
그리고 그것이 존재해야 한다는 것을 확인하고 싶습니다.

111
00:08:34,350 --> 00:08:40,850
이 단계를 실행하면 10개에서 10개
항목으로 변경되지 않았음을 알 수 있습니다.

112
00:08:41,390 --> 00:08:45,260
이 경우 이메일이 비어있더라도

113
00:08:45,261 --> 00:08:48,950
빈 값을 가지고 있다는 것을 알 수 있습니다.

114
00:08:49,310 --> 00:08:54,775
따라서 이 경우 조건은 존재함이 아니라

115
00:08:54,776 --> 00:09:00,011
빈 문자열과 같지 않음이 되어야 합니다.

116
00:09:00,170 --> 00:09:05,930
여기서 이 단계를 다시 테스트하면 입력의
10개 항목에서 유지된 8개 항목으로 줄고,

117
00:09:05,931 --> 00:09:10,710
두 개의 항목은 폐기되었음을 알 수 있습니다.

118
00:09:11,770 --> 00:09:13,370
빈 이메일이 있는 항목입니다.

119
00:09:13,610 --> 00:09:17,146
여기서부터는 이메일을 가지고 있는 우리가

120
00:09:17,147 --> 00:09:21,171
작업하고 싶은 8개의 항목만 있습니다.

121
00:09:21,850 --> 00:09:27,910
여기서 우리는 생각해 볼 수
있습니다. "이 사람의 이메일 주소가

122
00:09:27,911 --> 00:09:34,753
개인 이메일 주소인지 직장 이메일 주소인지에
따라 다른 종류의 동작이 필요할 수 있다."

123
00:09:34,754 --> 00:09:39,890
또는 개인 이메일 주소인지 직장 이메일
주소인지에 따라 다른 동작을 원할 수 있습니다.

124
00:09:40,310 --> 00:09:43,410
여기서 if 노드를 추가할 수 있습니다.

125
00:09:45,270 --> 00:09:48,110
그리고 if 노드에 몇 가지 조건을 추가할 수 있습니다.

126
00:09:48,450 --> 00:09:53,650
JSON을 보면 여기에 Gmail

127
00:09:53,651 --> 00:09:57,851
주소, 일부 직장 이메일, 그리고 핫메일 주소가 있습니다.

128
00:09:58,610 --> 00:10:12,450
여기서 조건은 이메일에 gmail.com이
포함되지 않아야 한다는 것입니다.

129
00:10:13,490 --> 00:10:17,910
이를 통해 Gmail 주소를 필터링할 수 있습니다.

130
00:10:19,050 --> 00:10:22,590
두 번째 단계로 필터링할 수 있습니다.

131
00:10:24,090 --> 00:10:26,330
여기에서 gmail.fr을 볼 수 있습니다.

132
00:10:26,610 --> 00:10:28,570
그리고 핫메일 주소가 있습니다.
그리고 gmail.com이 있습니다.

133
00:10:29,150 --> 00:10:31,670
dot com을 제거하여 이 조건을 단순화함으로써

134
00:10:31,671 --> 00:10:36,230
Gmail이 있는 모든 것을 제거할 수 있습니다.

135
00:10:37,060 --> 00:10:40,630
그리고 조건을 추가할 때 조건을 추가할 수 있습니다.

136
00:10:41,190 --> 00:10:44,170
따라서 if 노드에 두 가지 조건이 있습니다.

137
00:10:44,310 --> 00:10:47,510
조건을 결합하는 방법을 결정해야 합니다.

138
00:10:48,510 --> 00:10:54,410
여기서는 이메일에 at Gmail이
포함된 모든 사람을 제외하고 싶습니다.

139
00:10:56,890 --> 00:11:00,450
또는 이메일에 at Hotmail이 포함된
모든 사람을 제외하고 싶습니다.

140
00:11:00,590 --> 00:11:03,730
이 경우 or 필터를 사용할 것입니다.

141
00:11:04,450 --> 00:11:06,990
다시 이메일을 드래그 앤 드롭합니다.

142
00:11:07,350 --> 00:11:15,310
그리고 Hotmail을 포함하지 않아야 합니다.
정확히는 at Hotmail이 더 나을 것입니다.

143
00:11:16,770 --> 00:11:18,310
이 단계를 테스트하면.

144
00:11:22,670 --> 00:11:26,330
이 단계를 테스트하면 항목이
하나도 없음을 볼 수 있습니다.

145
00:11:26,331 --> 00:11:28,430
실제로 거짓 분기로 이동했습니다.

146
00:11:28,690 --> 00:11:36,430
이는 우리가 전문 이메일 주소
분기를 만들고 있기 때문입니다.

147
00:11:36,630 --> 00:11:39,470
따라서 실제로 and 조건을 사용해야 합니다.

148
00:11:40,090 --> 00:11:44,830
전문 이메일 주소는 Gmail을 포함하지 않습니다.

149
00:11:44,990 --> 00:11:47,270
그리고 Hotmail을 포함하지 않습니다.

150
00:11:47,390 --> 00:11:48,690
여기서 이 단계를 테스트할 수 있습니다.

151
00:11:49,830 --> 00:11:53,370
여기에서 여러 분기가 있음을 알 수 있습니다.

152
00:11:53,371 --> 00:11:58,970
여기서 노드를 추가하면.

153
00:11:59,210 --> 00:12:02,330
그리고 여기 다른 하나를 추가합니다.

154
00:12:03,450 --> 00:12:05,790
그리고 이 if 노드를 다시 실행합니다.

155
00:12:05,950 --> 00:12:09,690
다섯 개의 항목이 이 분기로
올라가는 것을 볼 수 있습니다.

156
00:12:09,910 --> 00:12:12,790
그리고 세 개의 항목이 이 분기로 내려갑니다.

157
00:12:14,290 --> 00:12:15,850
만약 우리가...

158
00:12:16,450 --> 00:12:20,870
이를 통해 입력의 각 항목이

159
00:12:20,970 --> 00:12:23,450
이러한 분기 중 하나만 따라 내려가는
분기를 만들 수 있습니다. 이 경로들.

160
00:12:24,350 --> 00:12:30,870
필터 노드에서 다른 if를 드래그하면.

161
00:12:32,770 --> 00:12:34,990
그런 다음 약간 재정렬할 수 있습니다.

162
00:12:37,210 --> 00:12:38,790
더 잘 볼 수 있도록요.

163
00:12:40,290 --> 00:12:42,490
여기서 필터 노드를 실행합니다.

164
00:12:42,610 --> 00:12:44,310
이 경우에는 볼 수 있습니다.

165
00:12:44,450 --> 00:12:46,270
8개의 항목이 여기로 내려갑니다.

166
00:12:46,430 --> 00:12:48,070
그리고 8개의 항목이 여기로 내려갑니다.

167
00:12:48,450 --> 00:12:51,450
따라서 여러 출력을 드래그하면.

168
00:12:51,451 --> 00:12:53,630
동일한 노드에서.

169
00:12:53,770 --> 00:12:57,370
항목을 두 경로로 복제합니다.

170
00:12:57,710 --> 00:13:00,090
하지만 if를 만들면.

171
00:13:00,250 --> 00:13:03,070
또는 조건부 분기 집합을 만들면.

172
00:13:03,510 --> 00:13:08,310
항목을 다른 경로로 분할합니다.

173
00:13:09,750 --> 00:13:14,510
NLN 초급 강좌의 5번째 비디오를
시청해 주셔서 감사합니다.

174
00:13:14,790 --> 00:13:17,410
여기서 몇 가지 핵심 워크플로 개념을 다루었습니다.

175
00:13:17,530 --> 00:13:20,850
그리고 우리의 첫 번째 연결된 노드를 만들었습니다.

176
00:13:21,450 --> 00:13:23,010
다음 비디오에서는,

177
00:13:23,050 --> 00:13:25,630
매우 유용한 몇 가지 노드를 다룰 것입니다.

178
00:13:25,730 --> 00:13:26,990
워크플로를 구축할 때요.

179
00:13:27,530 --> 00:13:30,930
그리고 이 워크플로를 계속해서 만들어나갈 것입니다.

180
00:13:31,170 --> 00:13:33,550
더 복잡한 예시를 만들기 위해서입니다.

181
00:13:33,910 --> 00:13:35,270
다음 비디오에서 뵙겠습니다.

