1
00:00:00,000 --> 00:00:00,480
반갑습니다

2
00:00:00,540 --> 00:00:03,360
Jump to Python 강의를 시작해 보도록 하겠습니다

3
00:00:03,600 --> 00:00:07,700
일단은 책은 Jump to Python
계정판 교재 기준으로 진행이 되고요.

4
00:00:07,800 --> 00:00:11,420
Python 책이 없다 하시는 분들은
이 Wikidocs를 보셔도 됩니다

5
00:00:11,560 --> 00:00:13,080
종이책을 선호하시는 분들이 있죠?

6
00:00:13,160 --> 00:00:16,120
그래서 종이책을 선호하시는 분들은 이걸 보시면 되겠습니다

7
00:00:16,380 --> 00:00:20,720
Jump to Python 1장, 파이썬이란
무엇인가를 들어가 보도록 하겠습니다

8
00:00:21,140 --> 00:00:25,037
지은이 박웅용 선생님이 Jump to
Python을 지으신 저자 분이시고요

9
00:00:25,061 --> 00:00:27,040
저는 이제 강의를 맡게 되었습니다

10
00:00:27,220 --> 00:00:28,920
일단 파이썬 시작하기

11
00:00:29,020 --> 00:00:30,280
파이썬이란 무엇인가

12
00:00:30,420 --> 00:00:31,760
귀도 반 로섬

13
00:00:31,840 --> 00:00:34,980
이 취미로 만든 프로그래밍 언어가 파이썬입니다

14
00:00:35,140 --> 00:00:36,800
왜 취미로 만든 프로그래밍 언어냐

15
00:00:36,860 --> 00:00:40,120
그냥 장난이 아니고 진짜로
취미로 만든 프로그래밍 언어입니다

16
00:00:40,200 --> 00:00:44,140
어떤 건지 보여드리면 파이썬의
공식 홈페이지에 나온 내용입니다

17
00:00:44,300 --> 00:00:49,237
파이썬 공식 홈페이지에 귀도 반
로섬님께서 남기신 메시지가 있습니다

18
00:00:49,261 --> 00:00:50,960
I was looking for a hobby

19
00:00:51,100 --> 00:00:52,697
나는 취미를 찾고 있었다

20
00:00:52,721 --> 00:00:53,120
라고 합니다

21
00:00:53,260 --> 00:00:58,160
그래서 프로그래밍 프로젝트를
크리스마스 기간 동안에 회사가 쉬었다고 해요

22
00:00:58,220 --> 00:01:00,180
My office would be
closed 라고 되어 있죠

23
00:01:00,300 --> 00:01:03,440
그래서 크리스마스 기간 동안에는
보통 휴가 기간이 있을 수 있잖아요

24
00:01:03,680 --> 00:01:09,480
뭐 해볼 거 없을까 하고 취미를 찾다가 프로그래밍
언어나 한번 만들어 볼까 하고 만든 게 파이썬이라고 합니다

25
00:01:09,720 --> 00:01:16,020
이렇게 천재적인 프로그래머는 휴일 날이 있으면 지금
거의 세상을 지배하고 있는 언어를 만들 수가 있습니다

26
00:01:16,300 --> 00:01:19,236
아무튼 귀도 반 로섬님이 취미로 만든 프로그래밍 언어입니다

27
00:01:19,260 --> 00:01:23,500
언어가 1991년 공식적으로
파이썬이라는 언어를 최초 발표를 했고요

28
00:01:23,580 --> 00:01:31,580
그리고 2000년에 파이썬 버전 2가 나왔고 2008년에는 파이썬
버전 3가 발표되면서 지금까지도 파이썬 버전 3를 쓰고 있습니다

29
00:01:33,380 --> 00:01:40,500
파이썬 버전 4는 나온다는 얘기, 헛소문이 좀 돌다가
최근에 귀도 반 로섬이 공식적으로 발표를 했습니다

30
00:01:40,700 --> 00:01:41,760
이거 아직 멀었다

31
00:01:41,860 --> 00:01:49,217
4가 나오려면 멀었으니까 안심하고 파이썬 3를 쭉 써라 라고 말한 여러
자료들이 있는데 여러분들이 혹시 지금 파이썬 3를 공개하고 계신가요?

32
00:01:49,241 --> 00:01:57,241
공부하는데 버전이 바뀌어서 확 바뀌는 거 아니야 라고 걱정하시는 분들이
있을 것 같아서 당분간은 파이썬 3가 유지된다라는 최근 인터뷰가 있었습니다

33
00:01:57,600 --> 00:02:00,120
아무튼 파이썬 3를 이번에 배워볼 거고요

34
00:02:00,180 --> 00:02:04,040
그 다음에 구글에서 만들어진 소프트웨어에
50% 이상이 파이썬을 쓴다고 합니다

35
00:02:04,220 --> 00:02:06,700
그 정도로 엄청나게 파이썬이 많이 쓰이고 있고요

36
00:02:06,880 --> 00:02:10,840
인스타그램, 넷플릭스, 아마존
등에서도 당연히 파이썬을 사용 중입니다

37
00:02:10,960 --> 00:02:16,120
그리고 파이썬의 가장 큰 특징이 이해하기
쉬워서 공동작업과 유지 보수가 편합니다

38
00:02:16,300 --> 00:02:19,216
그래서 굉장히 쉬운 언어고 여러
명이 작업해도 이해가 가능합니다

39
00:02:19,240 --> 00:02:21,420
이해하기가 쉬워서 같이 작업하기가 좋습니다

40
00:02:21,540 --> 00:02:24,840
그래서 이렇게 파이썬에 대한 기초적인 내용을 말씀드렸고요

41
00:02:24,920 --> 00:02:26,820
추가로 이제 귀도 반 로썸이 누구냐?

42
00:02:26,860 --> 00:02:30,920
정말 옛날 분이어서 이미 돌아가셨냐라고
생각하실 수도 있는데 아닙니다

43
00:02:30,960 --> 00:02:34,840
이게 나름 젊지는 않은데 아무튼
활발히 활동 중이신 분입니다

44
00:02:35,000 --> 00:02:40,579
헛래서 56년생이시고 네덜란드 출신의 컴퓨터
프로그래머이신데 2005년 구글 드랍박스를

45
00:02:40,603 --> 00:02:45,260
거쳐서 현재는 2020년부터 마이크로소프트에
지금 잘 근무를 하고 잘 계십니다

46
00:02:45,340 --> 00:02:47,777
그래서 파이썬이란 언어의 기원

47
00:02:47,801 --> 00:02:55,801
그러니까 이름을 어디서 나왔냐라고 하면 이 몬티 파이썬 비행
서커스라는 코미디가 1969년부터 했던 되게 유명한 코미디 프로그램이 있습니다

48
00:02:57,020 --> 00:02:59,160
이 프로그램에 엄청난 팬이셨다고 해요

49
00:02:59,240 --> 00:03:01,680
그래서 파이썬이 여기서 이름을 따왔다고 합니다

50
00:03:01,820 --> 00:03:06,860
그리고 또 다른 의미로는 파이썬이
신화에 나오는 이 뱀 이름이 파이썬이거든요

51
00:03:07,080 --> 00:03:13,977
그래서 실제로 그 사이트에 파이썬을 아마 검색해보시는 분들
아시겠지만 이런 파이썬 이미지도 나오지만 뱀 이미지가 좀 나와요

52
00:03:14,001 --> 00:03:20,303
그래서 이 파이썬이 뱀도 있어서 그 신화에 나오는
그 뱀 따라서 로고는 이렇게 뱀 두 마리가 이렇게 있는

53
00:03:20,327 --> 00:03:26,480
이런 모양으로 만들어졌는데 기본적으로 이 파이썬
이름은 몬티 파이썬 비행 서커스에서 따왔다고 합니다

54
00:03:26,600 --> 00:03:32,168
그래서 이따가 소개해드릴 다른 것들
중에서도 여기서 따온 개념들이 좀 있어서 이거에

55
00:03:32,192 --> 00:03:36,480
엄청난 팬이 기도반 로섬님이 만드신
언어라고 간략하게 소개를 드릴 수가 있겠습니다

56
00:03:36,760 --> 00:03:38,600
그리고 이제 파이썬의 특징

57
00:03:38,660 --> 00:03:40,560
파이썬은 인간다운 언어입니다

58
00:03:40,640 --> 00:03:44,897
인간다운 게 뭐냐라고 하면 이게 지금
파이썬 문법으로 쓰인 코드이거든요

59
00:03:44,921 --> 00:03:52,921
그래서 코드를 보면 정말 이걸 통해서 처음 배우신 분도 있을 텐데
영어를 어느 정도 배우셨다면 어느 정도 뜻을 좀 유추를 해볼 수가 있습니다

60
00:03:53,100 --> 00:03:54,140
이거 뭘 것 같으신가요?

61
00:03:54,240 --> 00:03:56,260
If가 만약에라는 뜻이잖아요

62
00:03:56,320 --> 00:04:03,540
그래서 만약에 4가 요런데 안에 있다 이런
거니까 요런데 안에 4가 있으면 프린트 4가 있습니다

63
00:04:03,760 --> 00:04:09,131
이거는 정말 프로그래밍을 아예 처음
보는 사람도 어느 정도 뜻을 유추할 수 있을

64
00:04:09,155 --> 00:04:13,237
정도로 그만큼 그냥 거의 영어에 가까운
인간다운 언어라고 할 수 있겠습니다

65
00:04:13,261 --> 00:04:21,261
이게 실제로도 프로그래밍 실행을 해보면 1, 2, 3, 4라는 숫자 중에
4가 포함되어 있으면 이걸 실행해라 프린트가 출력하다라는 의미죠

66
00:04:22,460 --> 00:04:29,660
그래서 요 문자를 출력해라라는 뜻인데 그래서 영어만 안다면 어느
정도 이해할 수 있는 그런 쉬운 인간다운 언어라고 할 수 있겠습니다

67
00:04:29,840 --> 00:04:31,980
근데 다른 프로그래밍 언어는 그렇지가 않아요

68
00:04:32,120 --> 00:04:32,780
네 요런 거 있죠

69
00:04:32,900 --> 00:04:35,620
자바랑 비교해보면 자바는 아예 모르겠죠

70
00:04:35,680 --> 00:04:43,236
이게 만약에 프로그래밍을 처음 접해봤다라고 하면 퍼블릭이
뭐며 클래스가 뭐며 보이드는 또 뭐고 막 알 수가 없는 말이죠

71
00:04:43,260 --> 00:04:44,260
그 말들로 쫙 써져 있잖아요

72
00:04:44,460 --> 00:04:49,200
파이썬은 대충 그래도 영어만 알면 이해를
할 수가 있겠다 라고 알 수가 있겠습니다

73
00:04:49,400 --> 00:04:51,720
그래서 초보자분들이 배우기 정말 좋습니다

74
00:04:51,860 --> 00:04:54,900
그래서 문법이 쉽다라는 게 굉장히 큰 특징이고요

75
00:04:54,980 --> 00:04:57,360
빠르게 배울 수 있다도 굉장히 좋은 특징입니다

76
00:04:57,500 --> 00:05:00,920
그래서 대학교 교양 강의에서
파이썬이 굉장히 많이 활용이 되고 있고요

77
00:05:01,140 --> 00:05:07,380
프로그래밍 유경험자 즉 어떠한 프로그래밍 언어라도
배워보신 적이 있다라면 사실 일주일이면 충분합니다

78
00:05:07,560 --> 00:05:09,580
지금 6주 완성으로 강의를 잡아놨잖아요

79
00:05:09,740 --> 00:05:17,720
근데 그거는 정말 아예 프로그래밍을 처음 접하는 사람 기준이고
프로그래밍을 배워봤다라는 경험 자체가 있으면 일주일이면 사실 충분합니다

80
00:05:17,860 --> 00:05:21,660
그래서 정말 쉬운 언어라고 좀
특징을 소개해 드릴 수가 있겠습니다

81
00:05:21,880 --> 00:05:26,200
또 다른 특징 두 번째 소개해 드리면은 파이썬은 무료입니다

82
00:05:26,420 --> 00:05:27,500
그래서 오픈 소스고요

83
00:05:27,600 --> 00:05:34,540
여러분들이 얼마든지 다운받아서 쓰실 공짜로 쓰실 수가 있고
파이썬으로 만든 프로그램을 영리 목적으로 팔 수도 있습니다

84
00:05:34,760 --> 00:05:36,260
근데 무료지만 강력합니다

85
00:05:36,440 --> 00:05:40,877
그래서 사용료 걱정 없이 언제 어디서든
파이썬을 다운로드해서 쓸 수가 있고요

86
00:05:40,901 --> 00:05:46,820
파이썬은 C와 찰떡궁합이라고 하는데 이
강력하다의 의미가 이제 파이썬은 C와 찰떡궁합

87
00:05:46,900 --> 00:05:51,320
이게 어떤 거냐면 파이썬은 쉽고
빨리 배울 수 있는 대신에 약간 느립니다

88
00:05:51,460 --> 00:05:52,260
성능이 느려요

89
00:05:52,360 --> 00:05:59,040
성능이 느린 파이썬이랑 빠른 C 언어라는 언어가
따로 있는데 이 C 언어는 굉장히 속도가 빠릅니다

90
00:05:59,140 --> 00:06:00,820
대신 좀 문법이나 이런 건 어려워요

91
00:06:00,920 --> 00:06:03,780
이 둘을 굉장히 잘 결합해서 쓸 수가 있습니다

92
00:06:04,020 --> 00:06:05,580
그래서 접착 언어라고 하는데요

93
00:06:05,740 --> 00:06:10,876
즉 C라는 빠른 언어와 좀 느리지만 쉬운
파이썬이라는 언어랑 잘 붙여서 쓸 수 있습니다

94
00:06:10,900 --> 00:06:16,800
빠른 기능을 할 때는 C랑 결합해서
유용하게 쓸 수 있다는 것을 말씀드립니다

95
00:06:16,880 --> 00:06:18,197
그리고 파이썬 라이브러리

96
00:06:18,221 --> 00:06:26,221
라이브러리는 이제 뒤에 나올 개념인데 라이브러리 중에서도 C로 만들어진
것이 있어서 파이썬을 활용할 때 여러 라이브러리라는 걸 갖다 쓰게 되는데 이런

97
00:06:26,781 --> 00:06:31,817
numpy를 예로 들면 numpy라는
라이브러리를 갖다 쓰면 파이썬이지만 C 언어를

98
00:06:31,841 --> 00:06:36,280
사용하는 것처럼 굉장히 빠른 속도로 뭔가
일을 처리할 수 있는 것도 할 수가 있습니다

99
00:06:36,460 --> 00:06:40,397
이렇게 무료지만 강력한 언어인
파이썬을 배워보도록 하겠습니다

100
00:06:40,421 --> 00:06:46,560
근데 요즘에는 사실 파이썬 자체를 업그레이드해서
그걸 랩핑해서 모조라는 언어도 나오긴 했어요

101
00:06:46,680 --> 00:06:53,440
그래서 잠깐 소개를 드리면 요즘에는 파이썬 문법은
거의 똑같이 쓰는데 여기서 몇 가지만 좀 업그레이드해서

102
00:06:53,464 --> 00:06:59,940
파이썬 문법을 기본적으로 쓰지만 정말 빠른 모조라는
랭귀지도 나왔다라는 것을 짧게 한번 소개를 드립니다

103
00:07:00,160 --> 00:07:06,220
이제 아마 지금은 오픈베타 이런 상태여서 이게
신청해야 쓸 수 있고 심지어 오픈소스도 아니에요

104
00:07:06,400 --> 00:07:14,400
여기에 웨이트 리스트에 등록해야 쓸 수 있는데 아무튼 나중에... 이
중에는 이런 모조가 좀 대세가 될 수도 있지 않을까라는 생각이 듭니다

105
00:07:14,800 --> 00:07:22,100
암튼 이런 모조라는 언어도 나왔다는 점 간단하게 소개드리고
그만큼 이제 파이썬 기본 문법을 알면 확장할 여지가 굉장히 많죠

106
00:07:22,160 --> 00:07:24,140
그래서 이런 게 파이썬의 특징입니다

107
00:07:24,260 --> 00:07:30,546
근데 파이썬은 느리고 C 언어는 빠르다고 했는데
도대체 어디서 이 차이가 오느냐를 좀 간략하게

108
00:07:30,570 --> 00:07:36,620
소개를 드리면 프로그래밍 언어에는 컴파일
언어라는 게 있고 인터프리터 언어라는 게 있습니다

109
00:07:36,820 --> 00:07:44,540
그래서 두 개의 특징이 좀 다른데 이게 어떤 의미인지를 좀
이해하면은 왜 이건 빠르고 왜 이건 느리지라는 걸 좀 이해하기가 좋은데요

110
00:07:44,580 --> 00:07:48,240
컴퓨터는 기본적으로 이런 CPU 같은 걸로 연산을 하잖아요

111
00:07:48,360 --> 00:07:51,960
근데 CPU가 연산을 할 때는
0과 1밖에 인식을 하지 못합니다

112
00:07:52,280 --> 00:08:00,280
그러니까 전원이 꺼진 거 켜진 것을 처리를 하면서 결국에 엄청
복잡한 처리들을 진행을 하는 건데 그렇다는 거는 이런 식으로 막 10010

113
00:08:00,801 --> 00:08:06,880
010 이런 막 복잡한 코드로 입력을 해야
사실 컴퓨터가 알아듣고 실행을 할 수가 있어요

114
00:08:06,960 --> 00:08:07,377
기본적으로

115
00:08:07,401 --> 00:08:09,180
그렇다면은 좀 불편하겠죠

116
00:08:09,280 --> 00:08:13,939
왜냐면 개발자가 프로그래밍 개발하려고
하면 컴퓨터가 알아듣게 한다고 해서 막

117
00:08:13,963 --> 00:08:18,160
이런 101010 이렇게 코딩을
하게 되면 사람이 알 수가 없잖아요

118
00:08:18,320 --> 00:08:25,100
그래서 진정한 프로그래머는 1과 0으로만 코딩한다
라고도 하는데 이렇게 하면은 코딩하기가 너무 어렵겠죠

119
00:08:25,300 --> 00:08:26,680
그래서 이런 걸 씁니다

120
00:08:26,760 --> 00:08:33,360
원래 사람도 그냥 예를 들어 영어로 얘기하고 싶은데 이렇게
한국말로 한 다음에 구글 번역기 같은 거 돌려서 영어로 뽑잖아요

121
00:08:33,560 --> 00:08:38,874
이런 것처럼 컴퓨터 프로그래밍 언어도
한국어는 아니겠지만 파이썬 뭐 C 이런 거를

122
00:08:38,898 --> 00:08:43,640
C 언어 이런 걸 입력한 다음에 이거를
컴파일러라는 걸 돌려서 이게 번역기입니다

123
00:08:43,740 --> 00:08:47,700
그래서 번역기로 이제 기계가 이해할
수 있는 언어를 만들어내게 됩니다

124
00:08:47,880 --> 00:08:55,300
그래서 이런 방식으로 컴파일러를 거쳐서 해독을 해서
결국에는 이 010 101 이 형태로 컴퓨터에 입력을 하게 되는데요

125
00:08:55,420 --> 00:09:03,420
그러면 이제 컴파일 언어와 인터프리터 언어가 어떻게 다른지 이 개념을
이해한 다음에 생각을 해보면 C 언어의 경우에는 이렇게 코드를 쭉 작성해서 뭐

126
00:09:04,581 --> 00:09:12,581
헬로우랑 월드 이런 거를 출발하고 출력해주는 코드를 작성했다고
하면 기본적으로 C 언어 코드를 작성한 다음에 컴파일러를 먼저 돌립니다

127
00:09:13,120 --> 00:09:21,120
그래서 컴파일러를 돌려서 이렇게 실행할 수 있는 기계어에 가까운 이런
프로그램을 만들어 놓고 이거를 실행하기 때문에 속도 면에서는 굉장히 빠릅니다

128
00:09:21,960 --> 00:09:23,660
근데 파이썬은 반면에 왜 느리냐

129
00:09:23,720 --> 00:09:28,300
이렇게 파이썬 코드가 작성이 돼 있으면
한 줄씩 한 줄씩 읽어서 해석을 합니다

130
00:09:28,460 --> 00:09:36,460
한 줄 읽고 인터프리터 거쳐서 컴퓨터한테 보내고 월드 한 줄 읽고
인터프리터 거쳐서 컴퓨터한테 보내고 이런 식으로 동작하기 때문에 느립니다

131
00:09:37,060 --> 00:09:39,836
C 언어는 바로 실행 프로그램이 들어가서 빠르죠

132
00:09:39,860 --> 00:09:45,080
이런 속도 차이가 이래서 생긴다라는 간단한
설명 한번 쭉 드리고 진행을 해보겠습니다

133
00:09:45,360 --> 00:09:50,629
그래서 여기까지 컴파일 언어, 인터프리터 언어라는 걸
소개해 드리면서 파이썬은 이런 인터프리터 언어라 조금

134
00:09:50,653 --> 00:09:57,260
느리지만 그래도 C 언어랑도 결합할 수 있고 모조라는
것도 나오고 해서 되게 강력하게 업그레이드 되고 있습니다

135
00:09:57,540 --> 00:09:59,560
세 번째 특징을 들어가 보도록 하겠습니다

136
00:09:59,800 --> 00:10:02,080
세 번째 특징은 파이썬은 간결합니다

137
00:10:02,220 --> 00:10:07,036
간결한 게 어떤 특징이 있냐면
파이썬은 가장 좋은 방법 한 가지입니다

138
00:10:07,060 --> 00:10:08,480
한 가지만 이용하는 것을 선호합니다

139
00:10:08,600 --> 00:10:14,200
파이썬이 카다라는 표현도 있을 정도로
파이썬 문법에 딱 맞는 그 규격이 있어요

140
00:10:14,300 --> 00:10:21,340
규격이라 하면은 이런 들여쓰기, 실행이 되게 하려면
줄을 맞춰야 한다던가 이런 규칙이 굉장히 엄격한 편입니다

141
00:10:21,520 --> 00:10:25,040
그래서 파이썬의 코드를 보면은 파이썬 코드인데요

142
00:10:25,840 --> 00:10:29,340
4라는 문법 아래에 들여쓰기가 들어가 있습니다

143
00:10:29,700 --> 00:10:31,700
이거를 만약에 안 지켜서 이렇게 쓰게 된다?

144
00:10:31,760 --> 00:10:32,560
오류가 납니다

145
00:10:32,780 --> 00:10:37,017
그래서 무조건 들여쓰기를 통해서
깔끔하게 이렇게 컴퓨터를 사용할 수 있습니다

146
00:10:37,041 --> 00:10:39,600
코드가 정리되도록 하는 거를 강제하고 있습니다

147
00:10:39,780 --> 00:10:46,320
그래서 이상하게 막 들여쓰기 하면은 오류가 나서
간결하게 표현할 수밖에 없는 그런 언어라고 할 수 있습니다

148
00:10:46,460 --> 00:10:50,360
그러니까 뭐 비유하자면 집
정리를 할 수밖에 없게 만든 거예요

149
00:10:50,480 --> 00:10:52,580
안 그러면 뭐 뭘 할 수가 없어요

150
00:10:52,940 --> 00:10:55,120
그러니까 밥을 먹기 전에 집 정리가 안 돼 있다?

151
00:10:55,240 --> 00:10:56,700
그러면 밥을 못 먹게 해요

152
00:10:56,740 --> 00:10:56,960
여기는

153
00:10:57,140 --> 00:11:03,340
그런 것처럼 파이썬도 이렇게 문법을 깔끔하게
지켜야지만 실행을 할 수가 있고 실행이 안 됩니다

154
00:11:03,640 --> 00:11:08,670
그래서 다른 언어 뭐 자바스크립트 이런 거
배우신 분들은 중괄호 이런 거 써가지고 조금

155
00:11:08,694 --> 00:11:14,240
이상하게 써도 다 동작을 하는데 얘는
무조건 들여쓰기로 깔끔하게 써야 동작이 됩니다

156
00:11:14,420 --> 00:11:20,420
그 다음에 특징 또 네 번째를 소개해 드리면
프로그래밍을 즐기게 해주는 특성이 있습니다

157
00:11:20,940 --> 00:11:28,580
이게 굉장히 큰 특성 중에 하나인데 부수적인
개념이나 제한사항을 굉장히 적게 알아도 쓸 수가 있습니다

158
00:11:28,960 --> 00:11:32,840
다시 한번 자바를 예로 들어
설명드리면 알아야 될 게 많아요

159
00:11:33,180 --> 00:11:36,997
자, 자바 언어를 보면은 퍼블릭이니 클래스니...
자, 자바 언어를 보면은 퍼블릭이니 클래스니...

160
00:11:37,021 --> 00:11:42,980
이런 개념을 몰라도 실행은 할 순 있겠지만
이게 막 들어가 있으니까 알아야 돼요

161
00:11:43,060 --> 00:11:47,560
그러니까 약간 개념 공부하다 보면 아
이게 뭐야 라고 하면서 좀 거슬리잖아요

162
00:11:47,820 --> 00:11:52,417
아 클래스가 이런 개념이고 퍼블릭이란
건 이런 개념이고 다 쓸데없는 사실

163
00:11:52,441 --> 00:11:57,060
쓸데없지는 않은데 처음에 굳이 머리
아프게 배울 필요가 없는 것들을 배워야 돼요

164
00:11:57,160 --> 00:12:04,776
막 나는 지금 빨리 주식투자 자동화 혹은 컴퓨터 자동화를
하고 싶은데 이런 쓸데없는 거 배우는데 시간을 낭비해야 된다

165
00:12:04,800 --> 00:12:07,000
라는 굉장히 좀 머리 아프게 배우는 개념을 배워야 됩니다

166
00:12:07,920 --> 00:12:15,860
부수적인 개념을 알 필요조차 없어요

167
00:12:16,300 --> 00:12:17,820
기능에만 집중할 수 있도록 합니다

168
00:12:17,960 --> 00:12:23,500
사실 프로그래밍의 본질이 내가 원하는 걸
자동화한다거나 프로그램을 만든다거나 이런 거잖아요

169
00:12:23,580 --> 00:12:27,260
그런데 쓸데없는 개념을 배우느라
이거에 집중할 수가 없는데 다른 거는

170
00:12:27,420 --> 00:12:35,257
그런데 얘는 정말 깔끔하게 기능에만 집중할 수 있도록 도와주는 게
있어서 파이썬이 그런 면에서는 프로그래밍을 즐기게 해준다는 특징이 있습니다

171
00:12:35,281 --> 00:12:39,480
이렇게 간결하고 필요한 것만 쓰는
만큼 파이썬은 개발 속도가 빠릅니다

172
00:12:39,560 --> 00:12:42,760
이 책에서 굉장히 많이 나오는
비유 중에 하나가 Life is too short

173
00:12:42,820 --> 00:12:45,500
너의 인생은 너무 짧기 때문에 유닛 파이썬

174
00:12:45,640 --> 00:12:46,640
파이썬이 필요하다

175
00:12:46,720 --> 00:12:54,720
너가 만들어야 될 거는 엄청 많은데 자바나 이런 거 쓰고 있으니 너무
길게 써야 되니까 파이썬으로 짧고 강렬하게 원하는 기능만 개발해라

176
00:12:54,760 --> 00:12:56,576
라는 이런 메시지가 잘 담겨있죠

177
00:12:56,600 --> 00:12:59,440
그래서 파이썬을 쓰면 빠른 속도로 개발을 할 수가 있습니다

178
00:13:00,060 --> 00:13:01,620
다음으로 이제 1-3

179
00:13:01,680 --> 00:13:04,517
파이썬으로 무엇을 할 수 있을까를 나가보도록 하겠습니다

180
00:13:04,541 --> 00:13:08,140
그럼 파이썬을 배우고 뭘 할 수 있냐를
하나씩 소개해드리도록 하겠습니다

181
00:13:08,320 --> 00:13:10,320
웹 프로그래밍이 좀 대표적입니다

182
00:13:10,700 --> 00:13:12,380
대표적까지는 아니고 그래도 많이 쓰입니다

183
00:13:12,520 --> 00:13:17,858
파이썬으로 할 수 있는 일 중에 웹
프로그래밍을 소개해드리면 장고, 플라스크, 패스트

184
00:13:17,882 --> 00:13:22,280
API 이런 것들이 있는데 이게 웹의 백엔드
서버를 주로 만들 때 많이 사용이 됩니다

185
00:13:22,520 --> 00:13:27,969
그래서 이런 서버를 만드는 것도 파이썬을
이용해서 프레임워크라고 하고 라이브러리라고

186
00:13:27,993 --> 00:13:32,360
부르기도 하는데 파이썬의 확장판
같은 그런 설치해서 쓸 수 있는 개념이에요

187
00:13:32,460 --> 00:13:36,682
그래서 파이썬 언어를 이용해서 이런
식으로 웹 개발도 진행할 수 있다는 걸

188
00:13:36,706 --> 00:13:40,980
소개해드리고 또 최근에 나온 개념을 좀
소개해드리면 최근에 이런 것도 나왔습니다

189
00:13:41,200 --> 00:13:43,300
리액트 파이라는 것도 나왔어요

190
00:13:43,420 --> 00:13:51,420
그래서 아마 프론트엔드 개발, 백엔드 서버를 개발한다고 하면 기본적으로
장고, 플라스크, 패스트 API 이런 프레임워크들을 사용하게 되는데 근데

191
00:13:52,381 --> 00:13:56,820
요즘에는 웹 프론트엔드 개발이 원래
리액트라는 걸 굉장히 많이 쓰고 있거든요

192
00:13:57,080 --> 00:13:58,400
자바스크립트 쪽으로

193
00:13:58,460 --> 00:14:03,960
리액트 파이라는 게 나와서 파이썬을 이용해서
리액트 문법 비슷하게 쓸 수 있도록 나왔습니다

194
00:14:04,160 --> 00:14:07,140
웹 개발에 리액트도 파이썬으로 쓸 수 있다

195
00:14:07,220 --> 00:14:10,580
그래서 웹 프로그래밍에도
사용될 수 있다는 걸 소개해드렸고요

196
00:14:10,680 --> 00:14:18,127
굳이 장고랑 차이를 좀 말씀드리면 장고는 복잡한 걸 여러
개를 막 묶어가지고 굉장히 무거울 수 있는데 여러 가지를

197
00:14:18,151 --> 00:14:24,360
다 묶어서 웹 개발을 편리하게 해줄 수 있다고 설명을
드릴 수 있고 패스트 API나 플라스크는 굉장히 가벼워요

198
00:14:24,480 --> 00:14:27,620
그래서 가볍게 웹 서버를 만들
때는 이것이 굉장히 편리합니다

199
00:14:28,000 --> 00:14:33,520
그리고 또 다음으로 인공지능과 머신러닝 이것
때문에 아마 파이썬을 배우시는 분들이 꽤 많을 것 같아요

200
00:14:34,160 --> 00:14:37,920
인공지능과 머신러닝은 파이썬으로
웬만한 게 가장 먼저 출시가 됩니다

201
00:14:38,060 --> 00:14:45,100
그래서 대표적인 인공지능으로 무언가를 만든다고 했을 때
텐서플로우, 파이토치 이런 거를 기본적으로 쓰게 되는데요

202
00:14:45,220 --> 00:14:49,720
이것도 프레임워크라고 불리는 어떻게
보면 파이썬의 확장 도구 같은 개념입니다

203
00:14:49,840 --> 00:14:57,840
그래서 파이썬 언어를 배우고 나시면 텐서플로우, 파이토치 이런 개념을 또
배우고 나면 인공지능을 모델을 학습시키거나 이럴 때도 보통 사용되는 이런

204
00:14:58,121 --> 00:15:03,344
프레임워크를 다룰 수 있는 웬만한 인공지능에서
뭔가 나왔다 라고 하면 가장 먼저 텐서플로우,

205
00:15:03,368 --> 00:15:08,200
파이토치, 기반으로 출시가 되니까 파이썬은
배워두시면 인공지능에 굉장히 도움이 됩니다

206
00:15:08,400 --> 00:15:10,180
그 다음에 수치연산 프로그래밍

207
00:15:10,240 --> 00:15:17,880
앞서 잠깐 언급드렸던 numpy라는 C언어 기반으로 만들어졌던
라이브러리를 이용하면 수치연산, 막 행렬 계산 있잖아요

208
00:15:18,120 --> 00:15:26,120
인공지능에도 이게 연관이 돼 있는데 막 무슨 행렬을 곱하고 더하고 하는 게
굉장히 연산이 많이 필요한데 이것도 numpy라는 라이브러리를 이용하면 이게.

209
00:15:26,581 --> 00:15:31,600
C 기반으로 만들어져서 굉장히 빠른 속도로
이런 복잡한 연산들을 처리할 수가 있습니다

210
00:15:31,820 --> 00:15:36,283
그리고 데이터 분석 때문에 또 파이썬은
파이썬을 배우시는 분도 많을 텐데 판다스라는

211
00:15:36,307 --> 00:15:40,260
라이브러리 이런 게 너무 잘 돼있어서
뭐 쉽게 말하면 엑셀 같은 개념이죠

212
00:15:40,320 --> 00:15:48,320
그래서 파이썬으로 엑셀 데이터를 불러와서 거기서 막 연산을 해서 그래프를
그리거나 아니면 뭐 컬럼을 나눠서 컬럼을 추가하고 뭐 데이터를 복합하거나

213
00:15:49,301 --> 00:15:54,387
이런 것들을 할 수 있는 게 판다스라는
라이브러리인데 이것 또한 파이썬 기반으로

214
00:15:54,411 --> 00:15:58,720
돼있어서 파이썬을 배우면 다음 진도로
이런 것들을 쉽게 진행을 하실 수가 있습니다

215
00:15:58,900 --> 00:16:00,276
파이썬으로 무엇을 할 수 있을까?

216
00:16:00,300 --> 00:16:03,000
두 번째 데이터베이스 프로그래밍도 할 수가 있습니다

217
00:16:03,160 --> 00:16:10,500
이거는 뭔 말이냐면 SQLite, MySQL 이런 데이터베이스가
어떤 거냐면 그냥 쉽게 말해서 정말 데이터를 저장하는 공간인데요

218
00:16:10,620 --> 00:16:15,580
좀 예시로 보여드리면, 쉬운 예시가 오늘
여러분들의 출석부를 한번 보도록 하겠습니다

219
00:16:15,840 --> 00:16:20,600
오늘 출석 체크를 여러분들이 남겨주시면
이런 식으로 데이터베이스가 생기게 됩니다

220
00:16:20,840 --> 00:16:22,980
이것도 DB라고도 볼 수 있겠고요

221
00:16:23,020 --> 00:16:31,020
이런 식으로 데이터가 쌓여있는 것을 관리해주는 도구가
DBMS 도구라고 이렇게 SQLite, MySQL 이런 프로그램들이 있어요

222
00:16:31,640 --> 00:16:35,440
그래서 이런 거를 쉽게 파이썬이랑
소통하면서 조작을 해줄 수가 있습니다

223
00:16:35,600 --> 00:16:38,860
그래서 여기서도 파이썬이 사용이 되고 또 시스템 유틸리티

224
00:16:38,900 --> 00:16:43,620
시스템 유틸리티는 뭐냐면 요즘에는 이런
거 많이 잘 안 쓰이는데 막 이런 거 있잖아요

225
00:16:43,820 --> 00:16:48,060
무슨 하드디스크 최적화니 뭐 프로그램
삭제 관리 뭐 이런 거 하는 거 있죠

226
00:16:48,180 --> 00:16:52,280
이런 프로그램을 만들 때도 시스템
유틸리티 만들 때도 파이썬이 사용됩니다

227
00:16:52,480 --> 00:16:54,180
그래서 이거는 어떻게 만드냐

228
00:16:54,240 --> 00:16:59,820
이 뒤에 거랑도 연결돼 있는데 GUI 프로그래밍이라고
해서 그래픽 유저 인터페이스의 약자인데요

229
00:16:59,940 --> 00:17:03,076
그래픽을 이용해서 즉 클릭 클릭하면 창이 열리고요

230
00:17:03,100 --> 00:17:11,100
이런 것들도 만들 수 있습니다

231
00:17:21,480 --> 00:17:27,736
그래서 GUI 프로그래밍이나 시스템 유틸리티
이런 것도 만들 수 있고 또 아까 설명드렸던 CC++와

232
00:17:27,760 --> 00:17:32,820
결합해서 속도 빠르게 진행할 것들은 이렇게
속도 빠르게 결합해서 진행을 할 수가 있습니다

233
00:17:33,100 --> 00:17:35,640
그리고 사물인터넷과도 결합할 수 있는데요

234
00:17:35,800 --> 00:17:40,880
사물인터넷이 뭐냐면 이런 작은
인터넷과 연결 가능한 디바이스가 있습니다

235
00:17:41,080 --> 00:17:49,080
이 기기가 Raspberry Pi라는 기기를 제가 예시로 갖고 왔는데
이런 기기가 파이썬을 이용해서도 조작할 수 있는 그런 컴퓨터입니다

236
00:17:49,460 --> 00:17:56,180
이걸 이용해서 스마트 스피커 이런 걸 만들거나
아니면 그냥 개인용 서버를 돌려놓고 여기서 쓸 수도 있겠죠

237
00:17:56,320 --> 00:18:04,140
어떻게 보면 새로운 컴퓨터 하나를 사물인터넷과 연결된 컴퓨터
이런 작은 컴퓨터도 파이썬으로 조작해서 뭔가를 만들 수가 있습니다

238
00:18:04,300 --> 00:18:11,057
거의 사용이 안 되는 곳이 없다고 할 정도로 파이썬이
이만큼 다양한 곳들이랑 연계가 될 수 있으니까요

239
00:18:11,081 --> 00:18:12,460
꼭 배워두면 좋겠죠

240
00:18:12,600 --> 00:18:14,360
이런 것들을 할 수가 있다

241
00:18:14,460 --> 00:18:18,820
그러니까 열심히 배워야 된다는 동기부여를 드리고 있습니다

242
00:18:19,040 --> 00:18:20,960
그러면 할 수 없는 것도 있겠죠

243
00:18:21,100 --> 00:18:24,260
할 수 있는 것도 있다면
파이썬으로 할 수 없는 일도 있습니다

244
00:18:24,480 --> 00:18:29,480
이런 목표를 가지고 있다라고 하면 파이썬보다는
다른 언어로 보시는 것을 추천드립니다

245
00:18:29,720 --> 00:18:33,200
시스템과 밀접한 프로그래밍 영역은 할 수가 없습니다

246
00:18:33,460 --> 00:18:41,060
나는 윈도우라는 운영체제를 만들고 싶어 리눅스라는
운영체제를 만들고 싶어 라고 한다면 파이썬이 좀 맞지는 않습니다

247
00:18:41,160 --> 00:18:49,160
왜냐하면 파이썬이 아까도 말씀드렸듯이 인터프리터 언어이기도 하고 고급
언어, 저급 언어가 나눌 수 있는데요 고급 언어라고 하면 좀 더 어플리케이션을

248
00:18:49,381 --> 00:18:57,340
만들거나 이런 단위고 저급 언어라고 하면 정말 기계와 맞닿아 있는
시스템 이런 걸 만드는 언어인데 사실 파이썬은 좀 고급 언어에 가깝습니다

249
00:18:57,440 --> 00:19:05,440
즉 어플리케이션 단에 프로그램을 만드는 데 사용되고 정말
운영체제나 기계와 정말 밀접적인 것들은 좀 맞지가 않습니다

250
00:19:05,780 --> 00:19:11,380
시스템 밀접 프로그래밍 영역과는 맞지 않는다 라는 걸
소개해드렸고 또 모바일 프로그래밍이란 도 맞지 않습니다

251
00:19:11,560 --> 00:19:13,140
앱 개발하고 싶으신 분들 있죠

252
00:19:13,240 --> 00:19:18,740
구글 플레이스토어에 올라가는 앱, 앱스토어에
올라가는 앱 이런 것들은 사실 다른 언어가 더 적합합니다

253
00:19:18,920 --> 00:19:24,601
뭐 리액트 네이티브 이런 걸로 만들 수도 있고
플러터 이런 거 만들 때는 자바스크립트 혹은 뭐 다트

254
00:19:24,625 --> 00:19:30,377
이런 언어가 사용되는데 그게 더 적합하고 파이썬은
이 모바일 앱을 만들더라도 여기에 백엔드 있죠

255
00:19:30,401 --> 00:19:35,058
그러니까 서버에서 처리하는 것들이 무조건
필요할 텐데 그때는 당연히 파이썬이 사용될

256
00:19:35,082 --> 00:19:39,020
수 있는데 이런 어플리케이션 화면단을
만들 때는 파이썬이 적합하지는 않습니다

257
00:19:39,060 --> 00:19:45,380
그래서 모바일 프로그래밍에는 좀 다른 언어 예를
들어 자바스크립트나 다트 요즘 그 플러터가 뜨고 있죠

258
00:19:45,440 --> 00:19:53,420
자바스크립트로 뭐 리액트 네이티브나 아니면 각각 네이티브로
만들려면 자바 코틀린 혹은 이 iOS는 스위프트 이런 것을 배우면 좋겠죠

259
00:19:53,540 --> 00:19:59,340
그래서 이 모바일 프로그래밍은 더 적합한 언어가
있으니 좀 적합한 것과 적합하지 않은 것을 소개를 드렸습니다

260
00:19:59,460 --> 00:20:01,776
그래서 이런 거 이런 것들을 할 수 있으니까요

261
00:20:01,800 --> 00:20:04,600
끝까지 배워서 이런 것들을 같이 해보면 좋을 것 같습니다

262
00:20:04,860 --> 00:20:08,240
네 그러면 이제 이론 강의는 어느 정도 설명을 드렸고요

263
00:20:08,300 --> 00:20:11,820
이제 파이썬을 직접적으로 설치를
해서 한번 실행을 해보도록 하겠습니다

264
00:20:12,040 --> 00:20:15,740
파이썬 언어 패키지를 다운로드하고
설치를 해보도록 하겠습니다

265
00:20:16,080 --> 00:20:17,800
이게 가장 어려운 부분일 수 있습니다

266
00:20:17,940 --> 00:20:21,520
이게 가장 많이 막혀서 처음에
시작을 못하는 분들이 많으니까요

267
00:20:21,600 --> 00:20:25,980
한번 이 막힐 수 있는 부분들을 제가 하나씩
뚫어드리면서 설명을 드리도록 하겠습니다

268
00:20:26,200 --> 00:20:28,300
파이썬 설치하기 함께 진행을 해보겠습니다

269
00:20:28,540 --> 00:20:36,540
파이썬 설치하기는 일단 python.org라는 파이썬 공식 홈페이지에
들어가서 일단 여기서 파이썬을 다운받고 설치를 하실 수가 있습니다

270
00:20:37,240 --> 00:20:40,100
네, 이거는 책에도 27페이지입니다

271
00:20:40,220 --> 00:20:41,600
책에 27페이지

272
00:20:41,700 --> 00:20:45,920
여기에서 기준은 3.11.2 버전 기준으로 돼 있죠?

273
00:20:46,040 --> 00:20:48,260
그래서 이거 맞춰서 한번 가보도록 하겠습니다

274
00:20:48,700 --> 00:20:51,760
다운로드 보면은 지금은 3.11.4에요

275
00:20:51,860 --> 00:20:57,737
다운로드에서 그냥 기본적으로 제일 위에 있는 요거를
누르면 가장 최신 버전이 지금 여기 위에 나와 있습니다

276
00:20:57,761 --> 00:21:01,920
그래서 이거를 설치하셔도 물론 되는데,
근데 책이랑 한번 똑같이 가보도록 하겠습니다

277
00:21:02,100 --> 00:21:04,940
왜냐하면은 특정 버전에 안 되는 게 있을 수가 있어요

278
00:21:05,060 --> 00:21:08,880
그래서 특정 버전의 파이썬을 설치하는
방법도 알려드리도록 하겠습니다

279
00:21:09,140 --> 00:21:15,640
그러면 일단 요거는 취소하고, 그러면 다운로드에서 특정
버전의 파이썬을 다운받는 방법을 알아보도록 하겠습니다

280
00:21:15,940 --> 00:21:20,040
뭐 책에도 나온 3.11.2 버전을
한번 다운받아보도록 하겠습니다

281
00:21:20,220 --> 00:21:21,220
그러려면 어떻게 해야 되냐?

282
00:21:21,260 --> 00:21:24,460
여기 다운로드 탭에 보면 윈도우랑 맥OS가 나눠져 있습니다

283
00:21:24,640 --> 00:21:32,300
그래서 일단 저는 윈도우 기준으로 설명드리고, 나중에 편집본 올라갈
때 맥 용도 따로 그거는 녹화 영상으로 포함을 해드리도록 하겠습니다

284
00:21:32,460 --> 00:21:38,140
그래서 윈도우로 들어가셔서 책과 똑같이
3.11.2 버전을 받아보도록 하겠습니다

285
00:21:38,340 --> 00:21:41,840
그러면은 3.11.2 버전이 이렇게 쭉 나오게 되는데요

286
00:21:41,960 --> 00:21:49,896
요거는 이제 예를 들어 다른 버전을 쓸 때는 다른
강의나 다른 뭐 어떤 프로젝트에는 3.8 버전을 써야 된다

287
00:21:49,920 --> 00:21:53,660
이런 경우에는 뭐 3.8 이렇게
검색을 해서 찾을 수가 있겠죠

288
00:21:53,800 --> 00:21:56,916
근데 저는 책이랑 똑같이 3.11.2 버전입니다

289
00:21:56,940 --> 00:21:58,980
그래서 3.11.2 버전을 찾아서
설치를 해보도록 하겠습니다

290
00:21:59,100 --> 00:22:02,980
그럼 3.11.2를 보면은 이렇게 또
다운받을 수 있는 게 굉장히 많아요

291
00:22:03,040 --> 00:22:04,840
그래서 이 중에 뭘 설치해야 되냐?

292
00:22:04,880 --> 00:22:07,360
여기 윈도우스 인스톨러라고 돼 있는 게 있습니다

293
00:22:07,540 --> 00:22:13,920
그래서 요거를 자기 컴퓨터에 맞게 설치를 해주시면
되는데, 웬만하면은 64비트를 다운받아 주시면 됩니다

294
00:22:14,140 --> 00:22:20,000
근데 또 이것도 가끔 라이브러리마다 막 32비트가
무조건 필요하다라는 라이브러리도 있습니다

295
00:22:20,320 --> 00:22:25,600
그러려면 그냥 윈도우 인스톨러 32비트를
64비트 컴퓨터에 깔아도 상관은 없습니다

296
00:22:25,780 --> 00:22:33,780
그래서 이 비트는... 이 시스템 정보란에 있는데, 혹시 모르는데...
네, 그냥 웬만한 요즘 컴퓨터는 사실 64비트를 받으시면 됩니다

297
00:22:34,000 --> 00:22:37,760
그래서 3.11.264비트를 다운받아 보도록 하겠습니다

298
00:22:38,260 --> 00:22:41,820
네, 주식투자 자동화 강의에서 제가
요거를 굳이 설치하는 강의도 있습니다

299
00:22:42,060 --> 00:22:47,500
그래서 이거는 그 라이브러리에 따라서 호환이
안 되는 게 있어서 그거 때마다 바꿔주시면 되고요

300
00:22:47,760 --> 00:22:50,060
기본적으로는 64비트를 써주시면 됩니다

301
00:22:50,280 --> 00:22:54,756
파이썬 3.11.2 버전의 64비트 인스톨러

302
00:22:54,780 --> 00:22:56,796
요걸로 설치를 해보도록 하겠습니다

303
00:22:56,820 --> 00:23:00,280
그래서 요거를 클릭해서 설치를 진행해 보겠습니다

304
00:23:00,400 --> 00:23:02,720
네, 클릭하시면 요런 창이 뜨게 되고요

305
00:23:02,800 --> 00:23:04,197
설치를 진행해 볼 건데요

306
00:23:04,221 --> 00:23:06,520
다운을 다 받으셨으면 가장 중요한 게 있습니다

307
00:23:06,740 --> 00:23:11,420
이 PPT에도 굉장히 강조하고 있는
가장 중요한 게 있는데 Add Python

308
00:23:11,444 --> 00:23:15,620
3.11.2 패스라는 옵션을 무조건 체크를
해주시고 진행을 해주셔야 오류가 안 나옵니다

309
00:23:15,700 --> 00:23:17,840
그래서 요거는 반드시 요 옵션 요거 있죠?

310
00:23:18,000 --> 00:23:21,520
네, 요거는 반드시 체크를 하고 진행을 해주시기 바랍니다

311
00:23:21,700 --> 00:23:26,796
이렇게 체크를 해주신 다음에 요걸로 설치하셔도
되긴 하는데 그냥 커스터마이즈 인스톨레이션 통해서요

312
00:23:26,820 --> 00:23:31,620
부가적인 것도 다 한번 설치를 하고 경로를
지정하는 그 방법도 알아보도록 하겠습니다

313
00:23:31,800 --> 00:23:38,220
여기서 커스터마이즈 인스톨레이션을 누르게 되면
여기서 어떤 것들을 설치할지 옵션들을 선택해 줄 수 있는데요

314
00:23:38,380 --> 00:23:40,580
웬만하면 그냥 다 설치를 해 주도록 하겠습니다

315
00:23:40,800 --> 00:23:48,340
다 설치를 해 주시고 Next를 눌러서 이것도 싹 다
체크해서 웬만한 것들은 다 함께 설치를 해 주겠습니다

316
00:23:48,540 --> 00:23:54,400
그러면 이제 인스톨레이션 로케이션 이 파이썬
프로그램을 어디에 깔 건지도 설정을 해 줄 수가 있어요

317
00:23:54,520 --> 00:24:02,520
나중에는 이 경로가 되게 중요한 경우에 경로를 지정하고 설정하고 해야
될 일이 있어서 그래서 이거는 통일해서 가면 찾기가 수월할 것 같습니다

318
00:24:03,360 --> 00:24:07,960
C의 프로그램 파일에 파이썬
311로 기본적으로 설정이 될 거예요

319
00:24:08,080 --> 00:24:10,140
그래서 여기에 설치를 해 보도록 하겠습니다

320
00:24:10,420 --> 00:24:15,280
모든 체크박스 다 체크해 주시고 경로
지정까지 해 주신 다음에 인스톨을 눌러줍니다

321
00:24:15,380 --> 00:24:18,980
그러면 뭔가 띵 하고 뜰 텐데 그건 예를 누르면 넘어갑니다

322
00:24:19,040 --> 00:24:21,000
그러면 설치가 이렇게 진행 중입니다

323
00:24:21,240 --> 00:24:25,540
이렇게 Setup was successful
이라고 뜨면 설치가 완료된 것입니다

324
00:24:25,680 --> 00:24:26,776
그다음에 파이썬 311을 누르면 설치가 완료되고 있습니다

325
00:24:26,800 --> 00:24:30,180
이제 파이썬을 둘러보기로 하나씩
실행하는 방법을 알아보도록 하겠습니다

326
00:24:30,360 --> 00:24:37,220
이 시작 옆에 있는 검색창에 파이썬을 검색하시면 그래서
이게 기본적으로 파이썬 실행하는 실행기라고 보시면 됩니다

327
00:24:37,400 --> 00:24:40,760
파이썬을 실행하시면 이렇게 파이썬 실행창이 뜹니다

328
00:24:40,860 --> 00:24:43,460
꺽쇠 3개가 있는 이런 창이 나오게 되는데요

329
00:24:43,600 --> 00:24:50,154
이 꺽쇠 3개는 뭐냐면 레펠이라고 부르는데
파이썬 구문을 여기에 입력하면 바로 결과가 나오고

330
00:24:50,178 --> 00:24:55,120
다시 입력할 수 있도록 그러니까 파이썬 코드를
좀 테스트해 볼 때 많이 쓰이는 그런 도구입니다

331
00:24:55,240 --> 00:24:56,677
Read, Evaluate, Print

332
00:24:56,701 --> 00:24:58,256
프린트 루프의 약자인데 레펠이

333
00:24:58,280 --> 00:25:01,620
그래서 여기서 파이썬 코드를
기본적으로 실행을 해볼 수가 있습니다

334
00:25:02,000 --> 00:25:05,580
그러면 가장 기본적인 코드를 한번
실행이 됐는지 한번 테스트를 해볼까요?

335
00:25:05,740 --> 00:25:07,760
Print, Hello World

336
00:25:08,200 --> 00:25:10,220
기본적으로 많이 쓰이는 Hello World

337
00:25:10,420 --> 00:25:18,080
이거는 프로그래밍 입문서에 거의 무조건 나오는 예제인데 Hello
World라는 거를 출력한다라는 파이썬 기본 코드를 작성을 해보겠습니다

338
00:25:18,340 --> 00:25:21,440
그리고 엔터를 누르면 Hello
World라는 게 잘 출력이 됐죠

339
00:25:21,520 --> 00:25:28,380
그래서 여기 꺽쇠에 이렇게 나오는 부분이 파이썬 코드를
여기다 입력하고 실행 결과를 아래에서 볼 수 있는 그런 형태입니다

340
00:25:28,540 --> 00:25:31,580
이렇게 나오신다면 파이썬 설치가 잘 되신 겁니다

341
00:25:31,780 --> 00:25:33,520
그리고 파이썬 버전은 여기 위에 뜨죠

342
00:25:33,580 --> 00:25:36,000
그래서 저희는 기본적으로 같이 가도록 하겠습니다

343
00:25:36,180 --> 00:25:41,580
왜냐하면 책이 파이썬 3.11.2 버전을 쓰고 있기
때문에 이 버전에 따라서 조금씩 달라질 수가 있거든요

344
00:25:41,800 --> 00:25:45,100
3.11.2 버전을 기준으로 진행을 해보도록 하겠습니다

345
00:25:45,360 --> 00:25:51,140
버전 따라 크게 차이는 안 나는데 그래도 혹시 다를 수
있기 때문에 이걸로 통일해서 진행을 해보도록 하겠습니다

346
00:25:51,620 --> 00:25:53,160
네, 그래서 여기까지 다 되셨나요?

347
00:25:53,240 --> 00:25:56,420
그러면 파이썬 설치는 잘 진행이 되신 겁니다

348
00:25:56,580 --> 00:25:57,640
이렇게 입력을 해봤고요

349
00:25:57,700 --> 00:26:00,180
그리고 뭐 다른 것도 좀 해보면 책에도 나오죠?

350
00:26:00,220 --> 00:26:03,800
책에 1 더하기 1을 하면 2가 나온다

351
00:26:03,840 --> 00:26:06,520
이런 것도 파이썬 문법이라고도 할 수 있겠습니다

352
00:26:06,760 --> 00:26:11,820
이렇게 더하기를 해서 결과가 바로 밑에
리턴이 되는 이게 레펠 방식이라고 부릅니다

353
00:26:12,360 --> 00:26:15,800
네, 이것까지 되시면 이제
파이썬 기본 설치는 다 되신 거고요

354
00:26:15,880 --> 00:26:21,726
이걸 종료하려면 여기도 나오는데
quit하고 괄호 열고 닫고 이렇게 쓰거나 아니면

355
00:26:21,750 --> 00:26:26,556
exit라고 괄호 열고 닫거나 이렇게 하면
이 레펠 이거를 종료를 할 수가 있습니다

356
00:26:26,580 --> 00:26:28,300
네, 그러면 이렇게 창이 꺼지죠

357
00:26:28,360 --> 00:26:32,720
그래서 이렇게 꺽새 3개가 있는 건
레펠이다라는 거를 기억해 두시면 좋을 것 같습니다

358
00:26:33,000 --> 00:26:35,960
네, 그 다음에 또 다른 거를 해보도록 하겠습니다

359
00:26:36,300 --> 00:26:38,420
이거 말고도 실행기가 다른 게 있습니다

360
00:26:38,800 --> 00:26:46,800
일단 뭐 문법 써보기 이런 거는 사실 좀 문법을 배운 다음에 하는 게 나을
것 같아서 파이썬 기본 구문만 되는지 확인을 해주시면 좋을 것 같습니다

361
00:26:47,240 --> 00:26:52,640
네, 그 다음에 파이썬 에디터가 있는데
기본적인 에디터가 같이 깔리는 게 있습니다

362
00:26:52,800 --> 00:26:53,800
어떤 거냐?

363
00:26:54,160 --> 00:27:00,460
Idle라고 검색을 해보시면 idle라는 프로그램이
기본적으로 파이썬 설치하면 같이 깔립니다

364
00:27:00,600 --> 00:27:05,957
마찬가지로 윈도우 검색창에 idle를
검색하시면 이렇게 이런 창이 나와서 idle

365
00:27:05,981 --> 00:27:10,721
프로그램을 실행할 수가 있고 여기서
idle 프로그램을 제가 켜보도록 하겠습니다

366
00:27:10,760 --> 00:27:13,520
네, idle 프로그램은 이렇게 생겼습니다

367
00:27:13,800 --> 00:27:17,500
네, 여기서 약간 신기한 거 하나
말씀드리면 이게 아이들이잖아요?

368
00:27:17,560 --> 00:27:22,660
이 귀도반 로섬님이 몬티파이썬 비행
서커스에 진짜 굉장한 팬이신가 봐요

369
00:27:22,760 --> 00:27:27,276
여기서 또 따왔는데 여기 출연진 중에 보시면
아시겠지만 에릭 아이들이라는 분이 계십니다

370
00:27:27,300 --> 00:27:32,160
또 동경을 해서 좋아해서 그런지 프로그램
실행하는 이 창 이름도 아이들이라고 지으셨습니다

371
00:27:32,280 --> 00:27:33,960
그래서 이렇게 가져온 개념들이 좀 많습니다

372
00:27:34,220 --> 00:27:40,700
심지어 이런 것도 있던데 찾아보니까 나와서 가져와 봤는데
기도반 로섬이 트위터에서 활발하게 활동하시는 분이십니다

373
00:27:40,840 --> 00:27:47,980
여기 에릭 아이들한테 여기에 나는 파이썬의 author입니다라고 남기면서
I chose the name and I'm fan 뭐 이런 식으로 남겼죠

374
00:27:48,020 --> 00:27:53,280
그만큼 굉장한 팬이셔서 에디터 이름마저
아이들로 짓는 네, 이런 거를 보여주고 있습니다

375
00:27:53,480 --> 00:27:55,297
네, 그래서 이렇게 이제 아이들을
만들어서 이런 식으로 진행해 봤습니다

376
00:27:55,321 --> 00:27:56,700
여기도 마찬가지입니다

377
00:27:56,800 --> 00:27:58,860
레펠 방식이 기본적으로 실행이 되고요

378
00:27:58,960 --> 00:28:01,780
거기다 다른 기능들이 조금 더 추가적으로 있는 형태입니다

379
00:28:01,940 --> 00:28:09,940
이 아이들의 특징은 아까 프린트 헬로 월드를 하면은 아까랑
비교해보면 얘는 이렇게 검해가지고 좀 구분이 어렵잖아요

380
00:28:10,880 --> 00:28:18,880
헬로 월드라는 게 좀 명확하게 컬러로 얘는 보라색이고 얘는 까만색 괄호에
초록색 글씨가 들어간다라고 좀 구분이 쉬운데 이런 거를 좀 지원해준다라는

381
00:28:20,581 --> 00:28:25,060
특징이 있어서 이걸 쓸 바에는 그래도
이거 쓰는 게 좀 더 기능적으로 많습니다

382
00:28:25,640 --> 00:28:28,260
그래서 이렇게 하면 헬로 월드가 잘 출력이 되죠

383
00:28:28,300 --> 00:28:31,280
여기도 1 더하기 1 하면 2가 잘 출력이 됩니다

384
00:28:31,860 --> 00:28:39,240
그 다음에 이 아이들의 또 가장 큰 특징 중에 하나가
이렇게 레펠 방식 말고 또 다른 방식을 사용할 수도 있습니다

385
00:28:39,460 --> 00:28:43,560
파일에 뉴 파일을 눌러서 파이썬 파일
자체를 만들어서 그걸 실행할 수도 있어요

386
00:28:43,680 --> 00:28:46,120
뉴 파일로 파일을 하나 만들어 보도록 하겠습니다

387
00:28:46,380 --> 00:28:50,760
새로운 창이 열리면서 이제 언타이틀드
새로운 문서를 만들 수 있게 된 겁니다

388
00:28:50,940 --> 00:28:58,660
여기에서도 마찬가지로 프린트 헬로 라고 입력하면 이거를
바로 레펠 방식이 아니니까 엔터 친다고 실행이 되지는 않고요

389
00:28:58,740 --> 00:29:02,880
이거를 저장해서 파이썬 파일 자체로
저장해서 가지고 오실 수가 있습니다

390
00:29:03,060 --> 00:29:09,680
저장을 해보면 C드라이브에 이것도 그냥 통일해서 하면
좋으니까 내 컴퓨터 C드라이브에 폴더를 하나 만들어 보겠습니다

391
00:29:10,160 --> 00:29:10,820
뭘로 할까요?

392
00:29:10,920 --> 00:29:12,800
파이썬으로 해서 만들어 볼까요?

393
00:29:13,020 --> 00:29:16,240
PC에 C드라이브에 파이썬이라는 폴더를 만들었고요

394
00:29:16,320 --> 00:29:21,080
여기 안에 헬로우.파이라는 파이썬
파일로 저장을 해보도록 하겠습니다

395
00:29:21,320 --> 00:29:27,260
헬로우.파이라는 파일로 C드라이브 파이썬을 만들고
파이썬이라는 폴더에 hello. Py를 저장을 해보겠습니다

396
00:29:27,460 --> 00:29:30,100
그러면 이 파일 자체를 저장할 수 있게 됐고요

397
00:29:30,180 --> 00:29:35,068
그리고 여기서 run을 눌러서 run
모듈을 하게 되면 이렇게 hello world, c

398
00:29:35,092 --> 00:29:40,920
드라이브에 저장한 hello. Py라는 파일에
적힌 코드를 실행해서 이렇게 보여주게 됐습니다

399
00:29:41,400 --> 00:29:48,219
즉, 아이들이라는 것은 기본 파이썬 실행기에서 에디터
기능이 있어서 뉴 파일로 파일 자체를 만들어서 저장할

400
00:29:48,243 --> 00:29:54,480
수도 있고 그리고 여기서 따로 run을 돌려서 실행을
해볼 수 있다는 특징이 있다는 것을 말씀드렸습니다

401
00:29:54,720 --> 00:29:56,600
글자 크기는 어떻게 키우나요?

402
00:29:56,680 --> 00:30:01,960
해주셨는데 글자 크기는 옵션에 configure
아이디를 누르면 여기서 사이즈를 조절할 수가 있습니다

403
00:30:02,080 --> 00:30:06,980
그리고 하나 더 소개해드리면 cmd
창으로도 따로 실행할 수도 있는데요

404
00:30:07,180 --> 00:30:10,520
이것도 책에 나오는 내용이라 한번
간단하게 소개를 드리도록 하겠습니다

405
00:30:11,260 --> 00:30:17,240
파워쉘이라는 것도 있고 윈도우에서는 이렇게
프로그램을 실행할 수 있는 도구가 여러 개가 있어요

406
00:30:17,360 --> 00:30:24,197
마찬가지로 윈도우 창에 cmd라고 검색을 하시면
이렇게 명령어 프롬트라는 앱을 실행시킬 수 있고요

407
00:30:24,221 --> 00:30:28,660
또 파워쉘이라고 여기에 검색을
하시면 그것도 실행하실 수가 있습니다

408
00:30:28,800 --> 00:30:32,020
이런 창들로 따로 들어갈 수도 있습니다

409
00:30:32,300 --> 00:30:40,300
여기서 아까 c드라이브 파이썬이라는 폴더 안쪽에 hello. Py 아까 저장을
해놨는데 가져와서 일단 경로 이동하려면 cd를 누르고 이 경로를 입력하게

410
00:30:42,881 --> 00:30:50,881
되면 이렇게 이동을 해서 여기에 hello. Py를 입력하게 되면 이렇게
파이썬 파일을 이런 식으로 터미널 창 안에서도 실행을 할 수가 있습니다

411
00:30:52,881 --> 00:31:00,881
추가로 명령 프롬트 이게 cmd 창인데 여기서도 마찬가지로 경로
이동을 해서 파이썬 hello. Py 이렇게도 실행을 해볼 수가 있겠습니다.

412
00:31:03,340 --> 00:31:05,640
Cd가 체인지 디렉토리의 약자입니다

413
00:31:05,860 --> 00:31:11,600
그래서 경로를 바꿔주고 이 경로에 있는 hello.
Py라는 것을 실행해라고 이렇게 실행을 한 거죠

414
00:31:11,960 --> 00:31:15,780
그래서 이때 파이썬이라고 써서
이렇게 연결이 안 되신 분들 있죠

415
00:31:15,900 --> 00:31:21,140
이런 식으로 버전 이렇게 연결이 안 되신 분들
오류가 뜨시는 분들은 이게 패스 설정이 안 된 겁니다

416
00:31:21,320 --> 00:31:22,440
오류 메시지가 뜨거나

417
00:31:22,880 --> 00:31:29,000
이렇게 마이크로소프트 스토어가 열리시는 분들이
있을 텐데 이러면 파이썬 패스 연결이 잘 안 된 것입니다

418
00:31:29,160 --> 00:31:33,660
그러면 이렇게 패스 연결이 잘 안 되어
있는 경우 해결하는 방법을 알려드리겠습니다

419
00:31:33,920 --> 00:31:41,920
먼저 시작 버튼을 눌러서 검색창에 시스템 환경까지만
검색하시면 이렇게 시스템 환경 변수 편집이라는 메뉴가 나올 텐데요

420
00:31:42,081 --> 00:31:43,081
이거를 클릭해 줍니다

421
00:31:43,180 --> 00:31:51,180
그러면 이런 창이 뜨게 되는데 여기서 환경 변수를 클릭하시고 아래쪽에
시스템 변수 쪽에 패스라는 변수를 찾아서 이거를 더블 클릭해 줍니다

422
00:31:52,880 --> 00:31:56,320
그러면 이렇게 환경 변수를 편집할 수 있는 창이 나오고요

423
00:31:56,380 --> 00:32:02,080
여기에 새로 만들기를 눌러서 이렇게
반짝반짝하고 있을 때 찾아보기를 눌러줍니다

424
00:32:02,220 --> 00:32:06,140
그리고 여기서 우리가 파이썬을
설치한 경로를 선택을 해줍니다

425
00:32:06,320 --> 00:32:10,100
C드라이브에 프로그램 파일
파이썬 310 안에 설치를 했었죠

426
00:32:10,140 --> 00:32:12,140
이거를 찾아서 확인을 눌러줍니다

427
00:32:12,240 --> 00:32:20,240
그러면 이렇게 파이썬이 설치된 경로가 연결이 되었고 또 새로 만들기를
한 번 더 눌러서 찾아보기를 누르고 다시 파이썬 설치 경로로 이동해 줍니다

428
00:32:21,280 --> 00:32:22,856
파이썬 310으로 들어가겠습니다

429
00:32:22,880 --> 00:32:28,480
여기에서 스크립츠라고 써져 있는
이 폴더도 선택하고 확인을 눌러줍니다

430
00:32:28,580 --> 00:32:34,780
그러면 이렇게 파이썬 310, 파이썬 310
스크립츠까지 연결이 되면 이제 연결이 잘 된 것입니다

431
00:32:35,000 --> 00:32:40,780
이거를 오른쪽에 위로 이동을 쭉 눌러서 가장
먼저 연결되도록 맨 위로 올려주도록 하겠습니다

432
00:32:41,060 --> 00:32:45,260
그러면 파이썬 310, 파이썬 310
스크립츠가 맨 위로 올라오게 되었습니다

433
00:32:45,480 --> 00:32:48,900
그리고 확인 또 확인을 눌러서 설정을 완료해 줍니다

434
00:32:49,080 --> 00:32:52,856
새로 명령 프롬트를 켜서 다시 파이썬이라고 입력합니다

435
00:32:52,880 --> 00:32:55,900
완료를 하면 이제 이렇게 정상적으로 연결될 수 있습니다

436
00:32:56,000 --> 00:32:59,040
다양한 실행 방법들을 하나씩 소개해 드렸습니다

437
00:32:59,280 --> 00:33:02,740
그 다음에 에디터를 설치 해보도록 하겠습니다

438
00:33:03,000 --> 00:33:07,120
근데 어떻게 보면 아이를도 에디터라고 할 수도 있는데요

439
00:33:07,320 --> 00:33:10,480
코드 에디터를 설치해 볼
건데께서 이런 게 코드 에디터입니다

440
00:33:10,820 --> 00:33:16,440
아이들도 코드 에디터라고 부를 수가 있겠는데
이것 보다 더 다양한 기능이 들어 있는 것들이 있어요

441
00:33:16,660 --> 00:33:17,460
그래서 어떤 게 있어요?

442
00:33:17,580 --> 00:33:19,640
이 아이� irgendwo 에디터죠

443
00:33:19,740 --> 00:33:22,237
그래서 이것도 에디터인데, 파이참이라는 것도 있고요

444
00:33:22,261 --> 00:33:30,200
여기 파이참 화면인데, 파이참이란 에디터도 있고, 가장 많이 쓰이는게,
Visual Studio Code라는 에디터가 엄청나게 많이 쓰입니다

445
00:33:30,380 --> 00:33:36,640
그래서 이것을 설치하고 이걸로 통일해서 같이
강의를 할때는 이걸로 진행을 해보도록 하겠습니다

446
00:33:36,880 --> 00:33:41,680
그러면 Visual Studio Code라는 에디터를
설치하는 과정도 같이 진행을 해보겠습니다.

447
00:33:41,980 --> 00:33:45,980
Visual Studio Code 공식
홈페이지에서 진행을 해보도록 하겠습니다

448
00:33:46,260 --> 00:33:49,697
요즘에는 거의 Visual Studio
Code가 장악하고 있는 것 같아요

449
00:33:49,721 --> 00:33:57,100
물론 파이차미니 이런 것도 많이 쓰이는데 그래도 비주얼 스튜디오
코드가 다방면을 사용하기 좋아가지고 굉장히 편리한 것 같습니다

450
00:33:57,300 --> 00:33:59,040
비주얼 스튜디오랑 다릅니다

451
00:33:59,220 --> 00:34:01,280
그래서 비주얼 스튜디오는 조금 더 무겁고요

452
00:34:01,400 --> 00:34:04,060
비주얼 스튜디오 코드는 더 가볍습니다

453
00:34:04,180 --> 00:34:05,260
무료 프로그램이고요

454
00:34:05,480 --> 00:34:09,240
이거 강의 여기 란에도 수업
자료 란에 이렇게 남겨드렸습니다

455
00:34:09,540 --> 00:34:12,520
그러면 비주얼 스튜디오 코드 함께 설치를 해보겠습니다

456
00:34:12,900 --> 00:34:15,060
여기서 다운로드 포 윈도우즈

457
00:34:15,100 --> 00:34:17,640
맥에서 들어가시면 맥이라고 떠 있을 거예요

458
00:34:17,760 --> 00:34:19,380
그래서 이거를 클릭을 해줍니다

459
00:34:19,720 --> 00:34:25,160
그러면 이렇게 페이지가 넘어가면서
자동으로 이렇게 exe 설치 파일이 받아집니다

460
00:34:25,220 --> 00:34:27,180
이걸 누르면 기본적으로 설치가 됩니다

461
00:34:27,380 --> 00:34:30,300
아니면 다운로드 안 받아주시면
여기 다운로드 링크도 있거든요

462
00:34:30,520 --> 00:34:33,100
그래서 이걸 누르면 이렇게 다운을 받을 수가 있습니다

463
00:34:33,480 --> 00:34:36,440
설치 파일을 실행시켜 보시면 이런 창이 뜹니다

464
00:34:36,540 --> 00:34:39,840
라이센스는 당연히 동의를 해주셔야 실행이 설치가 될 거고요

465
00:34:39,920 --> 00:34:45,980
다음을 누르고 이것도 다 체크하고 이거 싹 다
체크한 다음에 다음을 누르고 설치를 눌러줍니다

466
00:34:46,100 --> 00:34:47,860
Vs 코드 설치가 진행이 됩니다

467
00:34:48,100 --> 00:34:52,940
그래서 설치가 완료돼서 이제 종료를
누르면 비주얼 스튜디오 코드가 실행이 됩니다

468
00:34:53,120 --> 00:34:56,240
추가로 맥 os 용 설치 방법도 간단히 알아보겠습니다

469
00:34:56,480 --> 00:35:04,480
윈도우와 크게 다를 건 없는데 차이가 나는 부분만 간단히 설명드리면
파이썬을 받을 때 인텔 전용이 있고 모두 호환되는 유니버셜 버전이 있습니다

470
00:35:05,020 --> 00:35:07,740
그래서 사용하시는 칩에 따라서 다운 받으시면 되고요

471
00:35:07,860 --> 00:35:11,880
설치는 그냥 다운 받은 파일을
열어서 쭉쭉 다음을 누르시면 됩니다

472
00:35:12,140 --> 00:35:17,400
실행은 터미널을 열어서 파이썬3 라는
명령어를 입력하셔야 실행하실 수 있습니다

473
00:35:17,600 --> 00:35:19,536
그냥 파이썬은 기본적으로 맥에서 설치할 수 있습니다

474
00:35:19,560 --> 00:35:26,180
맥 os에서 파이썬 2점대 버전을 내장하고 있기
때문에 그냥 파이썬을 쓰면 파이썬 2점대가 실행이 되고요

475
00:35:26,260 --> 00:35:30,500
파이썬3를 써야지 새로 설치한
파이썬 3점대 버전을 쓸 수 있습니다

476
00:35:30,720 --> 00:35:38,720
Vs 코드는 윈도우와 거의 똑같기 때문에 설치하는 건 생략하고 차이점만
말씀드리면 터미널이 파워쉘이나 cmd가 아닌 zsh가 기본으로 실행됩니다

477
00:35:40,660 --> 00:35:48,660
이거는 기본으로 그대로 사용하셔도 되고 마찬가지로 실행하실 때
파이썬3 라고 3을 꼭 붙여야 된다는 점 기억해 주시면 좋을 것 같습니다

478
00:35:48,701 --> 00:35:56,701
혹시나 지금까지 파이썬 설치 과정을 따라오시다가 뭔가 오류가 생겨서 못
해먹겠다 하시는 분들은 굳이 파이썬을 내 컴퓨터에 깔지 않으셔도 됩니다

479
00:35:57,660 --> 00:36:03,260
온라인에서도 파이썬 코드를 실행할 수 있는 환경이
갖춰진 곳들이 있기 때문에 소개해 드리도록 하겠습니다

480
00:36:03,540 --> 00:36:06,400
가장 유명하게 많이 쓰이는 것이 구글 콜랩입니다

481
00:36:06,600 --> 00:36:09,520
구글 콜랩은 구글에서 만든 파이썬 실행 환경인데요

482
00:36:09,660 --> 00:36:15,241
이 주소로 들어오시면 이렇게 화면이 뜨게
되는데 여기서 파일에 새 노트를 누르시면

483
00:36:15,265 --> 00:36:20,400
이렇게 뭔가 새로운 노트가 열리면서 어떤
파일이 내 구글 드라이브에 만들어지게 됩니다

484
00:36:20,540 --> 00:36:22,420
이게 파이썬 실행할 수 있는 파일인데요

485
00:36:22,620 --> 00:36:29,486
여기 지금 깜빡깜빡하고 있는 곳에 마찬가지로
파이썬 명령어 print hi 이런 식으로 입력하고 실행을

486
00:36:29,510 --> 00:36:35,400
하려면 shift 엔터를 누르게 되면 실행을 했더니
밑에 hi 라는 것이 나오는 걸 확인할 수 있습니다

487
00:36:35,620 --> 00:36:43,620
즉 이 깜빡깜빡하는 곳에 파이썬 명령어 1 더하기 1 이런 거
입력하고 shift 엔터를 누르면 이게 계산이 돼서 결과가 아래쪽에 나옵니다

488
00:36:44,580 --> 00:36:52,580
이렇게 구글 콜랩이라는 파이썬 실행 환경인데 콜랩 외에도 온라인 파이썬이라고
구글에 검색하시면 수많은 온라인에서 파이썬을 실행할 수 있는 환경들이

489
00:36:54,321 --> 00:37:01,480
마련되어 있으니 내 컴퓨터에서 파이썬이 안 깔린다고 해서
포기하지 마시고 이런 온라인 환경에서 파이썬을 연습해 보시기 바랍니다

490
00:37:01,580 --> 00:37:03,800
이게 이제 Visual Studio Code의 화면입니다.

491
00:37:03,940 --> 00:37:07,580
Visual Studio Code를 여셨으면
어떻게 보면 아이들이랑 거의 비슷해요

492
00:37:07,660 --> 00:37:12,380
아이들도 이렇게 파이썬 실행할 수 있고
New File에서 파일 생성할 수 있고 이런 거잖아요

493
00:37:12,560 --> 00:37:14,480
그러니까 쉽게 말해서 메모장입니다

494
00:37:14,740 --> 00:37:18,476
윈도우 메모장은 써보신 분들
많을 텐데 이거랑 거의 똑같죠?

495
00:37:18,500 --> 00:37:22,140
그래서 메모장도 이렇게 파일 해서
새 파일 만들고 막 이럴 수 있잖아요

496
00:37:22,340 --> 00:37:30,340
그냥 기능들이 좀 여러 개 들어있고 이렇게 색깔도 조금 알록달록해서
코드 구분하기도 쉽고 이런 게 코드 에디터라고 할 수가 있겠습니다

497
00:37:31,340 --> 00:37:34,760
알록달록한 메모장 정도라고 생각하시면 좋을 것 같습니다

498
00:37:35,360 --> 00:37:37,500
아, Visual Studio를 설치하셨군요

499
00:37:37,920 --> 00:37:41,840
이거 착각하시면 안 되는
게 Visual Studio Code입니다

500
00:37:42,060 --> 00:37:44,880
여기 보면 Visual Studio Code이고요.

501
00:37:45,340 --> 00:37:46,920
Visual Studio는 또 다릅니다

502
00:37:47,420 --> 00:37:48,560
두 개가 다릅니다

503
00:37:48,700 --> 00:37:51,060
Visual Studio Code는 이렇게 생겼고요

504
00:37:51,100 --> 00:37:54,160
모양도, 아이콘도 이렇게 생겼고 이런 화면이 나오고요

505
00:37:54,260 --> 00:37:57,020
Visual Studio는 이렇게 생겼습니다

506
00:37:57,160 --> 00:37:58,600
그래서 이게 더 무거워요

507
00:37:58,740 --> 00:38:01,880
그래서 Visual Studio Code
이거를 다운받아 주시면 됩니다

508
00:38:02,300 --> 00:38:02,380
어?

509
00:38:02,460 --> 00:38:03,777
코드를 설치했는데 좀 다른...

510
00:38:03,801 --> 00:38:08,398
아, 이게 아마 제가 이미 설치를 해놔서
기본적으로 설치된 것들이 조금 있기 때문에

511
00:38:08,422 --> 00:38:12,200
약간은 다를 수 있는데 같이 따라 할
때는 똑같이 진행하실 수가 있을 겁니다

512
00:38:12,460 --> 00:38:20,460
예를 들어 이런 메뉴들 아마 제가 이것저것 설치해서 좀 더 많을
텐데 그냥 크게 신경 안 쓰셔도 기본 기능만 사용을 하도록 하겠습니다

513
00:38:21,100 --> 00:38:25,000
그 실행이 되셨다라고 생각을 하고
다음 과정을 진행을 해보겠습니다

514
00:38:25,380 --> 00:38:27,480
어떻게 뭐 파일 생성이나 이런 걸 어떻게 하냐?

515
00:38:27,540 --> 00:38:30,820
이게 파일에 일단 New File로
생성을 똑같이 할 수도 있고요

516
00:38:31,000 --> 00:38:38,500
아니면 가장 쉬운 게 Open Folder를 하면은 그 작업하는
폴더를 하나 지정해서 그 폴더에서 뭔가 작업하기가 편합니다

517
00:38:38,680 --> 00:38:44,700
파일에 Open Folder를 들어가서 네, 저희가
이제 C드라이브에 Python이라는 폴더를 만들었죠

518
00:38:45,080 --> 00:38:46,637
여기서 작업을 해보도록 하겠습니다

519
00:38:46,661 --> 00:38:54,661
그러면 C드라이브에 Python이라는 폴더를 폴더 선택을 하게 되면 이것은
이제 Yes, I trust the authors를 눌러서 승인을 해줍니다

520
00:38:55,540 --> 00:38:59,500
네, 그러면 이렇게 왼쪽에
보시면 조금 더 확대를 해볼까요?

521
00:38:59,640 --> 00:39:07,000
네, 왼쪽에 보시면 이 Python이라는 우리가 만든 폴더를
열어서 거기 안에 있는 파일이 보이는 것을 확인할 수가 있습니다

522
00:39:07,200 --> 00:39:13,700
이것을 누르면 이렇게 hello. Py라는 파일이
열리고 안에 적힌 코드가 이렇게 보이게 되는 것입니다

523
00:39:14,140 --> 00:39:19,943
즉, 구성을 보면 왼쪽이 이제 폴더
코드인데 폴더 구조가 나오고 이걸 클릭하면 그

524
00:39:19,967 --> 00:39:24,901
안에 있는 이 파일 안에 있는 코드가
오른쪽에 표시가 된다고 보실 수가 있겠습니다

525
00:39:25,600 --> 00:39:27,260
네, 이렇게 켜실 수가 있고요

526
00:39:27,440 --> 00:39:30,260
그러면 이게 아까 아이들로 작성한 코드랑 똑같죠?

527
00:39:30,300 --> 00:39:38,300
그래서 아이들로는 이렇게 작성해서 저장을 해놨는데 VS 코드는
좀 더 직관적으로 폴더 구조랑 이 코드랑 같이 볼 수가 있습니다

528
00:39:39,440 --> 00:39:42,960
여기서 메뉴들을 여러 개 선택할 수
있는데 이거를 실행하려면 어떻게 해야 되냐?

529
00:39:43,260 --> 00:39:49,680
일단은 아마 Python 파일을 실행하시면
오른쪽에 무슨 파이썬 익스텐션을 설치하시겠습니까?

530
00:39:49,740 --> 00:39:53,140
이런 게 뜰 텐데 그거를 눌러서 설치를 하셔도 되고요

531
00:39:53,200 --> 00:39:59,440
아니면 여기 Extensions로 들어가시면 여기
추가적으로 모듈들을 설치를 할 수가 있습니다

532
00:39:59,840 --> 00:40:05,760
그중에서 파이썬을 검색을 해보시면
기본적인 파이썬 모듈이 뜨게 됩니다

533
00:40:06,000 --> 00:40:14,000
저는 이미 설치를 해놔서 이렇게 뜨는데 파이썬 익스텐션은 반드시 설치하고
이렇게 활성화된 상태로 두시면은 Python 실행을 하실 수가 있습니다

534
00:40:17,180 --> 00:40:22,420
이게 설치가 되시면 아마 이제
오른쪽 위에 이런 표시가 뜰 겁니다

535
00:40:22,580 --> 00:40:25,420
이게 이제 Python 코드를
바로 실행할 수 있는 버튼입니다

536
00:40:26,020 --> 00:40:29,460
이걸 누르면 여기에 작성한
Python 코드가 쭉 실행이 됩니다

537
00:40:30,020 --> 00:40:30,660
이거 있죠

538
00:40:30,760 --> 00:40:32,320
문서 모양에 플러스 돼 있는 거

539
00:40:32,380 --> 00:40:34,680
이거를 누르면 파일을 만들 수가 있습니다

540
00:40:35,060 --> 00:40:39,600
이렇게 파일을 만들어서 hello
world. Py라는 걸 만들어 보겠습니다

541
00:40:39,980 --> 00:40:42,700
그러면 이렇게 파일을 만들어진 거고요

542
00:40:42,780 --> 00:40:43,780
이게 어떤 거냐?

543
00:40:43,840 --> 00:40:44,997
이게 윈도우로 만들어진 거고요

544
00:40:45,021 --> 00:40:45,016
이게 어떤 거냐?

545
00:40:45,040 --> 00:40:47,120
이것과 같은 개념입니다

546
00:40:47,220 --> 00:40:54,340
지금 여기 C 드라이브 파이썬 안쪽에 hello. Py라는
파일이 있었고 hello.world.py라는 파일을 방금 만들었죠

547
00:40:54,380 --> 00:40:56,920
그래서 이런 식으로 파일을 생성해 줄 수가 있고요

548
00:40:57,140 --> 00:41:01,320
그 생성한 파일 안쪽에 파이썬
언어 문법을 입력해 줄 수가 있습니다

549
00:41:01,620 --> 00:41:09,620
Print hello world 이런 식으로 입력하면 느낌표를
막 떠서 저장을 하고 이렇게 하면 hello.world.

550
00:41:09,975 --> 00:41:16,560
Py는 이거고 hello .py를 실행하면 이거고
이렇게 코드 에디터를 조작하는 방법을 배워봤습니다

551
00:41:16,660 --> 00:41:20,380
그러면 이렇게 파일을 만들고 코드를
입력한 다음에 실행을 해봐야겠죠

552
00:41:20,960 --> 00:41:26,860
실행을 해본다는 것은 익스텐션이 설치가 완료된
다음에 여기 오른쪽 위에 재생 런 버튼이 있습니다

553
00:41:27,160 --> 00:41:34,480
그래서 런 버튼을 누르면 이렇게 실행이 돼서 여기 print
hello 이 결과인 실행이 돼서 나온 것을 확인할 수가 있습니다

554
00:41:35,120 --> 00:41:36,440
여기까지 잘 진행되시나요?

555
00:41:36,520 --> 00:41:37,660
오류 뜨신 분 있으신가요?

556
00:41:38,180 --> 00:41:46,180
파일 옆에 실행하는 버튼, 재생 버튼이 없으신 분들은 익스텐션, 이 파이썬
익스텐션을 설치를 하시고 한번 에디터를 껐다가 키는 방법도 추천드립니다

557
00:41:49,220 --> 00:41:50,600
그래서 껐다가 한번 저도 켜보겠습니다

558
00:41:51,240 --> 00:41:55,120
그 실행하는 방법도 여러 가지가 있는데
명령 프롬프트 안에서 실행할 수도 있습니다

559
00:41:55,500 --> 00:42:02,300
이 폴더 안에서 코드 점을 누르면 비주얼 스튜디오
코드가 기본적으로 폴더가 선택된 상태로 열립니다

560
00:42:02,520 --> 00:42:05,080
그래서 여기 안에 있는 이 파일들을 볼 수가 있습니다

561
00:42:05,320 --> 00:42:12,460
그리고 이 파일 구조는 윈도우의 c드라이브 파이썬 안에
hello. Py, hello.world.py 이렇게 들어있는 이 구조입니다

562
00:42:12,600 --> 00:42:20,100
그런데 이 터미널이 뭐냐면 여기 윈도우 파워쉘 저희가
따로 실행해서 켜봤는데 이 창이 여기 안에 들어가 있는 겁니다

563
00:42:20,380 --> 00:42:23,080
그래서 사실상 이거랑 이거랑 똑같습니다

564
00:42:23,400 --> 00:42:24,860
무슨 말인지 아시겠나요?

565
00:42:24,940 --> 00:42:32,940
그러니까 어떻게 보면 이게 메모장이고 이게 폴더, 윈도우 탐색기고
아래쪽에 있는 게 터미널 지금 이 파워쉘 창이 결합되어 있는 형태입니다

566
00:42:34,120 --> 00:42:40,540
즉 id라는 게 통합 개발 환경의 약자인데
그 통합 개발 환경이 이걸 의미합니다

567
00:42:41,360 --> 00:42:48,720
통합 개발 환경이라는 게 말 그대로 여러 가지 요소들을
통합해서 한 화면에 보면서 개발할 수 있는 환경이라 id라고 부릅니다

568
00:42:48,840 --> 00:42:50,900
그래서 이게 없어도 사실 할 수는 있어요

569
00:42:51,000 --> 00:42:56,500
왜냐하면 이 윈도우 탐색기 보면서 폴더 구조
보면 되고 이거는 메모장으로 입력해도 되죠

570
00:42:56,540 --> 00:43:02,220
사실 그래서 이게 깔기 귀찮다 하시는 분들은 이거를
그냥 연결 프로그램으로 메모장으로 열 수도 있잖아요

571
00:43:02,400 --> 00:43:06,120
메모장, 메모장으로 열어서
그래서 이 메모장이 여기 있는 거고요

572
00:43:06,400 --> 00:43:09,600
편리하게 하기 위해 설치하는 거지 굳이 없어도 되긴 합니다

573
00:43:09,780 --> 00:43:10,780
이 에디터가

574
00:43:11,360 --> 00:43:16,900
아무튼 기본적으로 코드 작성하는 방법 그리고
이걸 눌러서 실행하는 방법까지 알아봤습니다

575
00:43:17,120 --> 00:43:25,120
추가로 이렇게 실행하면 계속 터미널이 여러 개 생길 때도 있고 이렇게
지울 수도 있고 이런데 이거는 여기 터미널 창에서 뉴 터미널을 누르면 이렇게

576
00:43:26,321 --> 00:43:31,700
터미널을 만들 수가 있는데 여기 플러스 버튼으로
여러 개 터미널을 막 여러 개로 생성할 수도 있습니다

577
00:43:31,880 --> 00:43:36,160
그리고 종류도 파워쉘도 있고 아까 cmd 창도 켰잖아요

578
00:43:36,280 --> 00:43:38,180
그게 커맨드 프롬트라는 창입니다

579
00:43:38,380 --> 00:43:45,047
그래서 맥은 아마 zsh 그리고 다른 게
뜰 텐데 이거는 큰 상관은 없고 그냥 여기

580
00:43:45,071 --> 00:43:50,500
파이썬 이 터미널 안에서 실행시킬 수
있다 라는 거를 간략하게 소개를 드립니다

581
00:43:50,580 --> 00:43:52,040
아 약간 복잡하죠

582
00:43:52,160 --> 00:44:00,160
오늘 좀 배우는 내용들이 사실 파이썬 문법과는 전혀 관련 없는 그냥 설치하고
실행하는 방법들을 쭉 소개를 드린 건데 이렇게 설치하는 과정 이런 것들을 쭉

583
00:44:02,221 --> 00:44:10,221
소개해 드리면서 환경이 이런 게 있다라는 걸 소개해 드리는
정도고 앞으로 이용할 거는 그냥 이 창 이 화면만 계속 실행하고 실행하고

584
00:44:11,341 --> 00:44:16,740
결과 보고 이런 것만 볼 거라서 이걸
세부적으로 막 엄청 외워서 아실 필요는 없습니다

585
00:44:16,920 --> 00:44:22,399
아 여러 파이썬 버전이 깔려 있으면 원하는
버전 선택은 어떻게 하나요 질문 주셨는데

586
00:44:22,423 --> 00:44:27,501
어 그거는 아래쪽에 보시면 이것도 파이썬
익스텐션을 설치하고 나서 보실 수가 있습니다

587
00:44:27,720 --> 00:44:35,060
이 아래쪽에 보시면 여기 파이썬
10.10.64비트라고 써져 있는 곳이 있습니다

588
00:44:35,240 --> 00:44:38,420
얘를 눌러서 여러 가지 중에 선택을 할 수가 있습니다

589
00:44:38,600 --> 00:44:42,520
아니면 여기에 안 뜬다 안 뜨는 분들은
패스를 직접 선택할 수도 있습니다

590
00:44:42,640 --> 00:44:47,500
그래서 파인드를 누르면 찾을 수가 있는데
저희가 파이썬 설치한 경로 기억나시나요?

591
00:44:47,580 --> 00:44:55,360
제가 통일에서 설치하자 라고 말씀드렸는데 C드라이브에
프로그램 파일즈에 파이썬 3.11에 같이 설치해요 라고 말씀드렸잖아요

592
00:44:55,420 --> 00:45:00,616
이 경로를 찾아서 들어와서 파이썬 exe를
선택을 하시면 이렇게 아까 방금 바뀌었죠

593
00:45:00,640 --> 00:45:03,460
파이썬 버전이 바뀐 것을 확인할 수가 있습니다

594
00:45:03,780 --> 00:45:10,437
이 바뀐 상태에서 실행을 하면은 이거 재생
버튼을 누르면 3.11 버전으로 실행을 하게 됩니다

595
00:45:10,461 --> 00:45:13,080
그래서 이렇게 선택을 할 수가 있겠습니다

596
00:45:13,300 --> 00:45:16,760
이렇게 파이썬 버전 바꾸는 방법도 소개를 드렸습니다

597
00:45:17,100 --> 00:45:18,640
메모장이랑 사실 똑같아요

598
00:45:18,740 --> 00:45:20,320
그래서 메모장도 이게 똑같이 뜨잖아요

599
00:45:20,420 --> 00:45:23,020
색깔 차이 뿐이지 코드 입력한 요거 있잖아요

600
00:45:23,220 --> 00:45:23,940
요건 똑같습니다

601
00:45:24,020 --> 00:45:26,820
여기서 코드를 입력하나 메모장에서 입력하나 똑같습니다

602
00:45:26,980 --> 00:45:31,060
그래서 그냥 코드만 알록달록하게
되고 자동완성 이런 게 되니까 좋죠

603
00:45:31,140 --> 00:45:35,520
다른 예시가 뭐가 있을까 모르겠는데 아이폰도
입력하다 보면 자동완성 해주고 이런 거 있잖아요

604
00:45:35,740 --> 00:45:39,917
그런 것처럼 p만 입력해도 pr만
입력해도 이렇게 자동완성이 쭉 뜨잖아요

605
00:45:39,941 --> 00:45:44,900
그래서 이거를 클릭하거나 아니면
PR 입력하고 키보드에 탭 키 있죠?

606
00:45:45,000 --> 00:45:46,520
키를 누르면 이렇게 자동완성이 됩니다

607
00:45:46,700 --> 00:45:49,980
그래서 이런 자동완성 할 때 굉장히 에디터가 유용합니다

608
00:45:50,240 --> 00:45:52,020
괄호 읽어놓고 하고 뭐 이렇게 써줄 수가 있겠죠

609
00:45:52,220 --> 00:45:54,000
네 이렇게 할 수가 있을 것 같고요

610
00:45:54,120 --> 00:45:59,643
여기에 추가적인 문법은 일단 문법을 배운 다음에
나가는 게 당연히 순서상 맞는 것 같아서 여기 책에

611
00:45:59,667 --> 00:46:04,840
나온 내용을 직접 써보셔도 되는데 일단 문법을
뒤에서 하나씩 배우고 시도를 해보도록 하겠습니다

612
00:46:05,060 --> 00:46:11,560
그전에 개념적으로 하나 그냥 미리 배우면 좋을 개념을
간단하게 설명드리면 그 주석이라는 개념이 있습니다

613
00:46:11,780 --> 00:46:13,660
주석 소개가 이제 책에도 나오죠

614
00:46:13,720 --> 00:46:15,256
그래서 주석이 어떤 개념이냐?

615
00:46:15,280 --> 00:46:19,000
Print, hello, world를 두
개를 분리를 한번 해보겠습니다

616
00:46:19,260 --> 00:46:25,260
그러면 print hello, print world라는 게 있으면 이거를
hello가 있고 world가 있고 두 개가 다 출력이 되잖아요

617
00:46:25,420 --> 00:46:26,460
주석은 어떤 거냐?

618
00:46:26,500 --> 00:46:31,740
여기서 컨트롤하고 이 물음표
있는 키 컨트롤하고 이거 있죠?

619
00:46:32,200 --> 00:46:32,820
물음표

620
00:46:32,960 --> 00:46:34,280
읽으면 주석이 됩니다

621
00:46:34,460 --> 00:46:34,760
주석

622
00:46:35,240 --> 00:46:41,660
주석이 뭐냐면 컴퓨터가 읽지 못하게 만드는 무슨
말이냐면 인간이 알아보기 위해서 쓰는 텍스트인데요

623
00:46:41,760 --> 00:46:44,540
예를 들어 이 월드 쪽을 주석을 먹여 보겠습니다

624
00:46:44,940 --> 00:46:47,480
컨트롤, 슬래시를 누르면 이렇게 주석이 되잖아요

625
00:46:47,660 --> 00:46:55,640
그래서 주석을 만들고 나서 실행을 하면 이제는 아까는
hello, world 두 개가 출력됐는데 지금은 hello만 출력이 됩니다

626
00:46:55,820 --> 00:46:56,820
하나만 출력이 됐죠

627
00:46:56,880 --> 00:46:59,400
그렇다는 건 이거를 읽지 못하고 지나가는 겁니다

628
00:46:59,580 --> 00:47:05,620
코드가 이제 위에서 아래로 쭉 실행이 되는데 이 아래쪽
거는 안 읽고 지나가겠다가 이제 주석을 처리한 겁니다

629
00:47:05,820 --> 00:47:07,337
그래서 주석이 이거

630
00:47:07,361 --> 00:47:14,540
그리고 지금 파이썬에서는 그 샵 기호가 붙어있으면
이제 주석 처리가 되는 건데 이런 것도 가능하죠

631
00:47:14,620 --> 00:47:15,860
원래는 막 안녕

632
00:47:16,240 --> 00:47:18,460
이런 거 입력하면은 오류가 나요

633
00:47:18,540 --> 00:47:22,400
왜냐하면 이렇게 한글이 들어가
있으면 이제 그런 거 할 수도 있죠

634
00:47:22,500 --> 00:47:26,400
예를 들어 그냥 어떤 메시지
혹은 코드 설명을 쓸 수가 있잖아요

635
00:47:26,720 --> 00:47:31,320
기본적으로 아래 코드는 월드를 출력하는 코드입니다

636
00:47:31,420 --> 00:47:33,080
이런 거 설명하고 싶을 때가 있죠

637
00:47:33,200 --> 00:47:36,977
다른 개발자한테 설명하거나 오픈 소스를 올려서 뭔가...

638
00:47:37,001 --> 00:47:45,001
제가 설명하는 걸 올릴 때 그때 이런 한글을 쓸 수도 있을 텐데 이런
것을 이제 주석 처리를 해놓으면 이 설명 코드는 작성이 되면서 이 실행은 안

639
00:47:46,621 --> 00:47:52,200
되니까 이렇게 이런 개발자끼리 사람이
알아보라고 쓰는 메시지를 이렇게 쓸 수가 있겠죠

640
00:47:52,320 --> 00:47:57,177
그래서 이렇게 컨트롤 슬래시를 눌러도
되고 아니면 그냥 이렇게 샵을 써도 됩니다

641
00:47:57,201 --> 00:48:05,201
그래서 여러 줄을 하려면 이렇게 전체 지정하고 컨트롤 슬래시를 하면
이렇게 지정이 되고 다시 풀려면 마찬가지로 컨트롤 슬래시를 하면 풀리게 됩니다

642
00:48:07,200 --> 00:48:11,340
내가 쓰고 싶은 메시지를 코드
안쪽에서도 실행 오류가 나지 않겠죠

643
00:48:11,520 --> 00:48:19,320
실행 버튼 단축키는 F5가 디버깅이
시작하는 거고 컨트롤 F5를 누르시면 됩니다

644
00:48:19,560 --> 00:48:23,760
여기서 컨트롤 F5를 누르면 이렇게 실행이 됩니다

645
00:48:24,320 --> 00:48:26,297
주석 처리에 다른 기호는 없나요?

646
00:48:26,321 --> 00:48:27,900
해주셨는데 이런 경우가 있습니다

647
00:48:28,060 --> 00:48:29,500
여러 줄 쓰고 싶을 때가 있죠

648
00:48:29,620 --> 00:48:30,620
입력하는 코드입니다

649
00:48:30,680 --> 00:48:31,680
따라해 주세요

650
00:48:31,860 --> 00:48:36,500
이렇게 두 줄을 입력하는 경우에 이렇게도
쓸 수 있겠지만 이런 경우도 있습니다

651
00:48:37,100 --> 00:48:45,100
큰 따옴표 3개를 입력하고 아래쪽에도 큰 따옴표 3개를
입력하면 여기 안에 있는 모든 것들이 다 주석 처리가 됩니다

652
00:48:47,520 --> 00:48:54,177
아니면 따옴표 3개를 입력해도 이
사이에 있는 것이 주석으로 처리가 됩니다

653
00:48:54,201 --> 00:48:57,200
신텍스 에러는 문법 오류입니다

654
00:48:57,300 --> 00:49:00,180
뭔가 오타가 났을 경우에 보통 신텍스 에러가 나옵니다

655
00:49:00,240 --> 00:49:03,540
프린트에 N이 빠졌다거나 이런 경우 신텍스 에러가 나죠

656
00:49:03,620 --> 00:49:08,060
실행해 보면 여기 에러가 났고
신텍스 에러인데 여기서는 잡아주네요

657
00:49:08,200 --> 00:49:13,440
잘못 쓴 거 아니니라고 이렇게 잘
친절하게 설명해 주는데 문법의 오류입니다

658
00:49:13,720 --> 00:49:19,500
이렇게 해서 이제 기본적인 파이썬 설치
과정 그리고 기본 문법 설명을 드렸습니다

659
00:49:19,660 --> 00:49:23,697
여기에서는 파이썬이라고 입력을
하면 기본적으로 이 레펠 창이 열려요

660
00:49:23,721 --> 00:49:29,635
그래서 가끔 어떤 분들은 파이썬이라고 입력한
다음에 여기에 입력할 거를 여기에 입력해서 좀 실수하시는

661
00:49:29,659 --> 00:49:35,320
경우가 있는데 여기에 파이썬을 입력하면 이 레펠
창이 열려서 여기는 파이썬 문법을 입력하는 곳입니다

662
00:49:35,420 --> 00:49:41,556
그래서 프린트 하이라고 입력하면 이렇게 하이 뜨는 이
문법은 이제 파이썬 문법을 입력하는 레펠 창이 열리고요

663
00:49:41,580 --> 00:49:46,560
다시 종료하고 이 파일을 실행할 때는
파이썬 하고 띄어쓰기 한 다음에 파일 이름

664
00:49:46,640 --> 00:49:51,960
이렇게 파일 이름을 입력해 주셔야
여기서 이렇게 파일을 실행할 수가 있습니다

665
00:49:52,180 --> 00:49:53,696
그래서 이것도 질문들을 많이 듣습니다

666
00:49:53,720 --> 00:49:59,020
그래서 가끔 이렇게 레펠 창에
python hello. Py를 했는데 왜 안되냐?

667
00:49:59,080 --> 00:50:01,060
이렇게 질문하신 분들이 꽤 계시더라고요

668
00:50:01,220 --> 00:50:09,220
레펠 창, 꺽쇠 3개 있는 건 레펠 창이라 파이썬 문법을 입력해야
되는 거고 여기를 exit로 빠져나가서 여기서 이제 파이썬 무슨.

669
00:50:10,258 --> 00:50:13,980
Py에서 실행시키는 건 이렇게 실행을
하셔야 된다라고 설명을 드립니다

670
00:50:14,240 --> 00:50:18,380
코딩 관련 질문은 최치피티한테
기본적인 건 하는 걸 추천드립니다

671
00:50:18,800 --> 00:50:21,017
최치피티 오타가 났다고 해봅시다

672
00:50:21,041 --> 00:50:25,460
여기 오타가 나서 이런 거 실행이 안 돼요

673
00:50:25,540 --> 00:50:31,740
그러면 최치피티한테 이런 거 해놓고 보통
코드를 할 때는 이걸로 감싸면 좋긴 합니다

674
00:50:32,420 --> 00:50:34,740
이 키보드의 왼쪽 맨 위에 있는 거 있죠?

675
00:50:34,860 --> 00:50:35,760
1 옆에 있는 거

676
00:50:35,840 --> 00:50:40,880
이걸로 3개를 써서 감싼 다음에
아래 코드에 뭐가 문제가 알려줘

677
00:50:40,940 --> 00:50:42,900
이렇게만 입력해도 오류를 고쳐줍니다

678
00:50:43,200 --> 00:50:47,740
이렇게 써도 오류를 고쳐서
n이 지금 빠졌는데 n을 채웠죠?

679
00:50:48,300 --> 00:50:49,520
함수 오타입니다

680
00:50:49,680 --> 00:50:51,016
이렇게 오타까지 잘 사용하시면 됩니다

681
00:50:51,040 --> 00:50:54,480
설명해주고 코드를 개선해줘 라고 하면 개선도 해줍니다

682
00:50:54,580 --> 00:50:58,820
근데 이걸 개선할 게 뭐가 있는지는 모르겠지만
좀 복잡한 게 있으면 또 개선도 해주겠죠

683
00:50:58,960 --> 00:50:59,840
에러가 떴습니다

684
00:50:59,980 --> 00:51:02,040
이미 간단하고... 와... 똑똑하네요

685
00:51:02,140 --> 00:51:03,420
이미 간단하고 문제가 없다

686
00:51:03,560 --> 00:51:04,280
너무 좋은데요?

687
00:51:04,320 --> 00:51:05,340
아무튼 뭐 이런 거 있죠?

688
00:51:05,440 --> 00:51:10,780
그러니까 뭔가 에러가 나거나 이건 무슨 문제인가
한 싶은 거는 이렇게 올려서 물어보면 설명을 해줍니다

689
00:51:10,840 --> 00:51:11,400
뭐가 문제인지

690
00:51:11,660 --> 00:51:19,640
유지형님, 최치피티 사용할 때 방금 보여주신 것처럼 기존의 코드에
대한 디버깅을 요청할 때 영어로 질문하면 답변의 정확도가 더 높아지나요?

691
00:51:19,700 --> 00:51:20,700
맞습니다

692
00:51:21,040 --> 00:51:22,440
하시면 뭐든 더 높아집니다

693
00:51:22,480 --> 00:51:24,200
영어 데이터가 더 많기 때문이죠

694
00:51:24,300 --> 00:51:26,580
영어가 질문에 대한 이해부터 정확하니까

695
00:51:26,700 --> 00:51:27,700
네, 저도 정확하죠

696
00:51:27,760 --> 00:51:35,760
그럼 아까 걸로 예로 들면은 아까 이런 거 한글로 쓰니까 더 정확도가
떨어지는데 파파고 같은 거 이용해서 이거를 영어로 이렇게 쉽게 바꿀 수가 있죠

697
00:51:36,460 --> 00:51:39,940
코드 부분은 그대로 두더라도
이런 거는 영어로 바꾸면 좋겠죠

698
00:51:40,160 --> 00:51:42,100
그래서 이 상태로 질문하는 게 낫습니다

699
00:51:42,400 --> 00:51:45,000
영어로 이렇게 질문을 하면 좀 더 정확합니다

700
00:51:45,200 --> 00:51:48,440
그래서 복잡한 질문이 있다면
이건 영어로 하시는 걸 추천드립니다

701
00:51:48,580 --> 00:51:49,780
좋아요 한 번씩만 부탁드리겠습니다

702
00:51:49,980 --> 00:51:50,980
점프 투 파이썬

703
00:51:51,040 --> 00:51:54,900
기장 파이썬 프로그래밍의 초,
자료형에 대해서 배워보도록 하겠습니다

704
00:51:55,120 --> 00:51:58,080
우선 점프 투 파이썬은 박응용 선생님이 지으신 책이고요

705
00:51:58,160 --> 00:51:59,560
제가 강의를 맡게 되었습니다

706
00:51:59,960 --> 00:52:05,510
자료형을 배울 건데 일단은 자료형이 뭔지
개념 설명을 드리면 자료형을 알고 있다면 그

707
00:52:05,534 --> 00:52:10,800
언어의 절반을 터득한 것이라는 말이 있을
정도로 굉장히 자료형이 중요한 요소입니다

708
00:52:10,960 --> 00:52:13,300
어떤 언어를 배우든 빠지지 않는 개념이고요

709
00:52:13,420 --> 00:52:18,540
그럼 자료형이 어떤 건지 직관적으로 와닿지는
않으니까 자료형이란 예시를 통해서 보도록 하겠습니다

710
00:52:18,800 --> 00:52:20,257
1 더하기 1이 뭘까요?

711
00:52:20,281 --> 00:52:21,780
2라고 생각을 하시잖아요

712
00:52:21,900 --> 00:52:26,760
근데 자료형에 따라서 파이썬이나 다른
프로그래밍 언어에서 2가 아닐 수가 있습니다

713
00:52:26,940 --> 00:52:34,940
2가 아니라 1도 문자열이고 2, 1도 문자열이라면 문자열끼리
더한다라는 개념은 문자끼리 붙인다라는 개념이거든요

714
00:52:35,920 --> 00:52:40,040
그래서 문자끼리 붙이면 1, 1
이렇게 연결된 1, 1이 될 수가 있습니다

715
00:52:40,260 --> 00:52:47,920
자료형이 숫자라면 여러분들이 생각하시는 2가 맞는데 이게
자료형이 문자 자료형이라면 더하면 그냥 1, 1이 돼버립니다

716
00:52:48,020 --> 00:52:50,256
그래서 이런 개념을 알아야 결과가...

717
00:52:50,280 --> 00:52:56,720
확 달라질 수 있기 때문에 자료형에 대해서는 알아야 되고
자료형은 이런 것이다 라고 좀 큰 개념 설명을 드려봤습니다

718
00:52:56,800 --> 00:53:02,200
이런 자료형 뭐 숫자도 있을 것이며 아까 말한
문자도 있을 것이며 되게 다양하게 있을 거잖아요

719
00:53:02,240 --> 00:53:06,920
어떤 것이 있는지 좀 소개를 드리면
숫자, 문자열, 문자열이 문자랑 같습니다

720
00:53:07,220 --> 00:53:09,860
불, 변수, 리스트, 튜플, 딕셔널의 집합

721
00:53:09,940 --> 00:53:11,156
어우 이름이 좀 어렵죠

722
00:53:11,180 --> 00:53:16,560
이렇게 많은 자료형이 있는데 이거를 2장
동안에 다 배워볼 거고 자료형마다 특징이 있어요

723
00:53:16,700 --> 00:53:19,860
그래서 그런 특징들이 어떻게 되는지
하나씩 보여드리도록 하겠습니다

724
00:53:20,280 --> 00:53:25,380
네, 그러면 일단 그전에 좀 선제적으로
알아야 되는 개념이 변수라는 개념이 있어요

725
00:53:25,520 --> 00:53:33,520
그래서 저희가 실습을 해보면서 항상 뭐 변수에 값을 담는다 뭐 이런
표현을 제가 주로 할 건데 변수가 어떤 건지 좀 소개를 드리도록 하겠습니다

726
00:53:34,620 --> 00:53:35,780
변수는 상자입니다

727
00:53:35,880 --> 00:53:41,176
쉽게 말해서 그냥 이런 박스 안에 뭔가
값을 담는다라고 일단 이해하시기 편한데요

728
00:53:41,200 --> 00:53:42,200
이런 개념입니다

729
00:53:42,300 --> 00:53:44,560
프로그래밍에서 되게 헷갈릴 수 있는 부분

730
00:53:44,680 --> 00:53:49,780
그러니까 그 프로그래밍을 아예 처음 접한다라고
하면 이게 좀 당황스러울 수 있는데 a는 3이...

731
00:53:50,280 --> 00:53:52,080
a가 3이랑 같다라는 뜻이 아닙니다

732
00:53:52,140 --> 00:53:55,060
이거는 어떤 뜻이냐면 약간 시간 차이가 있어요

733
00:53:55,220 --> 00:53:59,340
등호 뒤쪽에 있는 것을 a라는 상자에 담는다라는 개념입니다

734
00:53:59,500 --> 00:54:03,240
그래서 이게 수학에서 말하는 그 같다라는 등호가 아니에요

735
00:54:03,420 --> 00:54:06,900
그래서 이 프로그래밍 할 때 이
점은 꼭 유의를 해주시기 바랍니다

736
00:54:07,100 --> 00:54:12,160
좀 직관적으로 보여드리면 이 3이라는 값을
a 안에 넣는다의 개념이 등호의 개념입니다

737
00:54:12,220 --> 00:54:20,060
그래서 뭐 진짜 이게 같은가를 비교할 때는 등호를 두 개 쓰게 되는데
이거는 뒤에서 배우고 일단 이거 기본을 알아야 이제 뒤에가 이해돼서

738
00:54:20,280 --> 00:54:21,280
이걸 설명을 드렸습니다

739
00:54:21,340 --> 00:54:26,000
그래서 이게 그 등호라고 생각을 하면은
굉장히 말도 안 되는 상황이 벌어집니다

740
00:54:26,120 --> 00:54:28,400
프로그래밍에서 이런 표현이 굉장히 많거든요

741
00:54:28,620 --> 00:54:34,720
A는 a 더하기 1이라는 표현이 굉장히 많이 쓰이는데
그럼 수학으로 생각하면 말도 안 되는 표현이죠.

742
00:54:34,840 --> 00:54:36,820
A가 a 더하기 1이랑 같다고?

743
00:54:36,920 --> 00:54:39,820
라고 생각하면 양변에 a를 지우면은 0은 1이 되잖아요

744
00:54:40,020 --> 00:54:43,260
그래서 이게 말도 안 되는 표현이다라고
생각할 수 있는데 그게 아닙니다

745
00:54:43,300 --> 00:54:49,480
A 더하기 1을 먼저 계산을 해서 이걸 a라는
상자 안에 넣는다라는 개념이라서 예를 들어 만약.

746
00:54:50,280 --> 00:54:57,800
A가 처음에 3이었다라고 하면 a가 3이니까 3 더하기
1을 해서 4를 다시 a라는 상자에 넣는다라는 개념입니다

747
00:54:57,900 --> 00:55:03,020
이렇게 먼저 이해를 하고 가시면 등호의
개념을 좀 더 직관적으로 이해하실 수 있습니다

748
00:55:03,200 --> 00:55:06,680
그러면 자료형 첫 번째 숫자형에
대해서 배워보도록 하겠습니다

749
00:55:06,980 --> 00:55:10,480
숫자 자료형은 말 그대로 진짜 숫자를 표현하는 자료형입니다

750
00:55:10,820 --> 00:55:12,740
그래서 숫자형 자료형에는 어떤 게 있냐

751
00:55:12,860 --> 00:55:19,280
정수형, 실수형, 컴퓨터 지수 표현
방식, 8진수, 16진수 이런 게 있는데

752
00:55:20,280 --> 00:55:24,300
중요하게 보셔야 될 건 이 두 개
정수형, 실수형 이게 가장 많이 쓰이고요

753
00:55:24,420 --> 00:55:29,260
이거는 그냥 책에 나온 개념이니까 다루는데
막 엄청 많이 쓰일 일이 잘 없긴 합니다

754
00:55:29,540 --> 00:55:33,640
그럼 이런 게 있다 정도로 봐두시고 이 두
개만 제대로 이해하고 넘어가시면 되겠습니다

755
00:55:33,920 --> 00:55:36,960
그래서 이거를 하나씩 실습하면서 배워보도록 하겠습니다

756
00:55:37,240 --> 00:55:38,540
일단 정수, 실수가 중요하다

757
00:55:38,640 --> 00:55:44,240
그래서 이런 표현들이 나오는데 int가
integer라는 영어의 약자로 이렇게 int로 쓰이고요.

758
00:55:44,680 --> 00:55:49,540
Float는 float고 아무튼 이런 영어
표현도 이게 혼용이 돼서 쓰일 때가 있어서

759
00:55:50,280 --> 00:55:52,760
이 정도는 이렇게 매칭해서 알아두시면 좋을 것 같습니다

760
00:55:52,920 --> 00:55:54,340
그러면 사칙연산

761
00:55:54,420 --> 00:56:00,080
프로그래밍 언어가 되게 다양하게 쓰이지만
일단은 기본적으로 계산을 하는 걸로 출발했잖아요

762
00:56:00,160 --> 00:56:00,560
컴퓨터가

763
00:56:00,600 --> 00:56:03,300
그래서 가장 기본적인 계산하는 것을 배워보도록 하겠습니다

764
00:56:03,600 --> 00:56:11,580
그러면 실습하면서 배워볼 텐데 지난 1주차에서 파이썬을
설치하시고 에디터를 설치하셨다면 이렇게까지 띄우실 수가 있을 겁니다

765
00:56:11,800 --> 00:56:16,920
이거는 다시 보여드리면 오픈 폴더를 통해서
C드라이브에 파이썬이라는 폴더를 만들었죠

766
00:56:16,960 --> 00:56:18,420
여기서 작업을 해보도록 하겠습니다

767
00:56:18,600 --> 00:56:19,600
폴더 선택을 하면

768
00:56:20,280 --> 00:56:23,060
폴더가 열리고 지난주에 이렇게
두 개의 파일을 한번 써봤었죠

769
00:56:23,100 --> 00:56:26,740
이제 좀 주차별로 폴더를 나눠서 진행을 해보도록 하겠습니다

770
00:56:26,880 --> 00:56:31,560
그럼 new folder를 만들어서 chapter2라는
폴더를 만들어 주도록 하겠습니다

771
00:56:32,020 --> 00:56:39,460
이게 약간 어떤 개념인지 헷갈릴 수 있으니까 이
폴더 안에 2-1.py라는 파일을 만들어 보도록 하겠습니다

772
00:56:39,680 --> 00:56:45,060
그러면 윈도우 탐색기로 보면 마우스 우클릭 세
번째를 누르면 이렇게 파일 탐색기에서도 볼 수 있는데

773
00:56:45,200 --> 00:56:48,860
파이썬이라는 폴더가 있었는데
여기에 chapter2라는 폴더를 만들었고

774
00:56:48,920 --> 00:56:49,697
이 안에 들어오면

775
00:56:49,721 --> 00:56:51,560
2-1.py라는 파일이 생겼죠

776
00:56:51,600 --> 00:56:57,600
실습을 할 때는 물론 직접 타이핑해도 되는데 처음에
소개해 드린 것처럼 jump to python wikidocs가 있습니다

777
00:56:57,800 --> 00:57:00,640
보시면은 여기서 이제 코드 복사하기가 좀 편하잖아요

778
00:57:00,800 --> 00:57:01,860
챕터별로 잘 나와 있고요

779
00:57:02,060 --> 00:57:05,660
숫자형 들어가면 정수형 할 때
이런 거 복사해서 쓰실 수가 있습니다

780
00:57:05,880 --> 00:57:09,780
그래서 코드 복사할 때는 여기 wikidocs에서
같이 복사를 해 주시면 되겠습니다

781
00:57:09,980 --> 00:57:12,460
정수형 일단 뭔지 한 번씩 찍어 볼까요?

782
00:57:12,600 --> 00:57:13,600
A는 123

783
00:57:13,740 --> 00:57:15,120
이런 게 정수죠

784
00:57:15,220 --> 00:57:16,220
이 양의 정수

785
00:57:16,280 --> 00:57:17,540
얘는 음의 정수

786
00:57:17,640 --> 00:57:19,696
0을 포함해서 정수라고 부릅니다

787
00:57:19,720 --> 00:57:24,871
실습을 해 보면 복사해서 프린트 a만
하면은 여기 오른쪽 위에 이 재생 실행

788
00:57:24,895 --> 00:57:29,260
버튼을 누르면 123이 찍히는데 여기에
a의 타입이라고 감수할 수가 있습니다

789
00:57:29,400 --> 00:57:33,960
프린트 안쪽에 타입이라는 걸 쓰고
괄호 열고 닫고 안에 a를 넣었습니다

790
00:57:34,200 --> 00:57:35,220
이거를 실행을 해 보겠습니다

791
00:57:35,480 --> 00:57:38,680
이 a의 타입이 class int라고 나오죠

792
00:57:38,720 --> 00:57:44,880
그러면 이 a가 int 즉 정수형 자료형이다
라는 거를 타입을 통해서 찍어 볼 수가 있습니다

793
00:57:45,080 --> 00:57:46,320
다른 것도 해 볼 수 있겠죠

794
00:57:46,480 --> 00:57:49,640
Wikidocs랑 보면 실수형은 a는 1.2 이런 거죠

795
00:57:49,720 --> 00:57:56,382
소수점 있는 게 실수형 자료형인데 다시
한번 실행을 해 보면 이제는 1.2니까 float형

796
00:57:56,406 --> 00:58:01,680
자료형이라고 나오고 타입을 찍어 봤을 때
이렇게 float라고 나오는 것을 확인할 수 있습니다

797
00:58:01,780 --> 00:58:04,380
이렇게 자료형들을 좀 구분을 해 볼 수가 있겠습니다

798
00:58:04,660 --> 00:58:09,977
이거 그냥 간단하게만 소개해 드리면
공학용 계산기 이런 거 써보신 분들은 막 숫자가

799
00:58:10,001 --> 00:58:14,320
너무 쭉 길어지면은 무슨 2에 10
이렇게 써져 있는 경우 가끔 보셨을 겁니다

800
00:58:14,500 --> 00:58:18,100
그래서 실수형 중에 좀 숫자
자리가 커지면은 이렇게도 됩니다

801
00:58:18,280 --> 00:58:19,696
그래서 얘도 마찬가지입니다

802
00:58:19,720 --> 00:58:24,080
마찬가지로 float 자료형이긴 한데
이거를 그냥 출력해 보면 이렇게 나옵니다.

803
00:58:24,920 --> 00:58:27,020
Cls라고 입력하면 얘가 정리가 됩니다.

804
00:58:27,560 --> 00:58:31,160
Cls라고 하고 정리를 한 다음에
다시 실행을 해 보면 이렇게 나오죠

805
00:58:31,240 --> 00:58:37,360
4.24 곱하기 22 무슨 뜻이냐면
4.24에 곱하기 10에 10승인 겁니다

806
00:58:37,580 --> 00:58:40,220
쓰는 표현식이 이렇게 22로 표현을 할 수가 있습니다

807
00:58:40,420 --> 00:58:44,540
공이 그러면은 10개가 이 뒤로
쭉쭉 땡겨 가지고 추가가 되겠죠

808
00:58:44,640 --> 00:58:47,537
그래서 이거는 이제 수학적 표현도 여기서 사용할 수 있다

809
00:58:47,561 --> 00:58:52,040
8진수와 16진수 요런 거는 거의 안 쓰이긴 하거든요

810
00:58:52,180 --> 00:58:55,100
그래서 그냥 간략하게만 소개해 드리고 넘어가도록 하겠습니다

811
00:58:55,400 --> 00:58:57,640
여기서 말고는 볼 일이 없긴 할 겁니다

812
00:58:57,940 --> 00:59:01,940
예를 들어 10이라고 치면 이게
10진수에서는 그냥 10이잖아요

813
00:59:02,020 --> 00:59:07,569
근데 이 8진수로 바꾸는 표현식이 05
이게 아마 옥타 뭐 이런 걸로 표현되어 있을

814
00:59:07,593 --> 00:59:13,000
텐데 05를 앞에 붙이면 0510이 뭐냐면
출력해 보면 놀랍게도 8이 나옵니다

815
00:59:13,080 --> 00:59:13,496
그래서 어?

816
00:59:13,520 --> 00:59:17,517
10을 썼는데 왜 8이 나오지 라고
하면 진수의 개념을 생각해 보면요

817
00:59:17,541 --> 00:59:21,151
8진수의 개념을 생각해 보시면 이해하실
수 있는데 보통 사람 손가락 10개니까 이제

818
00:59:21,175 --> 00:59:25,480
10진수가 됐는데 123456789 10
하고 그 다음에 11로 넘어가잖아요

819
00:59:25,560 --> 00:59:32,260
근데 8진수는 1234567 하고 8을 표현을
못해서 한 자리가 넘어가서 10이 되버립니다

820
00:59:32,360 --> 00:59:38,300
아 요거는 약간 어려울 수 있어서 그냥 진수의
개념을 아신다 라고 하면 먼지가 이해되실 거고요

821
00:59:38,340 --> 00:59:40,280
8 더하기 0이 되는 거죠

822
00:59:40,380 --> 00:59:44,180
약간 그냥 이거는 좀 지적 허용심을 충족하기 위한 겁니다

823
00:59:44,320 --> 00:59:46,197
사실 파이썬이랑 크게 상관은 없는데

824
00:59:46,221 --> 00:59:47,820
약간 못 넘어가시는 분들 있잖아요

825
00:59:48,000 --> 00:59:50,100
아 이런 게 있구나 정도로 이해하시면 될 것 같습니다

826
00:59:50,380 --> 00:59:54,300
16진수도 표현할 때 5X로 시작하면 16진수입니다

827
00:59:54,520 --> 00:59:59,300
그래서 이것도 그냥 출력만 해보면
이거는 어떤 식이냐면 알파벳이 왜 나오냐

828
00:59:59,360 --> 01:00:04,800
10이 넘어가는데 그 숫자를 표현할 게
없으니까 11을 그냥 A로 표현을 합니다

829
01:00:04,960 --> 01:00:06,876
그래서 A라고 쓰면은 12 나와요

830
01:00:06,900 --> 01:00:09,600
왜냐면 이 A가 10이고 B가 11입니다

831
01:00:09,720 --> 01:00:09,900
그러면

832
01:00:10,040 --> 01:00:15,157
요거는 이제 진수 표현을 아시는 분들만 아 이게
이렇게 표현하는구나 정도로 알고 넘어가시면 됩니다

833
01:00:15,181 --> 01:00:18,920
전혀 중요하지 않은 부분을 그냥
책에 나오기 때문에 잠깐 다뤄봤습니다

834
01:00:19,000 --> 01:00:20,820
이제 중요한 거 넘어가도록 하겠습니다

835
01:00:21,040 --> 01:00:23,940
사칙연산 더하기 빼기 곱하기 나누기 이죠

836
01:00:24,000 --> 01:00:27,300
그래서 그거를 어떻게 하는지 하나씩 보여드리도록 하겠습니다

837
01:00:27,480 --> 01:00:32,340
가장 쉬운 더하기 A는 3 B는 4 요거
복사해서 한번 써보도록 하겠습니다

838
01:00:32,640 --> 01:00:37,760
참고로 이렇게 꺽새 3개가 이렇게
나와서 아니 왜 이렇게 쓰나라고 생각해보면

839
01:00:37,880 --> 01:00:39,660
그 이전 시간에 제가 말씀드렸죠

840
01:00:39,700 --> 01:00:43,237
파이썬이라고 쓰면 이 레펠이라는
표현식에서 쓸 수 있기 때문에

841
01:00:43,261 --> 01:00:46,680
이 책에서는 이 레펠에서 쓰라고 이게 나온 겁니다

842
01:00:46,820 --> 01:00:53,000
근데 레펠보다는 그냥 파일로 남기는 편이 좀 편리하기
때문에 여기 파일에 저희는 남겨서 해보도록 하겠습니다

843
01:00:53,500 --> 01:00:56,160
프린트 A 더하기 B를 해보도록 하겠습니다

844
01:00:56,360 --> 01:00:58,040
실행하면 이렇게 7이 나오죠

845
01:00:58,100 --> 01:00:59,100
너무 간단합니다

846
01:00:59,220 --> 01:01:03,280
그래서 사칙연산 3 더하기 4는 7
이렇게 더하기를 쓸 수가 있고요

847
01:01:03,460 --> 01:01:05,620
그러면 여기 빼기로 바꾸면 마이너스 1이죠

848
01:01:05,880 --> 01:01:07,820
이렇게 표현을 할 수도 있겠고요

849
01:01:07,920 --> 01:01:10,160
파이썬에서 곱하기는 별로 표현합니다

850
01:01:10,440 --> 01:01:11,560
이 별이 뭐냐면

851
01:01:11,720 --> 01:01:13,177
키보드를 같이 보여드리면

852
01:01:13,201 --> 01:01:16,740
쉬프트하고 8번 이렇게 하면 별이 나오잖아요

853
01:01:16,860 --> 01:01:17,860
곱하기 기호로 씁니다

854
01:01:17,900 --> 01:01:19,440
나누기는 이렇게 씁니다

855
01:01:19,580 --> 01:01:21,440
슬래시가 어딨냐면 여기 있죠

856
01:01:21,580 --> 01:01:22,700
물음표랑 슬래시 있는

857
01:01:22,780 --> 01:01:24,220
이거를 누르면 나누기입니다

858
01:01:24,520 --> 01:01:27,400
이걸 실행하면 0.75가 나오겠죠

859
01:01:27,580 --> 01:01:33,260
자바를 배우거나 다른 언어를 배우신 분들은
이렇게 하면 몫인데 뭐 이런 생각을 하실 수 있는데

860
01:01:33,400 --> 01:01:36,720
몫을 구하려면 파이썬에서는 이거를 두 개 쓰면 됩니다

861
01:01:37,020 --> 01:01:39,900
그래서 이렇게 두 개를 쓰면 몫이 0이 나오는데

862
01:01:40,020 --> 01:01:43,157
이 개념은 이제 뒤에 여기도 나올 거라서 같이 볼게요

863
01:01:43,181 --> 01:01:44,540
뒤에 진행하면서 보도록 하겠습니다

864
01:01:44,720 --> 01:01:46,700
4측 연산에 대해서 다 배워봤고요

865
01:01:46,880 --> 01:01:48,260
제곱을 나타내는 연산자

866
01:01:48,340 --> 01:01:49,620
별 두 개가 제곱입니다

867
01:01:49,820 --> 01:01:50,840
수학에서 이런 거 있잖아요

868
01:01:51,260 --> 01:01:52,280
2에 3승

869
01:01:52,420 --> 01:01:54,460
그럼 2 곱하기 2 곱하기 2 해서 8이잖아요

870
01:01:54,580 --> 01:01:57,320
그러면 3, 4가 있을 때 별 두 개를 붙이면 어떻게 되냐

871
01:01:57,440 --> 01:01:58,620
3에 4승이 됩니다

872
01:01:58,820 --> 01:02:02,180
이런 표현을 별 두 개를 써서 지수 표현을 합니다

873
01:02:02,440 --> 01:02:03,440
직접 실습을 해보면

874
01:02:03,480 --> 01:02:07,040
별 두 개를 쓰면 이렇게 81이 나오게 되죠

875
01:02:07,100 --> 01:02:08,100
쓰실 수가 있겠습니다

876
01:02:08,340 --> 01:02:10,700
그다음에 나머지를 리턴하는 연산자

877
01:02:11,120 --> 01:02:12,157
%라는 연산자는

878
01:02:12,181 --> 01:02:13,580
나머지를 리턴합니다

879
01:02:13,720 --> 01:02:14,820
이게 무슨 개념이냐

880
01:02:14,860 --> 01:02:16,220
예제로 보도록 하겠습니다

881
01:02:16,500 --> 01:02:19,020
7% 3을 하면 1이 나옵니다

882
01:02:19,160 --> 01:02:20,960
아니 이게 도대체 어떻게 나오는 건가

883
01:02:21,640 --> 01:02:22,640
나머지거든요

884
01:02:22,680 --> 01:02:25,360
7을 3으로 나눈다고 했을 때

885
01:02:25,440 --> 01:02:29,040
3 곱하기 2를 해서 이렇게 나머지가 1이 남는다

886
01:02:29,120 --> 01:02:30,400
얘를 몫이라고 하죠

887
01:02:30,480 --> 01:02:33,880
이 나머지를 구하기 위해서 이렇게 % 기호를 쓰게 됩니다

888
01:02:34,080 --> 01:02:35,200
그러면 몫은 뭐냐

889
01:02:35,280 --> 01:02:37,340
슬래시 두 개를 쓰면 2가 나오죠

890
01:02:37,420 --> 01:02:40,200
이렇게 몫과 나머지를 구하는 방법을 배워봤습니다

891
01:02:40,420 --> 01:02:42,060
다음으로 문자열에 대해서

892
01:02:42,180 --> 01:02:42,760
진행해보겠습니다

893
01:02:43,040 --> 01:02:46,300
문자열 자료형은 말 그대로 정말 문자입니다

894
01:02:46,580 --> 01:02:50,960
그래서 아까 1 더하기 1 설명드릴 때
문자끼리 더하면 그냥 붙는다고 말씀을 드렸죠

895
01:02:51,060 --> 01:02:53,960
네 가지 방법이 있는데 그거를 하나씩 해보도록 하겠습니다

896
01:02:54,200 --> 01:02:55,940
문자열이란 이렇게 표현이 됩니다

897
01:02:56,260 --> 01:02:59,880
이 a b c 모두 문자열 자료형입니다.

898
01:03:00,100 --> 01:03:01,980
Type이라는 걸로 찍어볼 수가 있습니다.

899
01:03:02,180 --> 01:03:07,040
A를 쓰게 되면 이 a라는 자료의
type을 볼 수가 있다고 말씀드렸죠

900
01:03:07,100 --> 01:03:11,900
그래서 이걸 실행해보면 이제는
str이라고 나온 것을 확인할 수가 있습니다

901
01:03:12,180 --> 01:03:15,240
이렇게 보시면 str이 string이라는 것의 약자인데요

902
01:03:15,340 --> 01:03:17,920
네 string이 이제 문자열 자료형의 의미입니다

903
01:03:18,040 --> 01:03:19,500
처음 보면 좀 헷갈리는 개념이 있어요

904
01:03:19,660 --> 01:03:24,680
A랑 뭐 life is too short 이런 거는
문자열이란 건 알겠는데 123은 숫자가 아니냐

905
01:03:24,740 --> 01:03:28,680
네 123이 숫자가 아니고 따옴표로 감싸면 문자로 봅니다

906
01:03:28,840 --> 01:03:34,640
1 더하기 1이 그냥은 2인데 이렇게 따옴표로
감싸면 문자열이 돼서 일일이 붙어버리게 됩니다

907
01:03:34,840 --> 01:03:36,860
이거는 숫자라도 문자로 바뀐다

908
01:03:36,900 --> 01:03:39,537
큰 따옴표로 양쪽을 감싸서 만들 수가 있고요

909
01:03:39,561 --> 01:03:42,020
작은 따옴표로 만들어도 똑같습니다

910
01:03:42,140 --> 01:03:46,140
작은 따옴표로 만들어도 타입을
찍어보면 똑같이 string입니다

911
01:03:46,300 --> 01:03:49,720
일단 큰 따옴표 3개를 연속으로
써서 또 만들 수가 있습니다

912
01:03:49,980 --> 01:03:52,520
이렇게 만들면 이것 또한 string입니다

913
01:03:52,660 --> 01:03:57,920
아니면 작은 따옴표 3개 이렇게
감싸도 이것 또한 string입니다

914
01:03:58,320 --> 01:04:01,420
네 그래서 만드는 방법 총 4가지를 살펴봤습니다

915
01:04:01,580 --> 01:04:03,940
근데 왜 이렇게 하냐 이런 일이 있을 수가 있습니다

916
01:04:04,160 --> 01:04:09,700
예를 들어 이렇게 큰 따옴표로 만들었는데 시작을 해
보았는데 이 안에 따옴표를 포함하고 싶을 때도 있을 수 있죠

917
01:04:09,780 --> 01:04:12,600
라이프하고 이 중간에 다운표를 넣고 싶어요

918
01:04:12,680 --> 01:04:14,140
그런데 그러면 깨지게 됩니다

919
01:04:14,320 --> 01:04:21,100
라이프 이렇게 따옴표를 이렇게 팩스트링을 만들고
싶은데 여기에 다운표가 들어가 버리면 어떻게 되냐?

920
01:04:21,360 --> 01:04:27,540
프로그램 파이썬이 인식하기에는 여기서
시작해서 여기서 끝나고 있는 것이라고 할 수 있습니다

921
01:04:27,700 --> 01:04:31,997
그러면 스트링이 여기까지가 스트링이
되고 이것의 뒤에는 오류가 되어 버리는 거에요

922
01:04:32,021 --> 01:04:33,936
실제로 실행을 해보면 이렇게 오류가 나왔죠?

923
01:04:33,960 --> 01:04:39,900
그래서 스트링이 여기서 끝이 나버렸는데 뒤에는 뭐지라고
의문을 품게 되는데 이렇게 쓰면 안되고 굳이 쓰고 싶다!

924
01:04:39,960 --> 01:04:41,120
하면 여러 방법이 있어요

925
01:04:41,220 --> 01:04:47,044
여기에 작은 따옴표로 감싸게 되면 그러면
작은 따옴표로 스트링을 만들었으니까 작은 따옴표

926
01:04:47,068 --> 01:04:51,976
시작과 끝을 이은 이게 스트링이 되고 이
안에 큰 따옴표가 들어 있는 건 아무 상관없죠?

927
01:04:52,000 --> 01:04:56,380
이렇게 만들면 문자열 안에 큰 따옴표
가 잘 들어간 것을 확인할 수 있죠

928
01:04:56,500 --> 01:05:01,280
그래서 이렇게 표시할 수 있고 그러면
마찬가지로 작은 따옴표를 넣으려면 이러면 깨지겠죠

929
01:05:01,440 --> 01:05:08,080
또 작은 따옴표를 넣기 위해서는 큰 따옴표, 큰 따옴표로
감싸면 이렇게 작은 따옴표를 문자열 안에 포함할 수가 있겠죠

930
01:05:08,240 --> 01:05:11,340
그럼 이렇게까지는 알겠는데 굳이 큰 따옴표를 넣고 싶어요

931
01:05:11,440 --> 01:05:12,560
그런데 그럴 땐 어떻게 하냐

932
01:05:12,600 --> 01:05:15,940
여기에 백슬래시를 넣으면 특수기호 같은 느낌이거든요

933
01:05:16,120 --> 01:05:20,120
그래서 백슬래시 뒤에 뭔가 이런
문자가 있으면 얘를 보존할 수가 있습니다

934
01:05:20,300 --> 01:05:28,300
그러니까 여기서 문자가 끝나지 않게 얘는 그냥 스트링 안에
들어가는 큰 따옴표야 라고 말해주는 그런 언어가 이제 백슬래시입니다

935
01:05:29,101 --> 01:05:33,020
그래서 이 백슬래시는 어디냐면 그
키보드에 보통 엔터 위에 있습니다

936
01:05:33,160 --> 01:05:35,200
아니면 원표시가 이렇게 들어가 있는 경우도 있죠

937
01:05:35,300 --> 01:05:37,820
키보드 따라 좀 다를 텐데 이게 백슬래시입니다

938
01:05:37,940 --> 01:05:42,420
그래서 요거를 누르면 그 따옴표나 큰
따옴표를 보존할 때 쓰이는 용도입니다

939
01:05:42,560 --> 01:05:46,760
그래서 작은 따옴표를 해서 이걸
쓰려면은 아임에 요 따옴표 보통 쓰잖아요

940
01:05:46,900 --> 01:05:49,436
근데 아임에 따옴표를 쓰고 싶은데 이러면 오류가 났죠

941
01:05:49,460 --> 01:05:51,236
왜냐하면 요게까지가 스트링이 돼버리니까

942
01:05:51,260 --> 01:05:57,397
이제 백슬래시를 써주게 되면 이제 따옴표가 유지가 되면서
텍스트 스트링인 상태로 유지가 되면서 이걸 완성할 수가 있습니다

943
01:05:57,421 --> 01:06:03,020
아 이거 항상 이거 뭔가 수정하고 안 돼요 하시는
분들 중에 대부분이 저장이 안 돼서 그렇습니다

944
01:06:03,060 --> 01:06:10,080
요게 하얀색 동그라미가 뜨면은 이게 저장이 안 된
거인데 여기서 컨트롤 플러스 S를 하면 저장이 됩니다

945
01:06:10,260 --> 01:06:12,520
저장하는 거를 습관화 해주시면 되겠습니다

946
01:06:12,720 --> 01:06:16,160
저장하고 실행하면 이렇게 아임
헝그리에서 따옴표가 잘 들어갔죠

947
01:06:16,200 --> 01:06:20,240
문자열에 따옴표를 포함시키는
방법에 대해서 쭉 다 소개를 드렸습니다

948
01:06:20,580 --> 01:06:23,940
여러 줄인 문자열을 변수에 대입하고 싶을 때가 있습니다

949
01:06:24,300 --> 01:06:27,396
줄을 바꾸기 위한 escape 코드를 사용합니다

950
01:06:27,420 --> 01:06:28,040
합입할 수가 있습니다

951
01:06:28,240 --> 01:06:32,320
먼저 그냥 따옴표로도 그 한 줄
내려서 줄 바꾸기 쓸 수가 있습니다

952
01:06:32,500 --> 01:06:37,854
그래서 출력해보면 그냥 이렇게 나오는데
직접 이렇게 엔터를 치면 오류가 나니까 줄

953
01:06:37,878 --> 01:06:42,620
바꾸기를 문자로 표현하고 싶다라고 한다면
백슬래시 N을 입력하시면 줄 바꾸기 됩니다

954
01:06:42,820 --> 01:06:44,240
실행하면 줄 바꾸기 됐죠

955
01:06:44,300 --> 01:06:48,400
그래서 백슬래시 N이 줄 바꾸기의
역할을 하는 좀 특수한 문자입니다

956
01:06:48,540 --> 01:06:51,080
종종 쓸 일이 있으니까 기억해 두시면 좋을 것 같습니다

957
01:06:51,220 --> 01:06:53,700
두 줄이면은 요렇게 돼서 일단은 깨집니다

958
01:06:53,800 --> 01:06:54,880
딱 봐도 깨졌죠

959
01:06:54,920 --> 01:06:57,120
두 줄을 포함하고 싶은데 안됩니다

960
01:06:57,420 --> 01:06:59,156
그래서 얘를 실행해보면 오류가 나요

961
01:06:59,180 --> 01:06:59,280
어?

962
01:06:59,320 --> 01:07:00,760
이거 왜 따옴표 안 썼어?

963
01:07:00,820 --> 01:07:02,877
라고 파이썬 이 인터프리터가 어?

964
01:07:02,901 --> 01:07:06,817
여기는 왜 여기에 따옴표가 있어야
이 문장인데 왜 다음 줄로 넘어갔지?

965
01:07:06,841 --> 01:07:07,841
하고 이게 이해를 못합니다

966
01:07:08,020 --> 01:07:10,940
그럴 때 이제 따옴표 3개, 큰 따옴표 3개를 씁니다

967
01:07:11,020 --> 01:07:19,020
그래서 여기에 따옴표 3개를 쓰고 아래쪽에도 따옴표 3개를 쓰면
여러 줄로 썼을 때도 다 인식을 해서 문자열로 만들 수가 있습니다

968
01:07:19,720 --> 01:07:24,100
그래서 얘를 실행하면 이제는 정상적으로
이렇게 두 줄이 잘 나온 것을 확인할 수 있죠

969
01:07:24,220 --> 01:07:26,717
이렇게 쓰기 위해서 이렇게 따옴표 3개를 쓴다

970
01:07:26,741 --> 01:07:27,976
큰 따옴표도 마찬가지입니다

971
01:07:28,000 --> 01:07:30,480
큰 따옴표로 감싸도 이렇게 잘 나옵니다

972
01:07:30,560 --> 01:07:34,580
그러면 이 백슬래시를 쓰는
특수 문자들이 좀 여러 개 있어요

973
01:07:34,760 --> 01:07:38,840
그래서 escape 코드라고 하는데
백슬래시 n을 포함해서 여러 가지가 있습니다

974
01:07:39,060 --> 01:07:43,380
백슬래시 n이 줄 바꿀 때 사용되고
백슬래시 t는 탭 간격을 하나 줍니다

975
01:07:43,520 --> 01:07:44,860
백슬래시 t를 한번 써볼게요

976
01:07:45,000 --> 01:07:46,160
그러면 어떻게 되냐?

977
01:07:46,200 --> 01:07:48,740
이렇게 탭 하나의 간격이 띄워집니다

978
01:07:48,800 --> 01:07:55,397
탭 하나의 간격이라고 하면 이렇게 탭 치면
띄워지는 게 하나, 둘, 셋, 넷, 네 개의 간격이 띄워지죠

979
01:07:55,421 --> 01:07:57,660
그래서 이게 이렇게 네 개의 간격이 띄워진 겁니다

980
01:07:57,840 --> 01:07:59,340
그래서 이런 문자들이 있어요

981
01:07:59,860 --> 01:08:07,860
백슬래시 표현 그대로 사용할 때 아까 따옴표도 마찬가지지만 이것도 마찬가지지만
백슬래시 자체를 표현하고 싶다면 이렇게 백슬래시 두 개를 쓰실 수가 있습니다

982
01:08:10,420 --> 01:08:12,660
그러면 이렇게 백슬래시가 표시가 되죠

983
01:08:13,360 --> 01:08:18,720
작은 따옴표, 큰 따옴표를 해봤고 그
다음에 아래쪽에 이렇게 네 개가 있잖아요

984
01:08:19,100 --> 01:08:20,820
그 부분은 거의 안 쓰입니다

985
01:08:21,040 --> 01:08:24,240
알아야 되는 건 이렇게 위에 이 정도만 아시면 충분합니다

986
01:08:24,500 --> 01:08:25,396
탭도 잘 안 쓰거든요

987
01:08:25,420 --> 01:08:29,220
그냥 이거, 이거, 이거, 이거
정도만 이해하시면 좋을 것 같습니다

988
01:08:29,500 --> 01:08:32,440
문자열 연산하기를 나가보도록 하겠습니다

989
01:08:32,720 --> 01:08:36,080
그럼 문자열 더해서 연결하기를 알아보도록 하겠습니다

990
01:08:36,640 --> 01:08:42,900
문자열을 더한다라는 개념이 일단은 좀 생소하긴
한데 한번 예제를 그대로 해보도록 하겠습니다

991
01:08:43,440 --> 01:08:45,520
네, 이거를 한번 예제를 출력을 해보겠습니다

992
01:08:46,120 --> 01:08:50,120
헤드라는 게 있고 여기에 파이썬이라는 문자열을 넣는다죠

993
01:08:50,240 --> 01:08:53,777
이거 등호 다시 한번 오른쪽에 있는 걸 왼쪽에 넣는답니다

994
01:08:53,801 --> 01:08:59,240
헤드라는 상자에 파이썬이라는 글자가 들어있고,
띄우고 이스펀이라는 게 테일이라는 상자에 들어있어요

995
01:08:59,620 --> 01:09:02,000
그럼 두 개의 문자열을 더하면 어떻게 되냐?

996
01:09:02,200 --> 01:09:06,720
파이썬에서는 이렇게 두 개를 연결한다의
개념으로 이해하시면 좋을 것 같습니다

997
01:09:06,980 --> 01:09:09,580
그 다음에 문자열 곱하기도 진행하실 수 있습니다

998
01:09:09,860 --> 01:09:13,820
곱하기 3을 하면 파이썬, 파이썬,
파이썬 이렇게 세 번이 나오게 됩니다

999
01:09:14,120 --> 01:09:17,037
반복해서 붙인다라고 이해하시면 좋을 것 같아요

1000
01:09:17,061 --> 01:09:19,700
그럼 문자열끼리 곱하면 어떻게 되냐?

1001
01:09:19,760 --> 01:09:20,260
안됩니다

1002
01:09:20,460 --> 01:09:23,980
문자열끼리 곱하면 a 곱하기 a라면 오류가 납니다

1003
01:09:24,160 --> 01:09:27,100
그래서 문자열이랑 숫자를 곱할 수가 있습니다

1004
01:09:27,340 --> 01:09:29,660
문자열 곱하기를 응용해보도록 하겠습니다

1005
01:09:30,280 --> 01:09:38,280
이거는 가끔 CLI, 그러니까 커맨드 라인 여기 안에서 뭔가 프로그램을
작성해야 된다라고 한다면 많이 쓰는데 이거를 실행하면 어떻게 되냐면 보통

1006
01:09:39,981 --> 01:09:47,981
여기서는 뭔가 그래픽을 표시할 게 한정적이니까 이런 등호를 쭉 여러
번 써야 되는데 이거를 키보드를 누르면 누르고 있자니 좀 복잡하잖아요

1007
01:09:49,180 --> 01:09:53,420
그래가지고 곱하기 50을 해버리면
등호가 50개가 그냥 쭉 생겨버립니다

1008
01:09:54,140 --> 01:10:00,220
그 다음에 마이 프로그래머를 쓰고 또 프린트
50하면 이렇게 등호가 또 50개 쭉 써지겠죠

1009
01:10:00,480 --> 01:10:03,540
그래서 이런 식으로 응용을 해볼 수 있다

1010
01:10:03,620 --> 01:10:04,080
곱하기를

1011
01:10:04,180 --> 01:10:06,120
라고 소개를 드릴 수가 있겠습니다

1012
01:10:06,820 --> 01:10:09,860
문자열 길이 구하기를 해보도록 하겠습니다

1013
01:10:10,380 --> 01:10:12,840
랭이라는 함수를 쓰면 됩니다

1014
01:10:13,220 --> 01:10:19,860
이게 함수라고 부르는데 이렇게 괄호 열고 닫고가 있는 게
이게 사전에 랭이라는 거를 이제 파이썬에서 만들어 놓은 거예요

1015
01:10:19,960 --> 01:10:25,900
그래서 랭 안에 괄호 안에 뭔가 문자열이
들어가면 이 문자열의 길이를 출력을 해줍니다

1016
01:10:26,180 --> 01:10:27,400
17이 나옵니다

1017
01:10:27,460 --> 01:10:28,640
왜 17이냐

1018
01:10:29,080 --> 01:10:30,240
랭이 맞아요

1019
01:10:30,400 --> 01:10:31,440
랭스의 약자입니다

1020
01:10:32,000 --> 01:10:35,160
띄어쓰기 포함해서 17글자니까 이렇게 나옵니다

1021
01:10:35,240 --> 01:10:38,640
그래서 이런 함수가 있다라는 거
기억해 두시면 좋을 것 같습니다

1022
01:10:38,860 --> 01:10:43,380
문자열의 인덱싱과 슬라이싱에 대해서 배워보도록 하겠습니다

1023
01:10:44,040 --> 01:10:45,420
이거 예제로 보시죠

1024
01:10:45,920 --> 01:10:48,120
여기서 이거를 실행하면 어떻게 되냐

1025
01:10:48,180 --> 01:10:49,940
일단 결과부터 보도록 하겠습니다

1026
01:10:50,820 --> 01:10:58,820
결과부터 보면 a에 대괄호를 쓰고 안에
3을 넣었더니 여기에 갑자기 e가 나왔어요

1027
01:10:59,660 --> 01:11:03,260
그럼 이게 무슨 의미인가를 한번
역으로 생각을 해보도록 하겠습니다

1028
01:11:03,840 --> 01:11:08,820
그럼 a에 대괄호 3을 했더니 e가
나온다라는 거는 a가 이제 문자열이잖아요

1029
01:11:09,120 --> 01:11:15,360
그중에서 3번째라는 그 인덱스를
넣어줘서 그거를 가져온 겁니다

1030
01:11:15,920 --> 01:11:21,480
그러면 생각해보면 3을 했을 때
e가 나왔다는 건 e가 여기에 있죠.

1031
01:11:21,560 --> 01:11:23,180
E가 여기에 있습니다

1032
01:11:23,440 --> 01:11:24,700
근데 4번째잖아요

1033
01:11:24,860 --> 01:11:25,140
E가

1034
01:11:25,480 --> 01:11:30,780
근데 4번째인데 왜 e가 나왔지
생각해보면 인덱스는 0번부터 시작합니다

1035
01:11:30,880 --> 01:11:33,820
가장 프로그래밍에서 좀 헷갈릴 수 있는 핵심입니다

1036
01:11:34,000 --> 01:11:37,960
뒤에 나올 리스트라는 개념에서도
0번부터 인덱스가 시작됩니다

1037
01:11:38,040 --> 01:11:38,500
이렇습니다

1038
01:11:38,680 --> 01:11:45,896
그래서 life is too short unit python을
하면은 각각 이 l이 0, i가 1, f가...

1039
01:11:45,920 --> 01:11:49,880
f가 2, e가 3이기 때문에 아까
a에 3을 했을 때 e가 나왔죠

1040
01:11:49,940 --> 01:11:57,300
빈 공백이 4번째 인덱스고 5번째 인덱스, 6번째,
7번째 이런 식으로 쭉쭉쭉 나가서 각각 번호가 붙게 됩니다

1041
01:11:57,560 --> 01:11:59,800
그래서 이거를 인덱싱이라고 부릅니다

1042
01:11:59,980 --> 01:12:01,580
Python 0번부터 숫자를 센다

1043
01:12:01,620 --> 01:12:03,000
굉장히 중요한 개념이고요

1044
01:12:03,100 --> 01:12:05,380
그 다음 인덱싱을 활용해보도록 하겠습니다

1045
01:12:05,760 --> 01:12:08,540
이렇게 하면 어떻게 나올지 예상이 되시나요?

1046
01:12:08,700 --> 01:12:10,040
0번이면 뭐가 나올까요?

1047
01:12:10,120 --> 01:12:12,740
당연히 0번부터 시작되니까 l이 나오겠죠

1048
01:12:12,940 --> 01:12:15,180
그리고 12번은 가다가 13번째...

1049
01:12:15,920 --> 01:12:16,480
13번째가 나올 겁니다

1050
01:12:16,780 --> 01:12:18,240
마이너스 1은 뭘까요?

1051
01:12:18,520 --> 01:12:20,000
역으로 계산을 합니다

1052
01:12:20,160 --> 01:12:20,960
N이 나옵니다

1053
01:12:21,060 --> 01:12:22,780
한번 실행을 해보도록 하겠습니다

1054
01:12:23,520 --> 01:12:29,040
그러면 l 예상대로 나왔고 s는
13번째 글자를 보면 s가 나올 겁니다

1055
01:12:29,280 --> 01:12:31,160
마이너스 1은 거꾸로 갑니다

1056
01:12:31,200 --> 01:12:31,700
N부터

1057
01:12:31,860 --> 01:12:33,920
그럼 마이너스 2를 하면 뭐가 나올까요?

1058
01:12:34,440 --> 01:12:35,500
5가 나옵니다

1059
01:12:35,580 --> 01:12:39,880
왜냐하면 마이너스 1, 마이너스 2
이렇게 가니까 이렇게 할 수가 있겠습니다

1060
01:12:40,700 --> 01:12:43,020
그러면 문자열 인덱싱 좀 이해되시나요?

1061
01:12:43,160 --> 01:12:43,340
어?

1062
01:12:43,380 --> 01:12:44,700
마이너스 33 해볼까요?

1063
01:12:44,780 --> 01:12:45,780
그렇죠

1064
01:12:45,920 --> 01:12:47,520
그러면 34 해야 되네요

1065
01:12:47,620 --> 01:12:52,960
왜냐하면 여기 마이너스 1부터 시작하고
쭉 계산하면 34번째가 l이 될 것 같습니다

1066
01:12:53,160 --> 01:12:54,580
이게 35가 되면 어떻게 될까요?

1067
01:12:54,720 --> 01:12:55,340
오류가 납니다

1068
01:12:55,580 --> 01:12:57,000
인덱스 아웃 오브 레인지

1069
01:12:57,180 --> 01:12:59,640
이 범위를 벗어나버렸다는 뜻입니다

1070
01:12:59,800 --> 01:13:02,960
그다음에 문자열 슬라이싱이라는 개념도 있어요

1071
01:13:03,100 --> 01:13:06,620
거의 비슷한데 이제 슬라이싱은 덩어리로 자르겠다는 겁니다

1072
01:13:06,880 --> 01:13:14,100
그냥 인덱스는 하나씩 뽑아오는 개념이라면 슬라이싱은
어디부터 어디까지라고 이렇게 범위를 정해서 가져오는 개념입니다

1073
01:13:14,220 --> 01:13:15,220
예를 들어

1074
01:13:15,920 --> 01:13:18,500
라이프라는 글자를 가져와서 출력을 하고 싶어요

1075
01:13:18,580 --> 01:13:22,300
그런데 라이프라는 글자를 가져오려면
하나씩 가져오려면 이렇게 해야겠죠

1076
01:13:22,440 --> 01:13:30,440
A에 0번째 l 가져오고 하나씩 가져온 다음에 b에 넣어주면 이렇게
라이프가 나오는데 슬라이싱은 범위를 어디부터 어디까지를 정해줍니다

1077
01:13:31,860 --> 01:13:38,220
이 콜론을 이용해서 0부터 4 미만까지 이렇게
정해주면 이렇게 똑같이 라이프가 나옵니다

1078
01:13:38,260 --> 01:13:39,260
이렇게 쓸 수가 있습니다

1079
01:13:39,320 --> 01:13:41,380
1일 때는 이상 미만이에요

1080
01:13:41,480 --> 01:13:42,400
이상 미만

1081
01:13:42,460 --> 01:13:44,800
그러니까 0 이상 4 미만

1082
01:13:44,880 --> 01:13:45,157
약간

1083
01:13:45,181 --> 01:13:50,080
이것도 수학 개념인데 0 이상
4 미만이면 x에 뭐가 들어갈까요

1084
01:13:50,280 --> 01:13:51,300
부등식에서 배우죠

1085
01:13:51,360 --> 01:13:52,536
23이 들어가죠

1086
01:13:52,560 --> 01:13:53,640
4는 안 들어갑니다

1087
01:13:53,720 --> 01:13:56,680
그래서 이 미만의 개념이 이거 전까지의 의미입니다

1088
01:13:56,840 --> 01:14:01,460
두 번째는 미만이라서 안 들어간다 라고
이해하고 보시면 좀 더 이해하기 가 좋죠

1089
01:14:01,600 --> 01:14:04,320
그 시작번호 끝번호에서 얘를 뺄 수도 있어요

1090
01:14:04,540 --> 01:14:05,840
얘를 빼는 건 어떤 의미냐

1091
01:14:06,120 --> 01:14:07,800
유니드 파이썬이 나왔어요

1092
01:14:07,880 --> 01:14:08,700
이건 무슨 말이냐

1093
01:14:08,760 --> 01:14:10,040
여기 이상 미만이죠

1094
01:14:10,160 --> 01:14:13,480
그런데 미만이 없다는 것은 이게 끝까지의 의미입니다

1095
01:14:13,580 --> 01:14:14,460
이게 비어 있다

1096
01:14:14,560 --> 01:14:15,156
비어 있어요

1097
01:14:15,180 --> 01:14:16,940
비어있으면 끝까지의 의미입니다

1098
01:14:17,020 --> 01:14:20,720
그러면 얘가 처음에 비어있으면 처음부터의 의미입니다

1099
01:14:20,880 --> 01:14:26,040
그럼 여기서 그냥 빠르게 간격이 뭔지
소개해드리면 콜론 하나 더 넣고 2라고 써볼게요

1100
01:14:26,200 --> 01:14:29,660
그러면 처음부터 끝까지 두 칸 간격으로 가져오는 거잖아요

1101
01:14:29,820 --> 01:14:36,943
출력해보면 이렇게 이상하게 나오는데 잘
생각해보면 l 나오고 한 칸 띄우 고 f 나오고 또 한 칸

1102
01:14:36,967 --> 01:14:42,960
띄우고 공백 나오고 이런 식으로 한 칸씩 띄
어서 이렇게 두 칸 간격으로 나오는 걸 볼 수가 있죠

1103
01:14:43,100 --> 01:14:43,337
네

1104
01:14:43,361 --> 01:14:45,440
이렇게 뽑아낸 것을 확인할 수가 있습니다

1105
01:14:45,660 --> 01:14:46,720
이렇게 하면 어떻게 될까요

1106
01:14:47,000 --> 01:14:49,160
음수로 하면 거꾸로 됩니다

1107
01:14:49,600 --> 01:14:54,720
N o h t y p n o h t y p 이렇게 되죠

1108
01:14:54,780 --> 01:14:56,760
그리고 마이너스 2를 하면 어떻게 될까요

1109
01:14:56,900 --> 01:15:02,480
N h y 공백 n h y 공백 이렇게 되죠

1110
01:15:02,560 --> 01:15:06,980
이렇게 거꾸로 가는 게 음수라고 보시면 될 것 같습니다

1111
01:15:07,700 --> 01:15:10,920
이상 미만 할 때도 마이너스 7로 계산할 수도 있습니다

1112
01:15:11,280 --> 01:15:12,500
약간 복잡하긴 한데

1113
01:15:13,360 --> 01:15:14,360
이렇게 계산도 됩니다

1114
01:15:14,460 --> 01:15:21,380
마이너스 7번 인덱스 찾아서 그것 어차피
이렇게 인덱스 계산은 마이너스 7번이면 여기죠

1115
01:15:21,860 --> 01:15:23,040
7번 인덱스가 이거죠

1116
01:15:23,100 --> 01:15:26,320
그럼 이거 미만이니까 이렇게 전까지 가 되겠죠

1117
01:15:26,400 --> 01:15:28,440
그래서 이렇게 뭐 이런 식으로도 자를 수가 있다

1118
01:15:28,880 --> 01:15:32,580
얘는 인덱스가 마이너스 7번이니까 아까 몇 번이었죠

1119
01:15:32,620 --> 01:15:35,256
19번부터 땡땡해서 이렇게 잘랐 죠

1120
01:15:35,280 --> 01:15:38,280
약간 헷갈릴 수 있는데 이렇게
보면은 좀 이해가 되실 겁니다

1121
01:15:38,880 --> 01:15:38,960
네

1122
01:15:39,040 --> 01:15:40,040
이런 경우가 있어요

1123
01:15:40,120 --> 01:15:41,897
보통 데이터가 막 날라오면은

1124
01:15:41,921 --> 01:15:49,921
이거의 스트링으로 만약 하나의 통채로 날라온다 라고 하면
얘를 나눠 가지고 쓸 일이 좀 있는데 이럴 때 이걸 쓸 수가 있습니다

1125
01:15:50,260 --> 01:15:53,900
그러면 숫자 부분이 있고 뒤에 날씨 부분이 있어요

1126
01:15:54,160 --> 01:16:01,900
23년 3월 31일이 비 오는 날이라고 만약 데이터가 날라왔다고
하면 얘를 따로 구분해 가지고 저장할 일이 있을 수가 있겠죠

1127
01:16:02,060 --> 01:16:08,416
그러면 숫자만 이렇게 자르려면 어떻게 해야 될까를
생각해 보면 몇 번째 인덱스인지 확인을 해 봐야 겠죠

1128
01:16:08,440 --> 01:16:11,877
얘는 01235678

1129
01:16:11,901 --> 01:16:13,560
7번까지가 숫자잖아요

1130
01:16:13,660 --> 01:16:14,460
7번 인덱스까지

1131
01:16:14,620 --> 01:16:19,540
그러면 미만이니까 처음부터 8번 미만까지로 자르면 되겠죠

1132
01:16:19,660 --> 01:16:24,680
나머지 웨더는 8번부터 이상이니까 끝까지로 하면은 되겠죠

1133
01:16:24,860 --> 01:16:32,860
그래서 이런 식으로 자르게 되면은 얘를 출력해 봤을 때 출력해
보면 이렇게 날짜와 문자가 잘 구분 된 것을 확인할 수가 있습니다

1134
01:16:33,460 --> 01:16:35,200
구체적으로 더 나눌 수도 있겠죠

1135
01:16:35,420 --> 01:16:41,200
이거는 굳이 그냥 눈으로만 좀 보자면 그
year day weather 이렇게 세분화할 수도 있겠죠

1136
01:16:41,900 --> 01:16:45,860
이건 23년 나누고 3월 31일 뭐
month랑 day도 나눌 수도 있겠죠

1137
01:16:46,000 --> 01:16:48,960
그래서 이것도 이렇게 슬라이싱으로 쪼개 볼 수가 있겠습니다

1138
01:16:49,180 --> 01:16:52,080
그래서 이런 거는 한 번씩 쭉
연습 을 해 보시면 좋을 것 같습니다

1139
01:16:52,300 --> 01:16:59,360
이 파이썬 이거 예제는 이게 이뮤터블 이런 걸 이해할
필요는 있어서 이거는 이제 뒤쪽에서 다루도록 하고요

1140
01:16:59,700 --> 01:17:00,700
읽어보시면 좋을 것 같습니다

1141
01:17:00,820 --> 01:17:07,000
그래서 이런 파이썬에서 오타를 수정하고 싶다라고 하면 그냥
교체 하면 되지 않을까라는 생각이 있는데 이러면 오류가 납니다

1142
01:17:07,160 --> 01:17:11,660
왜냐하면 문자열은 이뮤터블 자료 형인데
이거는 뒤쪽에서 좀 배우 도록 하겠습니다

1143
01:17:11,860 --> 01:17:15,300
근데 제가 영상에서 이거를 소개 해 드린 적이 있었어요

1144
01:17:15,400 --> 01:17:23,400
그래서 근데 이제는 아시겠죠 여기 이상 미만 간격인데 처음부터 끝까지
역순으로라는 뜻이니까 이 함수 는 palindrome이라고 회문 즉 거꾸로

1145
01:17:25,301 --> 01:17:33,301
읽어도 같은지를 검사하는 그런 코드인데 이런 게 나왔을 때 이제는
이상 미만 간격을 알고 있다면 이런 코드를 좀 이해할 수가 있겠습니다

1146
01:17:33,960 --> 01:17:37,677
이런 식으로 실제로 많이 활용된다
라는 거를 잠깐 소개를 드렸고요

1147
01:17:37,701 --> 01:17:40,380
문자열 포맷팅을 나가보도록 하겠습니다

1148
01:17:41,080 --> 01:17:47,040
그래서 문자열을 쓰고 싶은데 예를 들어
날씨를 온도를 체크해 주는 프로그램이에요

1149
01:17:47,120 --> 01:17:53,740
문자를 계속 출력해 주고 싶다면 그 문자열 전체를 다
입력하려면 현재 온도는 다 입력하려면 좀 귀찮잖아요

1150
01:17:53,900 --> 01:17:57,700
이 포맷을 정해놓고 안에 이
숫자 만 바꿔치기 하고 싶은 겁니다

1151
01:17:57,840 --> 01:18:03,518
그러니까 이걸 다 쓰려면 귀찮 으니까 이 템플릿을
딱 만들어 놓고 이 안에 이거 숫자만 바꿔치기 하거나

1152
01:18:03,542 --> 01:18:10,040
뭐 특정 문자만 바꿔치기 하거나 이런 거를 하고
싶을 때 그때 쓰는 게 문자열 포맷팅이라는 개념입니다

1153
01:18:11,080 --> 01:18:11,280
또 다른 방법이 있습니다

1154
01:18:11,440 --> 01:18:15,420
이것도 나는 사과를 몇 개 먹었다 여기에 %d가 들어갔어요

1155
01:18:15,480 --> 01:18:19,840
이게 뭐냐면은 decimal이라고 이게 십진수의 뜻이거든요

1156
01:18:19,960 --> 01:18:21,697
그러니까 사람이 쓰는 게 십진수 잖아요

1157
01:18:21,721 --> 01:18:27,180
문자열을 쓰고 %d에 어떤 숫자를 쓰면 그
숫자를 가져와서 여기에 넣는다의 개념입니다

1158
01:18:27,300 --> 01:18:35,300
즉 내가 사과를 몇 개 먹는지 프린트 a를 찍어볼 때 여기에
3를 쓸 수 있는데 이걸 숫자만 계속 변화를 주면서 쓸 수도 있겠죠

1159
01:18:35,420 --> 01:18:40,417
이 뒤에 숫자만 바꾸면 이게 안에 들어가서
3이 됐다가 5가 됐다가 10으로 바꾸면

1160
01:18:40,441 --> 01:18:43,480
이게 10이 됐다가 이런 식으로 해 볼 수가 있겠습니다

1161
01:18:43,640 --> 01:18:44,640
다양한 방법이 있습니다

1162
01:18:44,800 --> 01:18:46,020
그래서 이렇게 쓸 수도 있고요

1163
01:18:46,200 --> 01:18:48,600
문자열 바로 대입은 이렇게 쓸 수가 있습니다

1164
01:18:48,900 --> 01:18:53,700
아까 %d였다면 이번엔 s가
있으면 이게 string의 약자겠죠.

1165
01:18:53,880 --> 01:19:01,020
String 문자열 자료형의 약자인데 i it 하고 여기에
5라는 문자열을 이렇게 넣을 때 %s를 쓰게 됩니다

1166
01:19:01,140 --> 01:19:04,700
출력을 해 보면 여기에 5가
잘 들어간 것을 확인할 수 있죠

1167
01:19:04,960 --> 01:19:06,020
이렇게도 가능해요

1168
01:19:06,740 --> 01:19:07,880
넘버라는 변수를 주고

1169
01:19:08,020 --> 01:19:08,637
이거를

1170
01:19:08,661 --> 01:19:10,820
변수를 여기에 넣을 수도 있습니다

1171
01:19:10,980 --> 01:19:12,640
그래서 이게 맞아야겠죠

1172
01:19:12,740 --> 01:19:14,137
이건 숫자니까 숫자로 맞추고

1173
01:19:14,161 --> 01:19:15,760
이렇게 쓸 수가 있겠습니다

1174
01:19:16,400 --> 01:19:18,340
이것도 마찬가지로 잘 출력이 됩니다

1175
01:19:19,120 --> 01:19:20,120
이렇게도 가능합니다

1176
01:19:20,200 --> 01:19:21,060
2개 이상의 값

1177
01:19:21,100 --> 01:19:22,740
2개 이상의 값도 가능합니다

1178
01:19:23,020 --> 01:19:24,240
Number랑 day가 있죠

1179
01:19:25,060 --> 01:19:30,763
각각 number랑 day가 들어갈 자리를
마련해 놓고 뒤에 %를 놓고 number

1180
01:19:30,787 --> 01:19:36,157
day를 넣으면 number는 순서에 맞춰서
이렇게 가고 day는 이렇게 들어가 게 되겠죠

1181
01:19:36,181 --> 01:19:43,260
그래서 이렇게 해서 출력을 해 보면 number가 10이니까
여기로 들어갔 고 day가 3이니까 여기로 들어가게 되었습니다

1182
01:19:43,420 --> 01:19:45,080
그래서 이렇게 바꿔줄 수가 있겠습니다

1183
01:19:45,340 --> 01:19:46,940
여기까지 진행을 해 봤고요

1184
01:19:47,040 --> 01:19:50,980
그다음에 문자열 포맷 코드를 배워 보도록 하겠습니다

1185
01:19:51,420 --> 01:19:56,020
문자열 포맷 코드는 아까 %s는 문자열 %d는 정수

1186
01:19:57,060 --> 01:20:01,500
데시말로 표현이 되는데 정수와
문자열을 배워봤는데 %c도 있습니다

1187
01:20:01,700 --> 01:20:02,960
그때는 문자열 1개

1188
01:20:03,020 --> 01:20:06,156
딱 캐릭터 1개만 넣는 게 %c고 %d는 정수

1189
01:20:06,180 --> 01:20:14,180
그다음에 %f는 부동소수라고 하고 %o는 팔진수 %x는 16진수
%%는 이렇게 인데 이것까지는 다 아실 필요는 없을 것 같고요

1190
01:20:16,100 --> 01:20:17,380
%s만 아셔도 됩니다

1191
01:20:17,660 --> 01:20:21,340
%s를 쓰면 어떤 형태의 값이든 변환해서 넣을 수가 있어요

1192
01:20:21,460 --> 01:20:25,140
이렇게 숫자가 들어갔는데 %s면 사실 타입이 안 맞잖아요

1193
01:20:25,340 --> 01:20:27,697
얘는 숫자고 얘는 문자열이기 때문에

1194
01:20:27,721 --> 01:20:29,860
근데 문자열은 다 수용이 가능합니다

1195
01:20:29,960 --> 01:20:30,960
그래서 다 들어가요

1196
01:20:31,000 --> 01:20:36,160
그래서 이거 포맷팅 이 방식을 쓰실
때는 그냥 %s만 알아도 다 넣을 수가 있다

1197
01:20:36,260 --> 01:20:37,940
라는 거 기억해 두시면 좋을 것 같 고

1198
01:20:38,040 --> 01:20:41,040
좀 특징적인 거 하나 보여드리면 %%는 뭐냐

1199
01:20:41,120 --> 01:20:45,320
이 문자 자체에 입력하는 경우 백 슬래시랑
거의 비슷한 개념이라고 보시면 되겠습니다

1200
01:20:45,520 --> 01:20:49,617
백 슬래시도 그냥 이렇게 입력하면
이런 거 같이 쓸 때가 있잖아요

1201
01:20:49,641 --> 01:20:53,980
그래서 백 슬래시 따옴표 이렇게
쓸 때는 그냥 따옴표만 나와 버리 죠

1202
01:20:54,020 --> 01:20:59,140
그래서 이렇게 표시할 때 백 슬래시 를 하나 더 써서
백 슬래시 따옴표 가 나오는 것처럼 %도 마찬가지입니다

1203
01:20:59,240 --> 01:21:04,480
이렇게 넣으려고 했을 때 그냥 이렇게 넣을
수도 있는데 %를 표시하고 싶을 수가 있어요

1204
01:21:05,820 --> 01:21:08,780
표시하고 싶을 때 이렇게 쓰면은 오류가 납니다

1205
01:21:08,880 --> 01:21:10,580
왜냐면 그냥 %가 들어갔으니까

1206
01:21:10,780 --> 01:21:15,720
그래서 % 두 개를 써줘야 이렇게
3% 애플 이렇게 표시가 되겠습니다

1207
01:21:15,980 --> 01:21:21,240
파이썬 3.6 이상부터 쓸 수 있는 방식이라 그거는
이제 하나씩 나 가면서 소개를 드리도록 하겠습니다

1208
01:21:21,460 --> 01:21:24,900
그래도 올드 스타일도 그냥 한번 봐
놓으면 좋으니까 한번 쭉 보도록 하겠습니다

1209
01:21:25,200 --> 01:21:28,400
그다음에 포맷 코드와 숫자 함께 활용하는 방법이 있습니다

1210
01:21:28,600 --> 01:21:32,180
책에 나오는 개념이니까 또 지적
허용심을 한번 충족을 해보도록 하겠습니다

1211
01:21:32,420 --> 01:21:35,637
정렬과 공백에서 %s에 숫자가 10이 들어갔어요

1212
01:21:35,661 --> 01:21:38,840
이렇게 한번 이게 어떤 기능을 하는지 보도록 하겠습니다

1213
01:21:39,020 --> 01:21:45,040
이것을 출력해보면 원래는 그냥 퍼센트의 10을
뺀다고 했을 때 10을 빼면은 이렇게 나오잖아요

1214
01:21:45,120 --> 01:21:48,240
그냥 하이� Ladder 숙 들어가는데
여기 굳이 10을 넣을 때가 있어요

1215
01:21:48,380 --> 01:21:51,040
그래서 10을 넣으면 무슨 의미가 되냐 면 이렇게 됩니다

1216
01:21:51,220 --> 01:21:59,020
그래서 이게 하이를 빼고 총 8칸의 띄어쓰기가 들어가고
하이까지 해서 총 10칸을 맞춰서 이렇게 텍스트가 출력이 됩니다

1217
01:21:59,220 --> 01:22:01,640
그래서 이게 어떤 개념이냐 하면 여기가 볼 수 있죠

1218
01:22:01,720 --> 01:22:03,400
전체 길이가 10으로

1219
01:22:03,480 --> 01:22:03,660
이렇게

1220
01:22:03,981 --> 01:22:08,720
이 사이에 들어간 숫자만큼 생기고 그리고
하이라는 글자는 이 뒤로 들어가게 됩니다

1221
01:22:08,900 --> 01:22:11,500
그러면 반대로 이 앞에 놓고 싶으면 어떻게 해야 되냐?

1222
01:22:11,540 --> 01:22:13,960
앞에 놓고 싶다면 얘는 마이너스를 쓰면 됩니다

1223
01:22:14,160 --> 01:22:18,436
그래서 한번 실습을 빠르게 해보면
이거를 출력해보면 이렇게 되죠

1224
01:22:18,460 --> 01:22:26,460
뒤에 j는 그냥 텍스트 이미 있는 거니까 여기는 그대로 살리고
마이너스 10s 이게 어떤 의미인지를 보면 마이너스 10s의 의미는 총 이렇게

1225
01:22:27,201 --> 01:22:34,480
10칸이 들어가는데 이 10칸 중에 하이라는 글자가
맨 왼쪽에 오고 나머지 8칸을 채우겠다라는 의미입니다

1226
01:22:34,580 --> 01:22:36,080
그래서 이거를 그럼 언제 쓰냐?

1227
01:22:36,120 --> 01:22:36,816
거의 안 씁니다

1228
01:22:36,840 --> 01:22:42,420
거의 안 쓰는 개념이긴 한데 그냥 지적
허용심을 충족을 시킬 수 있는 시간이었습니다

1229
01:22:42,580 --> 01:22:44,840
그래서 이거는 그냥 이런 게 있구나 하고 넘어가시면 됩니다

1230
01:22:45,020 --> 01:22:47,740
소수점 표현할... 이거는 그나마
소수점은 좀 쓸 일이 있습니다

1231
01:22:48,120 --> 01:22:49,620
소수점은 이렇게 쓸 수가 있습니다

1232
01:22:49,940 --> 01:22:53,980
소수점 표현할 때는 소수점 몇째
자리까지 표시하시오 이런 거 많죠

1233
01:22:54,060 --> 01:22:58,340
이 소수점이 쭉 점 넷째 자리까지
표현하고 싶어 라고 할 때가 좀 있죠

1234
01:22:58,460 --> 01:23:06,460
그럴 때는 이렇게 %f가 아까 플로트 표현한... 라는 거 잠깐 소개해
드렸는데 0.4를 붙이게 되면 소수점 넷째 자리까지 표시해라 라는 뜻입니다

1235
01:23:08,500 --> 01:23:11,060
그래서 이렇게 소수점 넷째 자리까지만 나오죠

1236
01:23:11,100 --> 01:23:15,540
그럼 얘를 3으로 바꾸면 셋째 자리까지
나오고 그리고 심지어 0을 빼도 됩니다

1237
01:23:15,760 --> 01:23:17,380
0을 빼면 똑같이 나오죠

1238
01:23:17,420 --> 01:23:19,160
그럼 여기에 이제 10을 넣으면 어떻게 되냐?

1239
01:23:19,220 --> 01:23:23,900
똑같이 10칸이 생기고 여기에 .3에서
소수점 세 자리가 남고 이렇게 됩니다

1240
01:23:24,300 --> 01:23:25,320
막 엄청 중요하지는 않아요

1241
01:23:25,380 --> 01:23:31,900
그냥 소수점 표현하는 것도 그때 찾아보면 되는 거라 외우실 필요는
없고 그냥 이런 게 있구나 정도로 이해하시고 넘어가시면 좋을 것 같습니다

1242
01:23:32,160 --> 01:23:33,000
숫자 바로 대입하기

1243
01:23:33,060 --> 01:23:38,480
포맷이 여러 방식이 있다고 말씀드렸는데 아까
퍼센트를 이용한 방법들을 쭉 소개해 드렸어요

1244
01:23:38,580 --> 01:23:42,160
근데 그거 말고도 .포맷이라는
방법으로도 넣을 수가 있습니다

1245
01:23:42,500 --> 01:23:44,260
.포맷을 한번 써보도록 하겠습니다

1246
01:23:44,380 --> 01:23:47,360
그래서 포맷팅 방법이 여러 가지
있는데 그 중에 하나만 아셔도 됩니다

1247
01:23:47,540 --> 01:23:49,900
그 중에 마지막 것만 아셔도 되는데 포맷은 뭐냐?

1248
01:23:49,940 --> 01:23:52,440
이 숫자를 여기 안에 넣는다의 의미입니다

1249
01:23:52,480 --> 01:23:53,060
거의 똑같죠?

1250
01:23:53,120 --> 01:23:57,640
그냥 퍼센트 쓰는 거랑 똑같은데 그냥
이렇게도 쓸 수 있다라는 거를 소개해 드렸습니다

1251
01:23:58,180 --> 01:24:02,136
문자열도 얘도 얘는 좋은 점이
순서를 표현한 거기 때문에 0이라는...

1252
01:24:02,160 --> 01:24:10,160
굳이 문자열, 숫자 이런 걸 구분할 필요 없이 그냥 여기 문자열을
들어가도 잘 포맷팅이 돼서 들어간 것을 확인할 수가 있습니다

1253
01:24:11,180 --> 01:24:15,500
그리고 두 개 이상의 값 넣기 이것도
빨리 해보면 이렇게 해볼 수가 있겠습니다

1254
01:24:16,040 --> 01:24:19,180
넘버, 데이 이렇게 포맷 뒤에 두 개가 들어갔어요

1255
01:24:19,280 --> 01:24:21,620
그러면 각각 순서에 맞춰서 들어갑니다

1256
01:24:21,760 --> 01:24:26,420
0번, 1번 이렇게 0번째가 여기로
들어가고 1번째가 이렇게 들어갑니다

1257
01:24:26,480 --> 01:24:28,680
이렇게 잘 들어가게 된 것을 볼 수가 있죠

1258
01:24:28,800 --> 01:24:30,537
여기서 순서를 바꿀 수도 있습니다

1259
01:24:30,561 --> 01:24:32,800
0, 1번, 0번으로 하면 어떻게 될까요?

1260
01:24:32,900 --> 01:24:36,136
그러면 얘는 0번, 1번 이런
순서이기 때문에 바꿔서 들어갑니다

1261
01:24:36,160 --> 01:24:37,760
그럼 10 대신에 3가 들어갔죠?

1262
01:24:37,840 --> 01:24:43,100
즉, 1번이라는 게 이거 인덱스라 0번,
1번인데 이 데이가 여기로 들어가 버립니다

1263
01:24:43,200 --> 01:24:46,180
그래서 이렇게 숫자를 인덱스에 맞게 써줘야 됩니다

1264
01:24:46,400 --> 01:24:48,280
그다음에 이름으로 넣을 수도 있습니다

1265
01:24:48,480 --> 01:24:50,940
이거 대신에 순서로 하는 게 좀 헷갈릴 수 있잖아요

1266
01:24:51,140 --> 01:24:58,315
그래서 순서로 안 하고 아예 이렇게 변수를 정해줘서
넘버는 10이라고 쓰고 콤마를 쓰고 데이는 3이라고

1267
01:24:58,339 --> 01:25:04,380
쓰면은 이제 순서가 0번인데 0번, 1번이긴 한데
굳이 이렇게 안 쓰고 변수 자체를 넣어줄 수도 있습니다

1268
01:25:04,480 --> 01:25:08,900
넘버나 데이를 넣으면 넘버는 넘버 안에
들어가고 데이는 데이 안에 들어가고 이렇게 되겠죠

1269
01:25:09,040 --> 01:25:10,560
실행해보면 이상대로 들어갔죠

1270
01:25:10,680 --> 01:25:12,320
그래서 이런 포맷 방법이 있습니다

1271
01:25:12,620 --> 01:25:14,060
그래서 혼용도 가능합니다

1272
01:25:14,500 --> 01:25:16,480
0번째가 이제 첫 번째 이거죠

1273
01:25:16,540 --> 01:25:17,756
여기 첫 번째 있는 거

1274
01:25:17,780 --> 01:25:20,000
두 번째 데이가 3이라고 정해줬죠

1275
01:25:20,080 --> 01:25:27,740
이렇게 그러면은 이제 찾아 들어갈 때 0번째가 이렇게 들어가고
데이가 데이 자가 이렇게 들어가서 이렇게 쓸 수가 있겠습니다

1276
01:25:28,040 --> 01:25:33,540
이게 파이썬이 또 여러 업데이트가 되고 방법이
추가되면서 다양한 게 생겼는데 이걸 다 알 필요는 없어요

1277
01:25:33,680 --> 01:25:35,240
하나만 쓸 줄 알면 쓸 수가 있으니까

1278
01:25:35,460 --> 01:25:38,480
그래서 그냥 이런 게 있구나 정도로
하고 넘어가면 좋을 것 같습니다

1279
01:25:38,760 --> 01:25:40,717
그런데 왼쪽 정렬, 오른쪽 정렬

1280
01:25:40,741 --> 01:25:42,980
또 빠르게 이것도 잘 안 쓰이는데 한번 보도록 하겠습니다

1281
01:25:43,260 --> 01:25:45,220
포맷팅 중에 이런 표현도 있어요

1282
01:25:46,400 --> 01:25:50,300
정렬이 어떤 개념이냐면 플러스
마이너스 했을 때랑 비슷합니다

1283
01:25:50,660 --> 01:25:56,217
이 꺽새를 이용해서 A3개를 하나씩
이렇게 해서 출력을 해보도록 하겠습니다

1284
01:25:56,241 --> 01:25:58,036
그러면 이렇게 나옵니다

1285
01:25:58,060 --> 01:25:59,200
하나씩 보도록 하겠습니다

1286
01:25:59,660 --> 01:26:00,860
이것은 무슨 뜻이냐

1287
01:26:00,900 --> 01:26:04,060
여기 숫자 포맷을 해서 이렇게 넣을 건데 0번째잖아요

1288
01:26:04,900 --> 01:26:06,400
2개면 1번째도 있겠죠

1289
01:26:06,560 --> 01:26:10,540
그런데 0번째니까 들어가는데 이
콜론 뒤에 부등호가 있고 10이 있어요

1290
01:26:10,740 --> 01:26:12,876
그럼 각각 무슨 뜻이냐면 총 10글자

1291
01:26:12,900 --> 01:26:14,540
얘도 10칸을 만드는 거예요

1292
01:26:14,620 --> 01:26:16,940
얘는 왼쪽 정렬을 하고 싶다 라는 뜻입니다

1293
01:26:17,120 --> 01:26:21,120
그래서 왼쪽 정렬을 하고 총
10글자 8칸을 만들겠다 라는 뜻이죠

1294
01:26:21,260 --> 01:26:21,900
이것은 뭐냐

1295
01:26:21,960 --> 01:26:23,080
이 정렬만 바뀌었죠

1296
01:26:23,160 --> 01:26:26,197
이렇게 되면 오른쪽 정렬을 하고 8칸을 만드는 거예요

1297
01:26:26,221 --> 01:26:29,080
이거 가운데 이거는 뭐냐

1298
01:26:29,140 --> 01:26:30,660
이게 캐럿 문자라고 해요

1299
01:26:30,740 --> 01:26:31,540
이 웃음 표시 있죠

1300
01:26:31,660 --> 01:26:35,840
쓰는 이 문자가 캐럿 표시인데
이거를 쓰면 가운데에 위치하게 됩니다

1301
01:26:36,100 --> 01:26:38,116
10칸을 만들고 이 0은 이거죠

1302
01:26:38,140 --> 01:26:39,300
0번째니까 이렇게 들어오고

1303
01:26:39,380 --> 01:26:44,660
이렇게 표현을 할 수가 있는데 이거를 현실에서
개발할 때 쓰냐 라고 하면 많이 쓰이지는 않습니다

1304
01:26:44,780 --> 01:26:46,820
이런 게 있다 정도로 알아두시면 좋을 것 같고요

1305
01:26:46,900 --> 01:26:48,000
그다음에 공백 채우기

1306
01:26:48,040 --> 01:26:49,820
거의 똑같은데 등호가 들어갔어요

1307
01:26:49,880 --> 01:26:52,880
그럼 등호는 뭐냐면 이 등호 문자를 넣겠다라는 의미입니다

1308
01:26:52,960 --> 01:26:56,177
이렇게 출력을 해보면 총 10글자인데
캐럿 표시가 가운데에 있습니다

1309
01:26:56,201 --> 01:26:56,680
10칸을 가운데에 넣는다죠

1310
01:26:56,740 --> 01:26:59,980
10칸을 가운데에 넣고 나머지는
등호로 채우겠다라는 뜻입니다

1311
01:27:00,080 --> 01:27:03,320
는 대신에 별표를 쓰면 이렇게 별표로 바꿀 수도 있겠죠

1312
01:27:03,660 --> 01:27:09,480
CLI 프로그램이라고 커맨드 라인 이런 데서
출력하는 예전의 게임은 다 이런 식으로 돌아갔어요

1313
01:27:09,580 --> 01:27:12,180
그러면 개발을 이런 식으로 개발해야 되잖아요

1314
01:27:12,280 --> 01:27:13,780
요즘에는 이렇게 잘 안 하죠

1315
01:27:13,820 --> 01:27:18,040
보통 웹 개발을 하거나 클라이언트를
두고 스마트폰이랑 하거나 이런 식으로 하지

1316
01:27:18,180 --> 01:27:20,500
이 감성이 문법에 남아있는 겁니다

1317
01:27:20,820 --> 01:27:23,757
그래서 이걸 개발하고 싶다고 하면 이런 게 종종 쓰이겠죠

1318
01:27:23,781 --> 01:27:26,680
그게 아닌 이상은 이런 게 있구나
정도로 하고 넘어가시면 됩니다

1319
01:27:26,840 --> 01:27:29,280
그 다음에 소수점 많이 쓰이니까 빠르게 보도록 하겠습니다

1320
01:27:29,480 --> 01:27:30,480
아까의 연장선이죠

1321
01:27:30,580 --> 01:27:34,720
이거 0번째는 이거를 의미하고
0.4 이거는 포맷팅이랑 똑같죠

1322
01:27:34,760 --> 01:27:39,320
실행을 해보면 이렇게 소수점 넷째
자리까지 표시하겠다는 의미를 담고 있습니다

1323
01:27:39,440 --> 01:27:40,440
그래서 0은 지워도 됩니다

1324
01:27:40,540 --> 01:27:47,900
이것도 마찬가지인데 항상 좀 파이썬에는 백 슬래시
혹은 퍼센트 아니면 점 포맷 방식에서는 중괄호라고 하죠

1325
01:27:47,940 --> 01:27:49,420
중괄호가 들어가는 경우가 있어요

1326
01:27:49,540 --> 01:27:51,597
중괄호를 표현하고 싶을 때는 두 개를 써줍니다

1327
01:27:51,621 --> 01:27:59,621
이 포맷을 쓰고 싶은데 중괄호를 하나만 쓰면은 특수 기호로 인식하니까
이게 출력이 잘 안 돼서 두 개를 써야 중괄호 하나가 나온다라는 개념

1328
01:28:00,201 --> 01:28:03,300
이런 거는 아까 뭐 백 슬래시니
뭐 이런 거 할 때 많이 봤었죠

1329
01:28:03,340 --> 01:28:06,380
퍼센트도 두 개를 써야 됐고
이런 개념이 파이썬에는 있습니다

1330
01:28:06,600 --> 01:28:10,520
이게 특수 기호로 쓰일 때는 두 개를
써줘야 된다라고 이해하시면 좋을 것 같습니다

1331
01:28:10,680 --> 01:28:12,640
그 다음에 이제 이것만 배우셔도 됩니다

1332
01:28:13,200 --> 01:28:15,140
F문자열 포맷팅 이게 제일 최신 겁니다

1333
01:28:15,360 --> 01:28:23,360
파이썬 3.6 버전부터 나온 그 문자열 포맷팅이라 웬만하면은 요즘
파이썬 3.6 이상으로 개발하기 때문에 이것만 기억하셔도 포맷팅은 끝입니다

1334
01:28:24,380 --> 01:28:27,340
어떻게 하면 그 포맷을 효율적으로 쓸 수 있을까?

1335
01:28:27,380 --> 01:28:32,800
F를 붙이면 되겠다라고 해서 포맷의 약자인
f를 붙이고 그 다음에 스트링을 써줍니다

1336
01:28:32,900 --> 01:28:37,000
여기는 이제 중괄호를 써주면
안에 변수를 넣을 수가 있게 됐어요

1337
01:28:37,160 --> 01:28:37,900
제일 깔끔하죠?

1338
01:28:37,960 --> 01:28:38,760
지금까지 본 거 중에?

1339
01:28:38,840 --> 01:28:45,154
이렇게 f라는 포맷팅을 쓴다라고 알려주고
그 다음에 텍스트를 써줬을 때 중괄호 안쪽에

1340
01:28:45,178 --> 01:28:50,877
이렇게 변수를 넣을 수 있게 해주면 변수들을
쏙쏙 넣을 수 있어서 포맷팅이 편리하겠죠

1341
01:28:50,901 --> 01:28:56,660
그래서 이거를 출력해보면 이렇게 나의 이름은
name 홍길동이 들어갔고 age가 여기로 들어갔습니다

1342
01:28:56,740 --> 01:28:58,920
그래서 이게 가장 깔끔한 최신 문법

1343
01:28:59,000 --> 01:29:00,500
그래서 이것만 배우시면 됩니다

1344
01:29:00,740 --> 01:29:05,120
그래서 이전 거는 어디 가서 아는 척하거나
옛날 버전을 보거나 할 때 쓰시면 됩니다

1345
01:29:05,420 --> 01:29:11,160
그러면 이것 또한 근데 포맷팅이 이제 진화를
해왔지만 기존에 썼던 거랑 문법은 거의 비슷해요

1346
01:29:11,280 --> 01:29:18,220
이거는 더 직관적인 게 이런 거 변수가 있으면은
이 중괄호 안쪽에는 파이썬 연산을 할 수가 있어요

1347
01:29:18,340 --> 01:29:22,520
Age가 여기 30이 들어가면은 30 플러스
1을 여기서 연산을 할 수가 있습니다

1348
01:29:22,620 --> 01:29:26,840
나는 내년이면 31살이 된다라고 쓸
수가 있고 심지어 뭐 곱하기도 되겠죠

1349
01:29:26,940 --> 01:29:27,920
네 60살이 된다

1350
01:29:27,960 --> 01:29:31,160
계산을 할 수 있는 파이썬
문법을 이 안에 넣을 수 있습니다

1351
01:29:31,480 --> 01:29:36,320
F만 넣으면 중괄호 안쪽에 변수에 뭔가
처리를 할 수 있는 거를 다 넣을 수가 있습니다

1352
01:29:36,640 --> 01:29:38,260
그래서 이게 제일 직관적이고 쉽죠

1353
01:29:38,300 --> 01:29:40,040
그래서 이걸로 기억해 주시면 좋을 것 같습니다

1354
01:29:40,340 --> 01:29:43,780
아 얘도 뭐 정렬이 있긴 한데
앞에 거랑 거의 중복이 있긴 합니다

1355
01:29:44,180 --> 01:29:47,300
특수한 기호를 쓸 텐데 이제 이거 어떤 건지 아시겠나요?

1356
01:29:47,360 --> 01:29:49,700
이게 왼쪽 정렬 총 10글자 이렇게 쓰는 거죠

1357
01:29:50,120 --> 01:29:56,460
출력을 해보면 하의가 왼쪽 정렬이 됐고 그
다음에 총 10글자 안쪽에 8개의 공백이 생기는 거죠

1358
01:29:56,560 --> 01:29:59,600
거의 쓸 일이 많이 없는데 이런 게
있다라고 알아두시면 좋을 것 같습니다

1359
01:29:59,780 --> 01:30:01,260
그럼 오른쪽 정렬 뭐였을까요?

1360
01:30:01,360 --> 01:30:02,080
이렇게 하면 되겠죠

1361
01:30:02,200 --> 01:30:04,380
가운데 정렬 캐런 문자 웃음 표시 있죠

1362
01:30:04,500 --> 01:30:06,136
이걸 넣으면 가운데로 간다

1363
01:30:06,160 --> 01:30:08,500
문법은 똑같지만 이게 제일 간단하죠

1364
01:30:08,620 --> 01:30:12,600
F로 쓰는 게 제일 간단하기 때문에 이거
하나로 기억해 주시면 좋을 것 같습니다

1365
01:30:13,000 --> 01:30:17,524
이것도 마찬가지 등호 쓰는 거 이거는
소개 드린 것처럼 그 cli 프로그램이 할

1366
01:30:17,548 --> 01:30:21,520
때 쓰이는 거지 요즘에 잘 안 쓰이기
때문에 보시고 넘어가도록 알려드리겠습니다

1367
01:30:21,580 --> 01:30:22,800
그리고 이것도 다 똑같습니다

1368
01:30:22,900 --> 01:30:27,780
소수점 이건 많이 쓰이니까 한번 소개를
드리면 얘는 0.4가 이거는 이제 뭔지 아시겠죠

1369
01:30:27,940 --> 01:30:32,460
소수점 넷째 자리까지라는 표시기
때문에 이렇게 넷째 자리까지 표시가 됩니다

1370
01:30:32,820 --> 01:30:36,000
이것도 마찬가지로 중괄호는 이런 표현식에 쓰이게 되잖아요

1371
01:30:36,140 --> 01:30:40,440
그래서 표현식이 아니라 중괄호 쓰고 싶다면
두 개를 쓰면 된다라고 말씀드릴 수가 있겠습니다

1372
01:30:40,740 --> 01:30:45,000
그러면 여기까지 해서 이제 문자열
포매팅을 총 세 가지 방법으로 알아봤습니다

1373
01:30:45,140 --> 01:30:47,500
그래서 이런 거를 외우실 필요는 없어요

1374
01:30:47,620 --> 01:30:49,417
머리 용량을 좀 낭비하는 일입니다

1375
01:30:49,441 --> 01:30:50,620
이걸 어떻게 하면 되냐

1376
01:30:50,680 --> 01:30:54,056
첫 시간에 말씀드린 것처럼
요즘에는 Chet GPT가 어마어마합니다

1377
01:30:54,080 --> 01:30:55,080
3.5도 될 거예요

1378
01:30:55,120 --> 01:30:57,080
이런 거 한글로 물어봐도 아마 될 겁니다

1379
01:30:57,480 --> 01:31:01,720
파이썬 코드로 코드를 작성해
주라고 하면 작성을 해 줄 겁니다

1380
01:31:01,980 --> 01:31:03,640
이렇게 하면 된다고 잘 나오죠

1381
01:31:03,760 --> 01:31:08,780
이렇게 Chet GPT를 쓰면 돼서 사실 이
문법을 아 외워야지라는 거는 머리 낭비입니다

1382
01:31:08,960 --> 01:31:13,720
쌓여가지고 출력을 해보면 문법을
달달 외워야지는 진짜 머리 낭비입니다

1383
01:31:13,840 --> 01:31:16,080
이렇게 쓸 수 있다라는 거 좀 안내를 드렸고요

1384
01:31:16,320 --> 01:31:17,980
그 다음에 문자열 관련 함수들

1385
01:31:18,060 --> 01:31:18,877
함수란 뭐냐

1386
01:31:18,901 --> 01:31:26,280
점하고 뭔가를 쓰는 거를 이게 메소드라고 부르기도
하는데 함수라고 좀 간략하게 이해를 해보시면 좋을 것 같습니다

1387
01:31:26,360 --> 01:31:30,020
그래서 문자열이 있는데 그 문자열에
쓸 수 있는 여러 기술들이 있어요

1388
01:31:30,180 --> 01:31:32,400
그래서 그 기술을 하나씩 배워보도록 하겠습니다

1389
01:31:32,660 --> 01:31:36,060
그러면 일단은 문자열 갯수 세기 카운트를 보도록 하겠습니다

1390
01:31:36,360 --> 01:31:38,540
이 문자열에서 이것도 다 외울 필요는 없습니다

1391
01:31:38,700 --> 01:31:46,260
그냥 이런 게 있다라는 거를 이해하시면 좋을 것 같은데
허비에서 카운트 B라고 하면 B의 갯수가 몇 개지라고 셀 수가 있겠죠

1392
01:31:46,400 --> 01:31:48,017
그럼 허비의 B는 두 개죠

1393
01:31:48,041 --> 01:31:50,360
그래서 이렇게 E라는 값이 나오게 됩니다

1394
01:31:50,480 --> 01:31:52,740
그래서 이런 거를 메소드라고 부르는데요

1395
01:31:52,920 --> 01:31:57,720
함수가 좀 더 큰 개념이고 그래서 메소드라고
부르는데 이런 거를 문자열에 쓸 수 있는 것들이 있습니다

1396
01:31:58,240 --> 01:31:59,820
엑셀에서 함수랑 비슷합니다

1397
01:32:00,020 --> 01:32:02,460
그래서 문자에서 쓸 수 있는 이런 개념들이 있습니다

1398
01:32:02,680 --> 01:32:06,340
그래서 위치 알려주기 뭐 이런 것도
있는데 파인드 이런 걸 써볼 수도 있겠죠

1399
01:32:06,480 --> 01:32:09,800
이렇게 하면 B를 찾아서 B의 인덱스를 돌려줍니다

1400
01:32:09,960 --> 01:32:11,360
E가 나왔는데 왜 E가 나왔냐

1401
01:32:11,440 --> 01:32:15,540
B를 찾으면 여기 인덱스가 0번 1번 B가 2번이죠

1402
01:32:15,640 --> 01:32:17,377
그래서 인덱스 2번이 나온 겁니다

1403
01:32:17,401 --> 01:32:20,840
이렇게 인덱스를 찾아두는 게 있고,
그러면 없는 값을 넣으면 어떻게 되냐?

1404
01:32:20,880 --> 01:32:21,960
X 이런 걸 넣어볼게요

1405
01:32:22,060 --> 01:32:23,320
호비에 x가 없잖아요

1406
01:32:23,440 --> 01:32:24,020
그러면 어떻게 되냐?

1407
01:32:24,120 --> 01:32:25,120
마이너스 1이 나옵니다

1408
01:32:25,180 --> 01:32:29,960
Find를 했는데 없는 걸 찾아달라고 하면 마이너스
1이 나온다 라고 이해하시면 좋을 것 같습니다

1409
01:32:30,240 --> 01:32:34,540
그 다음에 그 find가 있다면 이거랑
비슷한 index란 함수가 있습니다

1410
01:32:34,760 --> 01:32:42,340
둘 중에 하나만 알아도 되긴 한데 얘는 좀 결과가 좀 다른데
index를 쓰면 얘도 마찬가지로 b를 쓰면 이렇게 2가 나오는데요

1411
01:32:42,500 --> 01:32:45,457
근데 여기에 없는 문자를 넣으면 오류가 납니다

1412
01:32:45,481 --> 01:32:49,880
아까 find는 마이너스 1을
뱉어줬는데 index는 아예 오류가 납니다

1413
01:32:50,020 --> 01:32:51,220
그래서 이런 차이가 있습니다

1414
01:32:51,480 --> 01:32:57,540
그래서 이런 메소드들, 위치 알려주는 거, 문자 개수
세주는 거, 또 뭐 삽입하는 거 이런 것도 해보도록 하겠습니다

1415
01:32:57,780 --> 01:32:58,920
이런 메소드들이 좀 있습니다

1416
01:32:59,280 --> 01:33:07,280
조이는 뭐냐면 여기 뒤에 문자열이 들어가 있다면 이
문자열들을 다 나눠서 이걸로 삽입을 가운데 다 하겠다라는 뜻입니다

1417
01:33:07,680 --> 01:33:12,700
그래서 실행을 해서 먼저 결과부터
보면 이렇게 a, b, c, d 이렇게 됩니다

1418
01:33:12,880 --> 01:33:15,077
그럼 여기에 띄어쓰기 하나를 추가하면 어떻게 될까요?

1419
01:33:15,101 --> 01:33:21,400
이렇게 a, 띄어쓰기가 다 추가가
돼서 이렇게 a, b, b, c 이렇게 됩니다

1420
01:33:21,580 --> 01:33:23,100
여기에 뭐 이런 것도 되겠죠

1421
01:33:23,220 --> 01:33:29,100
To the 이런 거를 넣으면 a to the b, b to the
c, c to the d 이런 식으로도 할 수가 있습니다

1422
01:33:29,400 --> 01:33:35,900
즉 여기 나온 거를 기준으로 이 뒤에 있는
문자열을 다 잘라서 사이사이에 넣겠다라는 뜻입니다

1423
01:33:36,340 --> 01:33:37,920
이렇게 이해하시면 좋을 것 같습니다

1424
01:33:38,340 --> 01:33:45,080
이거는 이제 리스트를 배우면 또 뒤에 배울 개념인데
미리 좀 보자면 문자열도 쓰지만 이렇게 리스트도 쓰죠

1425
01:34:11,160 --> 01:34:13,200
또 소문자 대문자 바꾸기

1426
01:34:13,240 --> 01:34:14,820
이런 거 가끔 쓸 일이 있겠죠

1427
01:34:15,100 --> 01:34:18,500
그래서 이런 게 있구나라고 좀
봐두시면 upper라는 함수가 있습니다

1428
01:34:18,840 --> 01:34:24,760
문자열이 있고 여기에 upper라는 함수를 적용하게
되면 high라는 게 이렇게 대문자로 바뀌게 됩니다

1429
01:34:24,940 --> 01:34:32,520
그러면 반대로 high하고 대문자가 써져 있는데 lower라는 함수를
쓰게 되면 이제는 그 반대로 대문자를 소문자로 바꿔주게 됩니다

1430
01:34:32,640 --> 01:34:33,700
섞여 있으면 어떻게 되냐

1431
01:34:33,740 --> 01:34:35,400
이거를 다 소문자로 바꿔줍니다

1432
01:34:35,540 --> 01:34:39,460
이렇게 주는 게 lower,
upper라는 함수의 개념입니다

1433
01:34:39,720 --> 01:34:40,960
공백 지우는 게 있습니다

1434
01:34:41,300 --> 01:34:45,660
공백 지우기, 왼쪽 공백 지우기,
오른쪽 공백 지우기, 양쪽 공백 지우기

1435
01:34:45,700 --> 01:34:47,260
이것을 하나씩 해보도록 하겠습니다

1436
01:34:47,460 --> 01:34:48,660
이것도 직관적입니다

1437
01:34:48,780 --> 01:34:49,100
직관적입니다

1438
01:34:49,240 --> 01:34:51,580
이 a라는 게 있는데 공백이 들어가 있어요

1439
01:34:51,720 --> 01:34:53,760
그럼 공백을 제거하고 싶을 때가 있을 수 있겠죠

1440
01:34:53,940 --> 01:34:55,140
그래서 lstrip은 뭐냐

1441
01:34:55,180 --> 01:34:58,820
실행해보면 왼쪽 공백을 제거한 상태로 출력을 합니다

1442
01:34:59,100 --> 01:35:01,020
즉 왼쪽 공백이 없어지고 오른쪽은 남아 있어요

1443
01:35:01,440 --> 01:35:02,260
Rstrip은 뭐냐.

1444
01:35:02,320 --> 01:35:03,320
Right의 약자겠죠.

1445
01:35:03,400 --> 01:35:04,120
L은 left고

1446
01:35:04,220 --> 01:35:09,280
그래서 이렇게 하면 오른쪽 공백이 없어지고
왼쪽은 남아 있는 이런 상태가 나오게 됩니다

1447
01:35:09,540 --> 01:35:10,620
그냥 strip도 있습니다

1448
01:35:11,100 --> 01:35:12,037
양쪽을 없앤다

1449
01:35:12,061 --> 01:35:15,300
그래서 양쪽 공백을 없애서 하이만 나오게 됩니다

1450
01:35:15,440 --> 01:35:18,000
그래서 이렇게 strip하는 방법도 알아봤습니다

1451
01:35:18,320 --> 01:35:19,740
공백의 수는 상관없습니다

1452
01:35:19,860 --> 01:35:21,680
띄어쓰기를 많이 한 다음에도 다 없어집니다

1453
01:35:21,760 --> 01:35:24,420
또 많이 쓰이는 게 replace 이런 것도 많이 쓰이죠

1454
01:35:24,740 --> 01:35:28,520
문자열에서 이런 걸 할 일이 많기
때문에 파이썬에서 이런 기능을 만든 겁니다

1455
01:35:28,860 --> 01:35:30,380
여러분도 그런 거 하실 때 있죠

1456
01:35:30,540 --> 01:35:32,020
막 찾아서 바꾸기 이런 거

1457
01:35:32,060 --> 01:35:34,120
워드나 한글에서 하신 적 있으신가요?

1458
01:35:34,180 --> 01:35:35,560
심지어 이 vs코드에서도 됩니다.

1459
01:35:35,960 --> 01:35:41,240
Vs코드에서도 ctrl-f 하면 이제 찾기가
되는데 이거 파이썬 안 쓰고도 할 수가 있어요

1460
01:35:41,380 --> 01:35:44,720
예를 들어 life is too short에서
life를 reg으로 바꾸고 싶다

1461
01:35:44,760 --> 01:35:48,916
라고 하면 vs코드에서도 이렇게
life를 replace reg로 바꾼다

1462
01:35:48,940 --> 01:35:49,860
이런 거 많이 쓰죠

1463
01:35:49,940 --> 01:35:52,140
그래서 바꾸기 누르면 이렇게 바뀌는 거

1464
01:35:52,220 --> 01:35:55,320
이거를 이제 파이썬 문법으로 구현을 해놓은 겁니다

1465
01:35:55,500 --> 01:36:02,390
문자를 불러와서 .replace라는 메소드를
통해서 life를 yourreg라고 바꾸면 이거를 출력해

1466
01:36:02,414 --> 01:36:07,560
봤을 때 life 대신에 yourreg가
들어가서 yourreg is too short가 되겠죠

1467
01:36:07,720 --> 01:36:10,600
그 ctrl-f의 그 기능을 이제 파이썬 안에 포함했다

1468
01:36:10,700 --> 01:36:11,757
라고 보시면 되겠습니다

1469
01:36:11,781 --> 01:36:13,440
Replace까지 해봤고요

1470
01:36:13,500 --> 01:36:15,180
그다음에 문자열 나누기

1471
01:36:15,520 --> 01:36:17,340
나누기도 종종 많이 쓰입니다

1472
01:36:17,560 --> 01:36:23,940
문자열 나누기는 splits로 쓸 수 있는데
splits은 이렇게 쪼개는 거의 의미인데요

1473
01:36:24,160 --> 01:36:28,480
이거를 실행을 해보면 life is too
short이 여기 list의 형태로 바뀌어요.

1474
01:36:28,560 --> 01:36:36,200
Iist는 아직 안 배웠기 때문에 간략하게만 소개해 드리면 그냥
이런 어떤 변수들의 모음이라고 생각하시면 편할 것 같습니다

1475
01:36:36,440 --> 01:36:40,680
그래서 life is too short
이렇게 각각 다 쪼개졌죠

1476
01:36:40,740 --> 01:36:41,737
그래서 이걸 쪼개는 게 아니라

1477
01:36:41,761 --> 01:36:45,580
쪼개는 함수가 split이라고 쓰면
이렇게 쪼개진 채로 리스트가 나온다

1478
01:36:45,620 --> 01:36:47,360
라고 이해하시면 좋을 것 같습니다

1479
01:36:47,500 --> 01:36:48,320
다른 경우도 있어요

1480
01:36:48,440 --> 01:36:51,060
Split을 쓰되 이렇게 돼 있는 경우도 있습니다.

1481
01:36:51,740 --> 01:36:54,980
Abcd가 있는데 이 콜론으로 다 연결이 돼 있어요

1482
01:36:55,140 --> 01:36:58,820
그러면 이거를 실행해 보면 그냥 통째로 나옵니다

1483
01:36:58,960 --> 01:37:03,480
즉 이 split의 기본 값이 띄워쓰기를 기준으로 나눕니다

1484
01:37:03,960 --> 01:37:05,620
근데 얘는 띄워쓰기가 안 돼 있죠

1485
01:37:06,040 --> 01:37:10,077
그러면 이 따옴표 기준으로
abcd를 나오려면 어떻게 해야 되냐

1486
01:37:10,101 --> 01:37:18,101
이렇게 딱딱 눌러서 콜론을 넣으면 이렇게 콜론을 기준으로
나눠서 이제는 abcd가 잘 쪼개진 것을 확인할 수가 있죠

1487
01:37:19,720 --> 01:37:22,240
그래서 이렇게도 나눌 수가 있겠습니다

1488
01:37:22,940 --> 01:37:25,340
이렇게 문자열 나누기까지도 해봤습니다

1489
01:37:25,840 --> 01:37:32,300
이거는 또 immutable 이런 거에 대한 내용이라
이거는 또 추후에 그걸 배우면 해보도록 하겠습니다

1490
01:37:32,860 --> 01:37:36,080
이렇게까지 해서 이제 문자열 자료형을 끝냈습니다

1491
01:37:36,200 --> 01:37:40,000
이런 함수들의 사용법을 알고 있다면 마치 뭔가...

1492
01:37:40,100 --> 01:37:47,720
마법 스킬들을 여러 개 보유한 것 같이... 예를 들어
엄청난 텍스트가 있는데 여기서 뭐 잘못된 단어가 있어요

1493
01:37:47,880 --> 01:37:52,970
뭐... chat-gpt인데 chat-gtp라고
들어갔는데 아 이거 싹 다 바꾸고

1494
01:37:52,994 --> 01:37:57,380
싶어하면 replace 써서 gtp를
gpt로 바꾼다 라고 하면 싹 바뀌잖아요

1495
01:37:57,580 --> 01:38:00,380
그래서 그런 마법을 부릴 수 있는 게 이런 함수들입니다

1496
01:38:00,520 --> 01:38:06,360
그래서 이런 함수들을 잘 쓸 수 있으면 어떤
자료에서 원하는 형태로 변환하기가 되게 좋겠죠

1497
01:38:06,580 --> 01:38:06,900
네

1498
01:38:06,980 --> 01:38:10,076
그래서 열심히 이제 이거 배웠으니까 다시 또 복습하겠습니다

1499
01:38:10,100 --> 01:38:18,100
이렇게 해서 문자열에 대해서 한번 전체적으로 쓸 수
있는 함수들, 포매팅, 만드는 방법 이런 거를 배워봤습니다

1500
01:38:19,440 --> 01:38:22,220
그 다음에 이제 리스트를 한번 나가보도록 하겠습니다

1501
01:38:22,600 --> 01:38:28,580
리스트가 거의 문자열과 크게 다르지
않은데 어떤 개념인지 소개를 드려보겠습니다

1502
01:38:29,260 --> 01:38:31,160
리스트는 어떤 자료형이냐

1503
01:38:31,240 --> 01:38:36,497
리스트라고 하면 해야 할 일 리스트,
해야 할 일 목록 약간 이런 개념이잖아요

1504
01:38:36,521 --> 01:38:38,460
그래서 그런 개념이라고 보시면 됩니다

1505
01:38:38,860 --> 01:38:43,160
어떤 거냐면 변수를 여러 개 놓은
개념이라고 볼 수가 있겠는데요

1506
01:38:43,300 --> 01:38:47,440
변수, 아까 a라는 상자가 있으면 여기
3을 담는다 이런 걸 말씀드렸잖아요

1507
01:38:47,580 --> 01:38:53,300
이거를 이렇게 복제를 해서 변수를 a,
b, c, d 이렇게 관리하려면 너무 많잖아요

1508
01:38:53,540 --> 01:39:01,540
그래서 이런 여러 가지 리스트가 있을, 여러 가지 변수에 담을
값들이 있을 때 그걸 각각 변수에 담는 게 아니라 각각 a는 1, b는 2,

1509
01:39:02,620 --> 01:39:10,620
c는 3 이렇게 나누느니 그냥 이거를 하나의 변수에, 1, 2, 3을
담고 이거 전체를 a라는 변수로 부르겠다라고 할 수도 있겠죠

1510
01:39:12,760 --> 01:39:19,580
이렇게 되면 이제 a라는 변수에 서랍에 1번,
서랍에 2번, 서랍에 3번이 각각 담긴 형태가 되겠죠

1511
01:39:19,720 --> 01:39:23,420
그래서 이게 리스트의 개념이라고
이해하시면 좋을 것 같습니다

1512
01:39:23,640 --> 01:39:24,680
그래서 이게 리스트입니다

1513
01:39:24,800 --> 01:39:27,960
그래서 리스트는 서랍장이다
라고 기억하시면 좋을 것 같습니다

1514
01:39:28,580 --> 01:39:31,020
그럼 변수 하나에 여러 개의 값을 각각 담을 수 있겠죠

1515
01:39:31,160 --> 01:39:33,160
그래서 어떻게 쓰는지 보도록 하겠습니다

1516
01:39:33,440 --> 01:39:35,577
리스트 자료형 이제 2-3으로 넘어왔습니다

1517
01:39:35,601 --> 01:39:38,340
리스트로 넘어가서 하나씩 실습을 해 보도록 하겠습니다

1518
01:39:38,480 --> 01:39:42,620
그러면 2-3, 이제 list. Py를
여기서 실습을 해 보도록 하겠습니다

1519
01:39:42,780 --> 01:39:44,300
리스트는 어떻게 만들고 사용할까?

1520
01:39:44,360 --> 01:39:45,540
이렇게 쓰시면 됩니다

1521
01:39:45,760 --> 01:39:53,760
문자열 할 때도 나와서 익숙하실 수 있는데 대괄호와 대괄호 사이에
서랍장에 들어갈 요소들을 콤마로 구분해서 넣어 주시면 되겠습니다

1522
01:39:56,160 --> 01:39:59,380
이렇게 넣어 주시면 odd라는
거에 type을 찍어 볼 수가 있었죠.

1523
01:39:59,440 --> 01:40:04,897
Type을 찍어 보면 이렇게 리스트
자료형이다 라고 이 자료형의 이름이 나옵니다

1524
01:40:04,921 --> 01:40:12,921
그래서 type을 찍어 보면 리스트 형식이고 대괄호와 대괄호
사이에 코마 로 구분해서 넣는다 라고 이해할 수가 있겠습니다

1525
01:40:13,440 --> 01:40:17,960
그래서 이게 근데 다른 언어를
배우신 분들은 약간 신기할 수 있어요

1526
01:40:18,100 --> 01:40:20,100
왜냐면 요런게 가능합니다

1527
01:40:20,640 --> 01:40:27,520
대표적으로 이거 하나만 보면 그 뭐 자바하나
아니면 다른 언어를 배우신 분들은 1, 2가 숫자잖아요

1528
01:40:27,700 --> 01:40:29,700
Type을 찍어 보면 숫자, 숫자죠

1529
01:40:29,800 --> 01:40:31,700
근데 얘는 문자, 문자에요

1530
01:40:31,800 --> 01:40:37,220
근데 보통 이 리스트 안에 같은 진짜 색이
나오잖아요 자료 형태만 담을 수 있는 언어들이 많아요

1531
01:40:37,260 --> 01:40:40,360
근데 파이썬은 그런거 필요없이 다 담을 수가 있습니다

1532
01:40:40,860 --> 01:40:45,180
문자도 담고 숫자도 담고 할 수
있는게 파이썬의 리스트입니다

1533
01:40:45,360 --> 01:40:47,520
근데 속도 면에서는 좀 비효율적이긴 합니다

1534
01:40:47,680 --> 01:40:53,780
메모리나 이런거 측면에서는 좀 많이 차지하긴 하는데
대신에 이렇게 관대하게 여러 자료형들을 한번에 담을 수가 있죠

1535
01:40:53,900 --> 01:40:56,020
그리고 리스트 안에 또 리스트를 넣을 수가 있어요

1536
01:40:56,140 --> 01:41:02,380
리스트 안에 또 리스트가 넣는다라는 건 어떤거냐면
여기 얘도 마찬가지로 스트링 처럼 인덱스가 있는데요

1537
01:41:02,500 --> 01:41:04,920
이걸 배우면서 하나씩 실습을 해보겠습니다

1538
01:41:05,200 --> 01:41:08,660
그러면 인덱싱부터 보면 리스트랑 스트링이랑 거의 비슷해요

1539
01:41:08,740 --> 01:41:09,000
느낌이

1540
01:41:09,200 --> 01:41:14,220
그래서 문법도 거의 비슷한데 a에 0번째
인덱싱을 해서 하나 뽑으면은 어떻게 되냐.

1541
01:41:14,280 --> 01:41:15,940
A에 0번째는 요거죠

1542
01:41:16,000 --> 01:41:21,260
그래서 요거를 출력해보면 0번째 인덱스는
1번이 나오고 그럼 a에 1을 넣으면 뭐가 나올까요?

1543
01:41:21,340 --> 01:41:22,940
이 2가 나오게 되겠죠

1544
01:41:23,060 --> 01:41:25,940
012라는 인덱스를 가지고 있습니다

1545
01:41:26,120 --> 01:41:27,357
거의 스트링이랑 똑같아요

1546
01:41:27,381 --> 01:41:34,080
그래서 이렇게 진행하실 수 있고 a에 1번 더하기
a에 2 이렇게 하면은 이게 결과가 어떻게 될까요?

1547
01:41:34,160 --> 01:41:35,460
2가 요거죠

1548
01:41:35,560 --> 01:41:36,620
1번 인덱스니까

1549
01:41:36,700 --> 01:41:37,440
012니까

1550
01:41:37,560 --> 01:41:38,320
012

1551
01:41:38,520 --> 01:41:39,980
그럼 3이 여기죠

1552
01:41:40,100 --> 01:41:41,500
그럼 더하면 5가 되죠

1553
01:41:41,560 --> 01:41:44,780
그래서 실제로 출력해보면 5가
나오는 걸 확인할 수 있습니다

1554
01:41:45,000 --> 01:41:47,340
많이들 실수하는 오답을 잘 내주셨는데

1555
01:41:47,540 --> 01:41:51,220
이 3을 하면은 얘는 스트링일 때는 이 3이 나오겠죠

1556
01:41:51,360 --> 01:41:56,397
그래서 스트링으로 이렇게 놓으면은 말씀하신 것처럼
이렇게 이 3이 나오는데 얘는 자료형을 잘 봐야 돼요

1557
01:41:56,421 --> 01:41:59,220
자료형이 숫자형 자료형이죠

1558
01:41:59,280 --> 01:42:00,040
이게 없기 때문에

1559
01:42:00,140 --> 01:42:02,040
그렇기 때문에 더해서 5가 나오게 됩니다

1560
01:42:02,300 --> 01:42:04,220
그래서 요거 인덱싱을 배워봤고요

1561
01:42:04,320 --> 01:42:04,940
마찬가지입니다

1562
01:42:05,080 --> 01:42:08,200
그 스트링이랑 거의 비슷한 게
마이너스를 넣으면 거꾸로 됩니다

1563
01:42:08,460 --> 01:42:13,280
3이 나오고 마이너스 2를 하면은 2가
나오고 마이너스 3을 하면은 1이 나온다

1564
01:42:13,340 --> 01:42:16,300
요거는 이제 그 스트링이랑 거의 똑같죠

1565
01:42:16,360 --> 01:42:19,620
그래서 리스트는 스트링이랑 거의
비슷하게 인덱싱이 이루어집니다

1566
01:42:19,700 --> 01:42:20,960
이렇게 이해할 수 있을 것 같고요

1567
01:42:21,280 --> 01:42:22,580
네 요런 경우가 좀 있습니다

1568
01:42:22,840 --> 01:42:25,980
이렇게 복합적으로 리스트 안에
리스트가 또 들어 있는 경우가 있어요

1569
01:42:26,080 --> 01:42:26,377
네 요런 경우가 좀 있습니다

1570
01:42:26,401 --> 01:42:26,377
이렇게 복합적으로 리스트 안에
리스트가 또 들어 있는 경우가 있어요

1571
01:42:26,401 --> 01:42:28,760
리스트인데 안에 리스트가 또 있어요

1572
01:42:28,920 --> 01:42:30,060
그럼 이게 어떤 개념이냐?

1573
01:42:30,100 --> 01:42:31,240
인덱스는 똑같습니다

1574
01:42:31,320 --> 01:42:36,140
얘가 0번이고, 얘가 1번,
얘가 2번, 얘 전체가 3번입니다

1575
01:42:36,340 --> 01:42:40,260
이 전체 하나의 리스트가 3번 인덱스인 거고요

1576
01:42:40,340 --> 01:42:45,240
그래서 실제로 한번 출력을 해보면
프린트 A의 3번째 인덱스를 뽑아볼게요

1577
01:42:45,770 --> 01:42:47,300
그러면 리스트가 나옵니다

1578
01:42:47,380 --> 01:42:49,160
여기도 하나의 새로운 리스트잖아요

1579
01:42:49,680 --> 01:42:52,957
그럼 그 새로운 리스트에서 또 예를 들어 B를 뽑고 싶다

1580
01:42:52,981 --> 01:42:57,860
그러면 새로운 리스트에는
또 0번, 1번, 2번 인덱스잖아요

1581
01:42:58,020 --> 01:43:04,860
그러면 B를 뽑고 싶다고 하면 여기에다가 또
대괄호를 쓰고 1을 쓰면 이렇게 해서 B를 뽑을 수가 있겠죠

1582
01:43:05,060 --> 01:43:12,980
그래서 이 리스트 자체도 그냥 하나의 인덱스 안에 들어가 있고
그 안에서 또 하나 추출해내고 싶다면 이어서 이렇게 써주면 됩니다

1583
01:43:13,320 --> 01:43:15,340
그래서 이렇게 쓸 일이 굉장히 많아요

1584
01:43:15,480 --> 01:43:17,840
그래서 이거를 잘 기억해두시면 좋을 것 같습니다

1585
01:43:18,060 --> 01:43:20,080
마찬가지이긴 한데, 마이너스 1을 해도 똑같겠죠

1586
01:43:20,220 --> 01:43:22,457
왜냐하면 거꾸로 해서 얘가 마이너스 1번 인덱스니까

1587
01:43:22,481 --> 01:43:24,480
그러면 C를 출력하려면 어떻게 해야 될까요?

1588
01:43:24,560 --> 01:43:25,100
되게 쉽죠

1589
01:43:25,140 --> 01:43:33,140
C를 출력하려면 얘를 2번으로 바꾸면 이제 얘를
가져온 다음에 0, 1, 2니까 이렇게 C가 나오게 되겠죠

1590
01:43:34,020 --> 01:43:37,460
그래서 이거는 많이 연습해주시면
많이 쓰이니까 좋을 것 같습니다

1591
01:43:37,720 --> 01:43:41,100
좋은 질문을 해주셨는데 1하고 0하면 오류가 나나요?

1592
01:43:41,160 --> 01:43:41,800
오류가 납니다

1593
01:43:41,920 --> 01:43:42,400
왜냐?

1594
01:43:42,440 --> 01:43:43,360
1번이 2죠

1595
01:43:43,460 --> 01:43:46,920
그런데 2는 인덱스, 그러니까 숫자형 자료형이죠

1596
01:43:47,040 --> 01:43:51,217
그렇기 때문에 대괄호를 붙여서 0
해봤자 인덱싱이라는 게 안 됩니다

1597
01:43:51,241 --> 01:43:52,780
그런데 이런 경우는 있을 수 있죠

1598
01:43:52,860 --> 01:43:55,800
얘가 hello라는 문자열 자료형이에요

1599
01:43:55,920 --> 01:43:59,920
그러면 1번째를 선택하면 얘가
나오는데 여기는 인덱싱이 되죠

1600
01:43:59,960 --> 01:44:02,060
왜냐하면 문자열 자료형이기 때문에

1601
01:44:02,160 --> 01:44:04,240
그래서 이렇게 사용하면 H가 나옵니다

1602
01:44:04,300 --> 01:44:06,760
이 문자열 자료형의 0번째 인덱스니까

1603
01:44:06,920 --> 01:44:08,400
그래서 이렇게 표현할 수가 있겠습니다

1604
01:44:08,580 --> 01:44:10,260
이렇게 쓰이고 이거는 되게 중요합니다

1605
01:44:10,340 --> 01:44:11,380
이거는 많이 쓰이기 때문에

1606
01:44:11,480 --> 01:44:14,520
지적 허용심 용이 아니라 이건 진짜 공부할 용입니다

1607
01:44:14,780 --> 01:44:17,460
3중 리스트 이것도 연습해보시면 좋을 것 같습니다

1608
01:44:17,720 --> 01:44:19,740
그다음에 슬라이싱도 마찬가지입니다

1609
01:44:19,840 --> 01:44:21,216
거의 스트링이랑 비슷하다는 의미입니다

1610
01:44:21,240 --> 01:44:22,660
슬라이싱이랑 비슷해요

1611
01:44:22,740 --> 01:44:23,640
0에서 2

1612
01:44:23,740 --> 01:44:25,320
이렇게 하면 뭐가 나올까요?

1613
01:44:25,480 --> 01:44:26,760
1, 2 이렇게 나옵니다

1614
01:44:26,800 --> 01:44:27,100
왜냐?

1615
01:44:27,180 --> 01:44:27,840
이거 기억나시죠?

1616
01:44:28,040 --> 01:44:29,040
얘가 이상

1617
01:44:29,180 --> 01:44:30,440
얘가 미만이죠

1618
01:44:30,580 --> 01:44:34,200
그렇다는 거는 0번 인덱스부터 2 미만이니까

1619
01:44:34,280 --> 01:44:34,940
이 전까지

1620
01:44:34,980 --> 01:44:36,540
1, 2가 나오게 되겠죠

1621
01:44:36,640 --> 01:44:37,300
보시면 되겠습니다

1622
01:44:37,480 --> 01:44:38,900
얘도 간격도 똑같습니다

1623
01:44:39,080 --> 01:44:40,900
그래서 간격을 원래 기본이 1이에요

1624
01:44:41,100 --> 01:44:44,820
그냥 1 써주는 거랑 안 써주는 거랑
똑같은데 얘를 2로 바꾸면 어떻게 될까요?

1625
01:44:44,920 --> 01:44:46,240
그러면 두 칸씩 갑니다

1626
01:44:46,380 --> 01:44:51,060
0부터 여기까지니까 이 두 칸씩 가봤자
1밖에 못 나오는데 끝까지로 바꿔볼게요

1627
01:44:51,240 --> 01:44:53,500
빈 것이면 끝까지인 거죠

1628
01:44:53,640 --> 01:44:56,840
그럼 이렇게 쓰면 1, 3, 5가 나옵니다

1629
01:44:56,920 --> 01:44:57,400
왜냐?

1630
01:44:57,860 --> 01:45:00,240
0번째부터 두 칸씩

1631
01:45:00,340 --> 01:45:03,717
하나 두 칸 띄워서 3 나오고 두 칸 띄워서 5 나오고

1632
01:45:03,741 --> 01:45:05,300
이렇게 해볼 수가 있겠죠

1633
01:45:05,740 --> 01:45:08,460
근데 0은 또 쓰나 안 쓰나 똑같으니까 이거랑 같겠죠

1634
01:45:09,180 --> 01:45:11,580
이렇게 다양하게 표현을 해볼 수가 있겠습니다

1635
01:45:11,940 --> 01:45:14,780
이렇게 쓰는 거랑 거의 문자열이랑 똑같죠

1636
01:45:14,880 --> 01:45:20,437
문자열 때는 이렇게 있으면 이렇게 자르면
0부터 2 미만에서 이렇게 가져오는 거랑 똑같죠

1637
01:45:20,461 --> 01:45:28,461
그래서 리스트... 사실 이것도 다 똑같은 거라 눈으로 봐도
이거는 직접 한번 연습해보시면서 실습하시면 이해가 되실 것 같습니다

1638
01:45:29,240 --> 01:45:35,003
그래서 1, 2, 3, 4, 5 있을 때 처음부터
2번 인덱스 미만 1, 2인 거고 그리고 나머지

1639
01:45:35,027 --> 01:45:39,660
뒤에 2번째 인덱스부터 끝까지라고 하면
1, 2, 3, 4, 5 이렇게 나눠줄 수가 있겠죠

1640
01:45:39,780 --> 01:45:40,220
B, c가

1641
01:45:40,260 --> 01:45:42,280
거의 스트링이랑 비슷하게 나눌 수 있겠습니다

1642
01:45:42,760 --> 01:45:44,940
이것도 연습해보시면 좋을 것 같아요

1643
01:45:45,260 --> 01:45:46,940
이거는 한번 해볼까요?

1644
01:45:47,040 --> 01:45:48,217
이거를 어떻게 하면 되나?

1645
01:45:48,241 --> 01:45:54,480
이것도 그냥 하나의 덩어리로의 인덱스가 된
거라고 생각하신 다음에 나눠보시면 좋을 것 같습니다

1646
01:45:54,660 --> 01:45:56,240
이렇게 하면 어떻게 될까요?

1647
01:45:56,400 --> 01:45:58,960
그러면 2번 인덱스 이상이니까 포함이죠

1648
01:45:59,080 --> 01:46:00,260
2번 인덱스가 이거죠

1649
01:46:00,300 --> 01:46:06,160
이상 5번 미만이니까 2, 3,
4, 5 미만이면 이렇게 나오겠죠

1650
01:46:06,320 --> 01:46:09,180
실제로 출력해보면 이렇게 나옵니다

1651
01:46:09,280 --> 01:46:13,120
아마 스트링에서 좀 이해가 되셨으면
여기도 금방 이해가 되실 겁니다

1652
01:46:13,420 --> 01:46:17,997
그래서 이거는 되게 중요하게 많이 쓰이는
개념이라 연습을 자주 해보시면 좋을 것 같습니다

1653
01:46:18,021 --> 01:46:19,640
리스트 연산하기도 해보겠습니다

1654
01:46:19,880 --> 01:46:22,920
스트링도 이게 더하기가 되고 곱하기가 됐잖아요

1655
01:46:23,060 --> 01:46:25,200
그것처럼 리스트도 연산을 해보겠습니다

1656
01:46:25,680 --> 01:46:28,400
더하기를 해보면 얘도 거의 개념은 비슷합니다

1657
01:46:28,660 --> 01:46:36,660
프린트 a 더하기 b를 해보면 이렇게 1, 2, 3 하고 스트링 마치
이어붙이듯이 리스트도 그냥 개수 서랍장을 서랍을 추가한 느낌이에요

1658
01:46:38,380 --> 01:46:46,380
그래서 3칸짜리 서랍이 있는데 여기에 뒤에 서랍을 더 붙여서
이렇게 총 6칸짜리 서랍이 되는 이런 개념이 더하기의 개념입니다

1659
01:46:48,020 --> 01:46:49,600
에서 리스트끼리도 더할 수 있다

1660
01:46:49,660 --> 01:46:50,780
그럼 곱하기도 됩니다

1661
01:46:51,160 --> 01:46:52,020
반복의 개념입니다

1662
01:46:52,120 --> 01:46:53,580
이것도 거의 스트링이랑 비슷하죠

1663
01:46:53,700 --> 01:47:01,700
곱하기 3 하면은 파이썬 파이썬 파이썬 이렇게 찍힌 것처럼
리스트도 곱하기 3 이렇게 하면은 b를 3을 놓고 곱해 보면은 1, 2, 3

1664
01:47:03,020 --> 01:47:03,600
1, 2, 3

1665
01:47:03,640 --> 01:47:04,060
1, 2, 3

1666
01:47:04,140 --> 01:47:05,780
세 번 반복되는 형태가 되겠죠

1667
01:47:05,900 --> 01:47:09,480
그래서 더하기 곱하기가 된다는
거 이해해 주시면 좋을 것 같습니다

1668
01:47:09,620 --> 01:47:10,376
이렇게 할 수가

1669
01:47:10,400 --> 01:47:11,940
그 다음 리스트 길이 구하기

1670
01:47:12,040 --> 01:47:14,100
이거 또한 스트링이랑 거의 비슷합니다

1671
01:47:14,380 --> 01:47:17,996
스트링에서도 문자열의 길이를
구할 때 makes의 약자입니다

1672
01:47:18,020 --> 01:47:19,356
랭이라는 함수를 썼었죠

1673
01:47:19,380 --> 01:47:23,700
그것처럼 이것도 마찬가지로 리스트의
길이를 구할 때도 랭을 쓰시면 됩니다

1674
01:47:23,940 --> 01:47:27,240
그러면 이거 랭을 써서 출력을
해보면 이렇게 3이 나오게 됐죠

1675
01:47:27,320 --> 01:47:31,240
그래서 이것도 리스트의 길이가
3이니까 랭을 썼을 때 3이 나오게 됩니다

1676
01:47:31,500 --> 01:47:34,060
근데 스트링이 문자로 이루어진 리스트군요

1677
01:47:34,120 --> 01:47:37,436
이거가 되게 좋은 표현인 게 문자열이라고 부르잖아요

1678
01:47:37,460 --> 01:47:37,860
스트링을

1679
01:47:37,920 --> 01:47:41,220
이게 문자가 플러스 배열의 느낌이거든요

1680
01:47:41,740 --> 01:47:42,740
문자열이라는 게

1681
01:47:42,780 --> 01:47:46,617
이런 개념이라 어떻게 보면 문자를 엮은 리스트인 거죠

1682
01:47:46,641 --> 01:47:51,720
이런 개념이라고 이해하시면 이 문자열을 좀
더 이해하는데 도움이 되시지 않을까 싶습니다

1683
01:47:51,940 --> 01:47:56,780
자료형에 대해서 좀 이해를 도울 수 있는 예제인
것 같아서 이거는 빠르게 한번 보도록 하겠습니다

1684
01:47:57,480 --> 01:47:59,620
자료형이 헷갈리는 경우가 좀 있잖아요

1685
01:47:59,860 --> 01:48:07,860
그래서 헷갈리는 경우를 좀 보자면은 아까도 영님께서 헷갈려서 말씀 주신 게
있었는데 이것도 한 마찬가지로 여기 보면 이렇게 계산을 해보면 오류가 납니다

1686
01:48:10,740 --> 01:48:12,020
왜 오류가 날까요?

1687
01:48:12,120 --> 01:48:15,200
생각해보면 A의 2번은 0, 1, 2니까 3이죠

1688
01:48:15,300 --> 01:48:16,616
3이 여기 들어가는 거랑 마찬가지죠

1689
01:48:16,640 --> 01:48:23,740
3이라는 숫자와 숫자열을 더한다의 개념인데
파이썬에서는 서로 다룬 자료형이 더해지지가 않습니다

1690
01:48:23,880 --> 01:48:27,560
자바스크립트나 다른 언어에서 되는
데도 있는데 형태를 통일해 주셔야 됩니다

1691
01:48:27,760 --> 01:48:29,060
이렇게 더하면 오류가 납니다

1692
01:48:29,180 --> 01:48:29,620
왜냐?

1693
01:48:29,700 --> 01:48:37,700
네, 오프랜드가 이제 양쪽 요거를 의미하는데 이게 인트랑 스트링이랑
더하려고 하는데 자료형이 다르니까 못 더해 라고 에러를 내뱉게 됐습니다

1694
01:48:39,240 --> 01:48:40,360
그래서 이걸 하려면 어떻게 해야 되냐?

1695
01:48:40,780 --> 01:48:42,520
자료 형태를 변환해 줘야 됩니다

1696
01:48:43,060 --> 01:48:49,700
Str로 이렇게 감싸서 변환을 해주면 str로
감싼다는 게 얘의 자료형을 이거랑 같은 개념입니다

1697
01:48:49,740 --> 01:48:54,320
이렇게 하는 거랑 같은 개념인데 자료형을
문자열로 바꾼다 라고 하면 3하의가 되겠죠

1698
01:48:54,440 --> 01:48:55,620
이렇게 쓸 수가 있겠습니다

1699
01:48:56,000 --> 01:48:57,176
곱하기는 어떻게 되냐?

1700
01:48:57,200 --> 01:49:01,040
라고 해주셨는데 곱하기는 아까 설명드렸듯이 그냥 곱해지죠

1701
01:49:01,120 --> 01:49:07,320
그냥 숫자로도 문자 곱하기 3하면 이거 반복의
표현이니까 이거는 그냥 기본적으로 됩니다

1702
01:49:07,620 --> 01:49:09,680
아무튼 그래서 자료형이 굉장히 중요하다

1703
01:49:09,800 --> 01:49:15,080
그래서 처음에 1 더하기 1 말씀드린 게 자료형에
따라 결과가 달라지니까 이렇게 말씀을 드렸습니다

1704
01:49:15,260 --> 01:49:17,480
그 다음에 이렇게 str로 감싸면 되겠죠

1705
01:49:18,120 --> 01:49:19,120
나누기는 안 됩니다

1706
01:49:19,260 --> 01:49:20,620
나누기도 오류가 나겠죠

1707
01:49:20,800 --> 01:49:22,680
나누기를 하면 이렇게 오류가 납니다

1708
01:49:22,860 --> 01:49:25,860
그 다음에 리스트는 아까 서랍장 말씀드렸잖아요

1709
01:49:26,000 --> 01:49:29,500
이렇게 서랍장을 넣다 뺐다가
하면서 교체를 할 수가 있습니다

1710
01:49:29,700 --> 01:49:36,320
서랍장에 2가 들어가 있었는데 이 a라는
변수에서 2만 따로 버리고 여기에 막 5를 넣고 싶어요

1711
01:49:36,400 --> 01:49:39,720
이렇게 5를 넣어서 바꿔치기
하고 싶다 라고 하면 가능합니다

1712
01:49:39,840 --> 01:49:45,820
그래서 5를 뺐다가 딴 숫자 넣고 이런 게 가능해서
이거 하는 방법을 빠르게 소개를 드리도록 하겠습니다

1713
01:49:46,060 --> 01:49:47,060
이렇게 가능합니다

1714
01:49:47,300 --> 01:49:48,840
Print a를 해보겠습니다

1715
01:49:49,180 --> 01:49:53,340
리스트의 경우에 a가 1, 2, 3인데
2번째 인덱스를 4로 바꾸겠다

1716
01:49:53,480 --> 01:49:55,200
그럼 0, 1, 2니까 이거죠

1717
01:49:55,260 --> 01:49:58,220
이거를 4로 바꾸면 이렇게 1, 2, 4가 나옵니다

1718
01:49:58,300 --> 01:50:06,300
이렇게 진행이 되는 게 리스트의 값을 바꿔칠 때 리스트의 인덱스를
이용해서 가져와서 이거를 변수 삼아서 얘가 상자의 역할이 되는 거죠

1719
01:50:08,140 --> 01:50:11,020
그래서 오른쪽에 있는 걸 왼쪽에 넣는다잖아요

1720
01:50:11,280 --> 01:50:16,036
그래서 오른쪽에 있는 값을 왼쪽에 상자에 넣는다

1721
01:50:16,060 --> 01:50:18,480
넣는다의 개념이니까 이게 4로 바뀌게 되겠죠

1722
01:50:18,580 --> 01:50:20,400
이렇게 바꿔치기를 할 수가 있겠습니다

1723
01:50:20,620 --> 01:50:23,540
그리고 좀 더 응용을 해서 딜리트도 가능합니다

1724
01:50:23,680 --> 01:50:26,640
아예 그 서랍 하나 자체를 떼서 버릴 수가 있어요

1725
01:50:26,800 --> 01:50:27,540
그래서 이거는 어떻게 하냐

1726
01:50:27,620 --> 01:50:29,340
Del이라는 키워드를 쓸 수가 있습니다

1727
01:50:29,840 --> 01:50:34,200
이거를 하면 del a의 1이라는
건 1번 인덱스니까 이거죠

1728
01:50:34,280 --> 01:50:38,640
이거를 아예 날려버린다고 하면 길이가 2인 배열이 되죠

1729
01:50:38,980 --> 01:50:40,600
길이가 2인 리스트가 되죠

1730
01:50:40,660 --> 01:50:43,120
그래서 1, 3이 남는 것을 확인할 수가 있습니다

1731
01:50:43,420 --> 01:50:44,577
이렇게 날릴 수도 있고요

1732
01:50:44,601 --> 01:50:49,220
2개의 리스트가 있을 때 같은
인덱스끼리 숫자형으로 어떻게 더하나요?

1733
01:50:49,300 --> 01:50:51,920
2개의 리스트가 있을 때 그냥 더하면 됩니다

1734
01:50:52,100 --> 01:50:54,400
이렇게 있다고 하면 이거 말씀이신가요?

1735
01:50:54,540 --> 01:50:58,840
그냥 print a에 0번 더하기 b에 0번

1736
01:50:58,900 --> 01:50:59,900
이런 거는 당연히 되죠

1737
01:50:59,960 --> 01:51:01,060
그냥 숫자 숫자이기 때문에

1738
01:51:01,180 --> 01:51:04,820
이거를 출력해보면 이렇게 1
더하기 4가 돼서 5가 나옵니다

1739
01:51:04,980 --> 01:51:08,560
공백도 같이 지우려면 공백이라 하면 여기 이거

1740
01:51:08,740 --> 01:51:14,557
이거는 사실 공백이라기보다는
그냥 프린트를 하면 이렇게 기본적으로

1741
01:51:14,581 --> 01:51:15,017
나와요

1742
01:51:15,041 --> 01:51:17,400
그러니까 print b를 해도 여기 공백이 없잖아요

1743
01:51:17,600 --> 01:51:19,160
근데 공백이 생겨서 나옵니다

1744
01:51:19,600 --> 01:51:20,840
왜냐면 그냥 표기법이에요

1745
01:51:20,920 --> 01:51:21,300
이건 사실

1746
01:51:21,420 --> 01:51:24,880
왜냐면 자료형이 이렇게 생겼다라는 서랍장의 그림이지

1747
01:51:25,160 --> 01:51:28,720
여기에 뭐 값이 공백이라는 값이 추가된 건 아닙니다

1748
01:51:28,780 --> 01:51:29,060
여기서는

1749
01:51:29,120 --> 01:51:32,720
그다음에 슬라이싱도 되는데 슬라이싱으로 삭제도 돼요

1750
01:51:32,880 --> 01:51:36,460
이것도 좀 신기한데 파이썬은 좀 자유분방한 것 같습니다

1751
01:51:36,600 --> 01:51:36,960
이런 걸 보면

1752
01:51:37,120 --> 01:51:38,920
그래서 얘는 슬라이싱이죠

1753
01:51:39,060 --> 01:51:42,580
슬라이싱이라 하면 2번 인덱스 이상부터 끝까지

1754
01:51:43,220 --> 01:51:44,480
0, 1, 2니까

1755
01:51:44,580 --> 01:51:46,176
2번부터 끝까지면 이거죠

1756
01:51:46,200 --> 01:51:46,900
3, 4, 5

1757
01:51:47,220 --> 01:51:48,840
이거를 날립니다

1758
01:51:49,080 --> 01:51:50,120
그럼 어떻게 되냐

1759
01:51:50,620 --> 01:51:51,700
1, 2만 남겠죠

1760
01:51:52,340 --> 01:51:56,520
그래서 굉장히 할 수 있는 것이
슬라이싱으로 날려버릴 수가 있습니다

1761
01:51:57,160 --> 01:52:00,880
이렇게 해서 이제 리스트를 좀
조작하는 방법들을 배워봤습니다

1762
01:52:01,620 --> 01:52:02,980
그래서 중간 뭐 날릴 수도 있겠죠

1763
01:52:03,100 --> 01:52:06,240
처음부터 끝까지인데 이거를 뭐 2부터 4

1764
01:52:06,400 --> 01:52:11,740
이렇게 하면 4번인 0, 1, 2, 3, 4
미만이니까 이렇게 두 개를 날리게 되겠죠

1765
01:52:11,900 --> 01:52:13,417
그럼 1, 2, 5가 남겠죠

1766
01:52:13,441 --> 01:52:14,900
이렇게 두 개를 날려서

1767
01:52:15,020 --> 01:52:16,460
이런 것도 당연히 가능합니다

1768
01:52:16,660 --> 01:52:23,980
네, 그러면 이제 리스트에서 좀 슬라이싱, 인덱싱부터
문자열이랑 거의 비슷한 조작들을 배워봤습니다

1769
01:52:24,200 --> 01:52:29,340
그럼 리스트도 마찬가지로 자료형이니까
어떤 함수, 메소드가 있습니다

1770
01:52:29,780 --> 01:52:31,580
그래서 그거를 하나씩 써보도록 하겠습니다

1771
01:52:31,920 --> 01:52:33,840
네, 리스트의 요소 추가하기

1772
01:52:33,940 --> 01:52:38,560
리스트가 이제 서랍장이니까 거기에
새로운 서랍을 추가하는 뭔가 함수도 있습니다

1773
01:52:38,800 --> 01:52:40,220
Print a를 하면

1774
01:52:40,360 --> 01:52:41,740
네, 이거를 출력을 해보면

1775
01:52:42,100 --> 01:52:43,397
A라는 리스트가 있습니다

1776
01:52:43,421 --> 01:52:49,040
그런데 여기에 4라는 새로운 값을
추가를 하면 이렇게 1, 2, 3, 4가 됩니다

1777
01:52:49,240 --> 01:52:51,180
그러면 리스트를 추가할 수도 있습니다

1778
01:52:51,500 --> 01:52:52,960
리스트를 추가하면 어떻게 되냐

1779
01:52:53,020 --> 01:52:55,840
네, 이렇게 추가하면... 여기 이어서 되네요

1780
01:52:56,300 --> 01:53:01,000
그러면 4를 추가하고 5, 6이라는 리스트를
추가하면 말 그대로 리스트가 추가됩니다

1781
01:53:01,400 --> 01:53:05,220
0, 1, 2, 3, 4번 인덱스에 그냥
리스트가 들어간 형태가 되겠죠

1782
01:53:05,300 --> 01:53:06,740
그래서 이렇게 추가가 됩니다

1783
01:53:07,540 --> 01:53:08,680
그다음에 정렬

1784
01:53:08,740 --> 01:53:10,180
정렬도 굉장히 많이 쓰이죠

1785
01:53:10,680 --> 01:53:12,160
정렬할 일이 되게 많은데

1786
01:53:12,580 --> 01:53:13,396
정렬하는 방법

1787
01:53:13,420 --> 01:53:14,540
정렬하는 방법을 배워보도록 하겠습니다

1788
01:53:15,020 --> 01:53:17,320
정렬을 하면 숫자가 이렇게 막 섞여 있을 때가 있죠

1789
01:53:17,400 --> 01:53:19,040
문자, 숫자 이런 거 섞여 있을 때

1790
01:53:19,480 --> 01:53:24,400
Sort를 하게 되면 .sort를 통해서 여기
있는 걸 다 정렬을 할 수가 있습니다

1791
01:53:24,520 --> 01:53:24,940
깔끔하게

1792
01:53:25,240 --> 01:53:31,980
그래서 정렬을 하면 이게 1, 4, 3인데 이제 1, 2,
3, 4로 바뀌어서 정렬이 된 것을 확인할 수 있죠

1793
01:53:32,200 --> 01:53:34,520
그러면 인덱스도 이제 딱 정렬돼서 나오겠죠

1794
01:53:35,680 --> 01:53:39,200
알파벳도 알파벳 순서대로 오름차순으로 정렬을 하게 됩니다

1795
01:53:39,560 --> 01:53:42,697
그래서 a, c, b 이런 것도 a, c, b를 넣고

1796
01:53:42,721 --> 01:53:48,720
실행을 하면 sort 함수를 통해서 a,
b, c로 정렬이 된 것을 확인할 수 있죠

1797
01:53:49,120 --> 01:53:51,817
상냥한 소년이 함수는 실행할 수 있는 지시어 개념

1798
01:53:51,841 --> 01:53:52,140
맞습니다

1799
01:53:52,380 --> 01:53:57,300
약간 그걸 할 수 있게 기능을 만들어
놓고 이 기능을 실행하는 개념입니다

1800
01:53:57,500 --> 01:54:01,280
그래서 sort라는 기능도 안에 뭐
알고리즘이 막 짜져 있을 거예요

1801
01:54:01,380 --> 01:54:07,120
퀵소트 이런 방법으로 쫙 짜져 있을 텐데 그거를
실행하면 그냥 쫙 정렬이 되는 그런 형태입니다

1802
01:54:07,280 --> 01:54:14,960
그래서 이런 알고리즘 다 짜놨으니까 이름만 기억하면
.sort만 하면 쫙 알아서 최적화되게 정렬을 해줍니다

1803
01:54:15,180 --> 01:54:16,180
뒤집을 수도 있습니다

1804
01:54:16,380 --> 01:54:20,940
그러니까 sorting을 하면 오름차순이 되는데
내림차순 정렬을 하고 싶을 수도 있잖아요

1805
01:54:21,160 --> 01:54:23,120
그때 리버스를 쓸 수가 있습니다

1806
01:54:23,880 --> 01:54:29,480
리버스 단독으로 쓰면 말 그대로 그냥 거꾸로만 해주거든요

1807
01:54:30,240 --> 01:54:35,329
리버스를 쓰면 a, c, b가 있다고
하면 b, c, a 즉 이렇게 이렇게

1808
01:54:35,353 --> 01:54:40,220
이렇게 거꾸로 정렬이 되는데 sort를
한 다음에 리버스를 하면 어떻게 될까요?

1809
01:54:40,320 --> 01:54:42,300
A.sort, a.reverse를 해서.

1810
01:54:42,720 --> 01:54:50,720
Sort를 먼저 한 다음에 그 다음에 그 a를 리버스를 하면 내림차순,
오름차순이 아닌 내림차순으로 c, b, a 이렇게 정렬이 됩니다.

1811
01:54:51,340 --> 01:54:54,880
Index 반환 이것도 find랑 비슷한 개념이죠

1812
01:54:55,000 --> 01:55:00,160
그 앞에 배웠던 index 함수가 이런
식으로 string에서처럼 쓸 수가 있습니다.

1813
01:55:00,460 --> 01:55:05,480
Print 이거를 해보면 이게 이제
함수를 배우면 아마 이해가 되실 겁니다

1814
01:55:05,640 --> 01:55:06,617
이런 개념이

1815
01:55:06,641 --> 01:55:14,641
그래서 지금은 그냥 이렇게 하는구나 정도로 index 3이 몇
번째 인덱스야 라고 find나, 뭐 index 함수 string에서 썼었죠

1816
01:55:14,740 --> 01:55:18,540
문자열에서도 이것처럼 3이 0, 1, 2번째죠

1817
01:55:18,620 --> 01:55:22,520
그렇기 때문에 2가 나왔고
그러면 1은 몇 번째 인덱스일까요?

1818
01:55:22,920 --> 01:55:23,600
0번째죠

1819
01:55:23,660 --> 01:55:26,120
그래서 0이 나오고 이렇게 할 수가 있겠습니다

1820
01:55:26,440 --> 01:55:29,780
그럼 여기서 없는 거, 5 이런
값을 쓰면 오류가 나오게 됩니다

1821
01:55:30,120 --> 01:55:36,440
그래서 이런 index라는 메소드도 index라는 함수도
string에서랑 거의 비슷하다고 하실 수가 있겠습니다

1822
01:55:36,820 --> 01:55:42,500
실행을 제대로 구현하려면 함수들을 다 외워야겠네요
라고 해주셨는데 그냥 어느 정도만 외워도 됩니다

1823
01:55:42,720 --> 01:55:49,820
그러니까 모든 문법을 자세하게 알 필요는 없고 왜냐하면
채찍비티나 구글 검색이나 를 통해서 문법은 언제든 찾아볼 수 있잖아요

1824
01:55:50,000 --> 01:55:53,760
그렇기 때문에 이런 개념이 있었지
정도로 이해하시면 좋을 것 같습니다

1825
01:55:54,120 --> 01:55:59,340
네, 그래서 이렇게 하면 되고 그래서 아까 없던
값 했을 때 오류 나는 것까지도 확인해봤습니다

1826
01:55:59,520 --> 01:56:04,826
그 다음에 리스트의 요소 삽입이라는 것도
있는데 아까는 append랑은 어떤 차이가 있는지 좀

1827
01:56:04,850 --> 01:56:11,417
소개를 드리면 insert는 어떤 개념이냐면 몇 번째
인덱스에 어떤 값을 넣겠다라고 순서가 있습니다

1828
01:56:11,441 --> 01:56:14,860
그래서 얘는 몇 번째 인덱스?

1829
01:56:14,900 --> 01:56:17,440
하고 얘는 값을 넣는 겁니다

1830
01:56:17,620 --> 01:56:22,380
즉 0 번째 인덱스에 4라는 값을 추가하겠다라는 뜻입니다

1831
01:56:22,760 --> 01:56:30,760
네, 그래서 이렇게 하면 0 번째 인덱스에 4라는
값이 추가 번호에 어떤 값을 삽입한다의 함수입니다

1832
01:56:45,380 --> 01:56:47,260
이렇게 이해하시면 좋을 것 같습니다

1833
01:56:47,500 --> 01:56:50,480
그 다음에 remove, 추가하는
게 있으면 제거하는 것도 있겠죠

1834
01:56:50,880 --> 01:56:58,880
그래서 제거는 리스트에서 첫 번째로 나오는 x를 삭제하는
함수, 즉 이렇게 되면 이 3이 여러 개 있을 수도 있잖아요

1835
01:56:59,240 --> 01:57:05,917
여기 있고 여기, 가운데도 있고 끝에도 있는데
탐색을 하면서 가장 먼저 걸리는 3을 remove를 해줍니다

1836
01:57:05,941 --> 01:57:11,640
그래서 이렇게 가운데 있는 이 처음 맨
먼저 걸리는 3만 없어진 걸 확인할 수 있죠

1837
01:57:11,720 --> 01:57:13,500
그래서 remove까지도 써봤고요

1838
01:57:13,580 --> 01:57:17,360
두 개 가지고 있을 경우 이제
가운데만 되고, 그러면 이 두 번 써야겠죠

1839
01:57:17,440 --> 01:57:21,200
이렇게 remove를 두 번 써줘야지
이렇게 둘 다 없어지게 되겠습니다

1840
01:57:21,540 --> 01:57:28,640
뒤에 3을 없애려면 이렇게 하면 되겠고, 아니면 뭐
굳이 또 응용을 해본다면은 아까 reverse 배웠었죠.

1841
01:57:28,740 --> 01:57:36,720
Reverse를 하고 remove를 하고 또 reverse를 하면 뒤집고
지우고 뒤집고 해서 그래서 이제 얘는 뒤부터 지우게 되겠죠

1842
01:57:36,820 --> 01:57:37,220
이렇게 하면

1843
01:57:37,700 --> 01:57:42,820
이렇게 하면 뒤에 3만 날라가고 다시 원상복귀
돼서 이렇게 나온 것을 확인할 수가 있겠습니다

1844
01:57:43,200 --> 01:57:45,000
리스트 요소 끄집어내는 것도 있습니다

1845
01:57:45,320 --> 01:57:48,420
지우는 게 아니라 하나 폭 뱉어내는 개념이 있어요

1846
01:57:48,560 --> 01:57:50,680
그게 말 그대로 폭 뱉어낸다는 건 pop입니다.

1847
01:57:50,980 --> 01:57:58,980
Pop 되게 많이 쓰이는데 remove랑 거의 비슷한데 이렇게 1, 2,
3이 있는데 pop을 하면 맨 끝에 있는 거를 날려버린다는 개념이에요

1848
01:57:59,500 --> 01:58:00,780
얘를 날려보냅니다

1849
01:58:00,940 --> 01:58:02,480
그래서 1, 2만 남죠

1850
01:58:02,620 --> 01:58:06,220
근데 여기서 중요한 게 이 pop을
출력을 해 볼 수가 있겠습니다.

1851
01:58:06,360 --> 01:58:08,716
Pop이 말 그대로 날려버리는 개념이잖아요

1852
01:58:08,740 --> 01:58:10,420
그래서 3이 이렇게 튀어나옵니다

1853
01:58:10,540 --> 01:58:16,600
튀어나온다는 개념이 뭐냐면 이 프린트로 튀어나온 걸
출력을 해 보면 이렇게 3이 튀어나와서 찍힌 걸 볼 수가 있죠

1854
01:58:16,720 --> 01:58:22,300
이 pop을 하면 3이 튀어나와서 프린트를
찍어보면 실제로 여기 3이 나온 걸 볼 수가 있어요

1855
01:58:22,880 --> 01:58:26,340
그러니까 어떤 거를 pop하고
튀겨냈는지를 볼 수가 있습니다

1856
01:58:26,600 --> 01:58:29,640
그래서 이렇게 꺼내 볼 수
있다는 점이 있는 게 pop입니다

1857
01:58:29,820 --> 01:58:35,477
그래서 이걸 안 쓰면 그냥 아예
remove랑 거의 비슷한 개념인데 팝을 안

1858
01:58:35,501 --> 01:58:40,680
쓰면, 프린트를 안 쓰면, 팝은 그냥 어떤
게 튀어나가는지를 잡을 수가 있습니다

1859
01:58:41,000 --> 01:58:45,800
Append에 반대인데 append는 이렇게
4를 추가한다고 하면 이 차이가 있어요

1860
01:58:45,960 --> 01:58:48,360
팝이랑 또 다른 게 append는 안 나옵니다.

1861
01:58:48,760 --> 01:58:49,640
None이 나와요

1862
01:58:49,680 --> 01:58:52,520
여기 보면 이게 첫 번째 출력, 두 번째 출력이잖아요

1863
01:58:52,560 --> 01:58:54,120
첫 번째 출력이 none이에요

1864
01:58:54,280 --> 01:58:55,020
왜 none이냐?

1865
01:58:55,080 --> 01:58:59,160
Append는 추가하는 거라서 이렇게 퍽
하고 튀어나와서 3처럼 나오는 게 없습니다

1866
01:58:59,460 --> 01:59:01,277
근데 팝은 튀어나오는 게 있습니다

1867
01:59:01,301 --> 01:59:06,020
그래서 팝을 쓰게 되면 팝을 쓰게
되면 맨 끝에 게 튀어나와서 1, 2가 되죠

1868
01:59:06,080 --> 01:59:10,120
그래서 이 팝에 튀어나오는 거라고 보실 수가 있겠습니다

1869
01:59:10,340 --> 01:59:13,300
그래서 이렇게 팝을 이해해 주시면 좋을 것 같습니다

1870
01:59:13,860 --> 01:59:15,820
인덱스를 여기 팝으로도 쓸 수 있습니다

1871
01:59:16,100 --> 01:59:23,640
팝 1, 2라고 하면 팝이 그냥 아무것도 안 하면 맨 끝에 걸 날리는
건데 여기에 인덱스를 굳이 써서 0, 1, 2 인덱스 중에 1이 이거죠

1872
01:59:23,680 --> 01:59:25,780
그럼 2를 퍽 날리는 거가 되겠죠

1873
01:59:25,880 --> 01:59:28,800
그래서 날려버리면 2가 튀어나오고요

1874
01:59:28,860 --> 01:59:33,360
여기서 2가 튀어나왔고, 그 다음 1, 3만
남기고 그래서 이렇게 할 수도 있겠습니다

1875
01:59:33,560 --> 01:59:35,520
이게 계속 거의 비슷하죠

1876
01:59:35,620 --> 01:59:39,160
지금 스트링에서도 카운트라는
함수가 있었는데, 리스트에도 있습니다

1877
01:59:39,540 --> 01:59:46,600
그래서 이런 거 1이 몇 개가 포함되어 있을까
이런 거 궁금할 때 이렇게 카운트를 쓰면 됩니다

1878
01:59:47,140 --> 01:59:51,840
이렇게 하면은 a.count 1을 하면 1이 2개가 있죠

1879
01:59:51,940 --> 01:59:53,500
그래서 2개가 출력이 됩니다

1880
01:59:54,040 --> 01:59:56,877
Append랑 더하기의 차이..

1881
01:59:56,901 --> 01:59:59,800
사실 거의 똑같긴 합니다

1882
01:59:59,960 --> 02:00:01,097
사실 이게..

1883
02:00:01,121 --> 02:00:07,420
만약에 이렇게 4를 추가하는 거나 더하기를
하는 거나 어펜드 4를 하는 거나 같은 개념이긴 하죠

1884
02:00:07,880 --> 02:00:11,920
그래서 이걸 해서 출력을 해보면 이게 똑같습니다

1885
02:00:12,020 --> 02:00:13,040
이렇게 하셔도 됩니다

1886
02:00:13,440 --> 02:00:13,700
네 맞아요

1887
02:00:13,840 --> 02:00:19,060
이게 부자가 되고 싶어 님께서 굉장히 좋은
말씀 해주셨는데 기억이 안 나는 게 당연합니다

1888
02:00:19,240 --> 02:00:24,495
처음부터 배우자마자 기억이 나는 것은 머리가
엄청 좋아야 되는 거고 웬만하면 이런 문법이

1889
02:00:24,519 --> 02:00:28,897
있었지 정도의 개념만 있으면 채찍 PT나
구글링이나 이런 걸로 찾아가면서 하는 겁니다

1890
02:00:28,921 --> 02:00:36,180
디아블로 4 게임 만든 사람도 다 구글링하고 그런 어마어마한
개발자도 구글링 하면서 찾아보지 않는 사람이 없습니다

1891
02:00:36,380 --> 02:00:37,900
그래서 다 외운다는 말도 안됩니다

1892
02:00:38,000 --> 02:00:45,180
다 그냥 인터넷에 있으니까 찾아서 하겠다라고 하시면 좋고
자주 쓰면 외워진다 라는 개념으로 접근하시는 게 좋습니다

1893
02:00:45,320 --> 02:00:47,100
그 다음에 익스텐드 라는 것도 있습니다

1894
02:00:47,280 --> 02:00:51,260
어펜드랑 거의 비슷한데 이제
리스트끼리 이렇게 넣을 때 쓰게 됩니다

1895
02:00:51,500 --> 02:00:53,700
어펜드랑의 차이를 한번 보여드리도록 하겠습니다

1896
02:00:53,940 --> 02:00:58,180
익스텐드를 쓰면은 그냥 4,5라는게
펼쳐져서 확장이 되는 느낌이에요

1897
02:00:58,240 --> 02:00:59,356
어펜드는 어떻게 되냐?

1898
02:00:59,380 --> 02:01:01,220
어펜드를 하게 되면 차이 보이시나요?

1899
02:01:01,280 --> 02:01:06,776
익스펜드는 펼쳐져서 추가가 됐다면
어펜드는 그대로 이거 자체가 추가가 되버리죠

1900
02:01:06,800 --> 02:01:09,680
그래서 이런 차이가 익스펜드 랑 어펜드의 차이입니다

1901
02:01:09,720 --> 02:01:11,400
그렇게 정리를 해볼 수가 있겠고요

1902
02:01:11,460 --> 02:01:17,600
리스트에 사용할 수 있는 함수들까지 다
배워서 이제 오늘의 진도는 다 나갔습니다

1903
02:01:17,700 --> 02:01:21,820
점프 투 파이썬 2장 파이썬 프로그램의
기초 자료형 두 번째 시간입니다

1904
02:01:21,960 --> 02:01:24,840
점프 투 파이썬은 박응용 선생님이 지으신 책이고요

1905
02:01:24,940 --> 02:01:26,560
제가 강의를 맡게 되었습니다

1906
02:01:26,820 --> 02:01:29,880
지난 시간 복습을 해보자면 자료형에 대해서 배웠죠

1907
02:01:29,920 --> 02:01:34,366
그래서 1 더하기 1 이런 거 예제를
들어가면서 자료형에 따라서 결과가 완전히

1908
02:01:34,390 --> 02:01:38,260
달라질 수 있으니 자료형을 잘 파악하는
게 중요하다 라고 말씀을 드렸습니다

1909
02:01:38,380 --> 02:01:46,380
그래서 숫자 그리고 문자열 리스트 이렇게 세 개를 배우고 변수는 그냥 큰
개념만 배웠었는데 나머지 자료형들이 어떤 건지 하나씩 다 배워보도록 하겠습니다

1910
02:01:49,880 --> 02:01:52,620
네 그러면 튜플 자료형 들어가 보도록 하겠습니다

1911
02:01:52,820 --> 02:01:59,331
일단은 리스트랑 거의 비슷하기 때문에
리스트를 왜 쓰는지 생각을 해보면 각각 상자를

1912
02:01:59,355 --> 02:02:04,920
abc라는 변수를 각각 만들고 여기에
각각 값을 담기에는 너무 좀 번거로웠어요

1913
02:02:04,980 --> 02:02:06,560
왜냐하면 변수를 여러 개 관리해야 되니까

1914
02:02:06,620 --> 02:02:11,180
서랍장을 쓴다 라고 말씀드렸는데
튜플도 서랍장이랑 같은 개념입니다

1915
02:02:11,340 --> 02:02:15,160
거의 리스트랑 거의 동일한 개념이라고 보시면 되는데요

1916
02:02:15,280 --> 02:02:22,180
차이가 있다면 자물쇠로 잠궈서 더 이상 이 서랍장을
변경할 수 없다 라고 기억하시면 좋을 것 같습니다

1917
02:02:22,360 --> 02:02:24,080
리스트는 이런 게 됐잖아요

1918
02:02:24,280 --> 02:02:28,177
예를 들어서 a의 0번째를 선택해서 5로 바꾼다

1919
02:02:28,201 --> 02:02:31,080
요런 코드를 쓰면 어떻게 됐죠

1920
02:02:31,120 --> 02:02:32,440
여기 첫 번째 서랍이죠

1921
02:02:32,540 --> 02:02:40,400
0번째가 인덱스가 그러면 이 첫 번째 서랍에
있는 값이 5로 바뀌는 이렇게 바뀔 수가 있었죠

1922
02:02:40,500 --> 02:02:44,180
그래서 append니 하면 append를 하면 어떻게 됐죠

1923
02:02:44,240 --> 02:02:49,700
여기에 서랍 하나가 더 추가되고
값을 이렇게 추가할 수도 있었습니다

1924
02:02:50,040 --> 02:02:56,599
그래서 리스트에 대해서 값을 추가하고
변경하고 삭제하고 이런 과정에 대해서 배워봤는데

1925
02:02:56,623 --> 02:03:02,361
튜플 자료형은 리스트랑 거의 나머지
개념은 다 똑같은데 변경이 불가능합니다

1926
02:03:02,410 --> 02:03:10,410
그렇다는 것은 b에 마찬가지로 0번째 요소를 5로
변경한다 이런 코드를 쓰면 오류 메시지가 출력됩니다

1927
02:03:10,820 --> 02:03:12,160
이 변경을 할 수가 없습니다

1928
02:03:12,340 --> 02:03:17,140
변경이 안 되는 리스트라고 생각하시면
좀 빨리 이해하실 수 있을 것 같습니다

1929
02:03:17,520 --> 02:03:23,877
이런 변경이 안 된다라는 개념이 어떤 개념이냐면
프로그래밍에서 굉장히 많이 사용되는 개념인데요

1930
02:03:23,901 --> 02:03:29,680
그 파이썬에서는 이 뮤터블이랑 이뮤터블
자료형이 두 가지가 나눠져 있습니다

1931
02:03:29,860 --> 02:03:36,250
그 말씀드린 것처럼 변경이 가능한 거 이렇게
어떤 서랍에 어떤 숫자를 넣을지 이런 거를

1932
02:03:36,274 --> 02:03:42,060
바꿔치기 할 수 있고 뭔가 마음대로 변형할
수 있는 거는 뮤터블 자료형이라고 하고요

1933
02:03:42,100 --> 02:03:47,402
그래서 리스트가 대표적으로 아까 보여드린
것처럼 서랍장에 있는 값을 빼서 새로운 걸

1934
02:03:47,426 --> 02:03:52,377
넣고 이런 게 가능하고 뒤에 배울 뭐
딕셔너리 집합 이런 것도 뮤터블 자료형입니다

1935
02:03:52,401 --> 02:04:00,401
이거는 근데 지금은 약간 이해가 안 되실 수 있는데 이거는 개념적인 것만
설명을 드리고 뒤에서 좀 더 다뤄보면서 이 개념을 다시 한 번 설명드리면 아

1936
02:04:02,761 --> 02:04:10,040
이게 그 개념이었구나라고 이해 오는 시점이 있어서 지금은 이해가 안
되시더라도 아 이런 개념이 있구나 정도로 이해해 주시면 좋을 것 같습니다

1937
02:04:10,200 --> 02:04:12,200
그래서 얘네는 마음대로 변경이 가능하고요

1938
02:04:12,320 --> 02:04:20,320
이 뮤터블 자료형은 정수, 실수, 문자열,
튜플이 있는데 얘네는 변경이 불가능합니다

1939
02:04:20,500 --> 02:04:22,017
숫자가 변경이 불가능하다

1940
02:04:22,041 --> 02:04:30,041
이런 개념이 아직은 좀 와닿지 않을 텐데 지금은 그냥 아 이런 것들은 변경이
안 되는구나 정도로만 생각하시고 그 튜플이 이제 그 대표적인 예로 이번에

1941
02:04:32,741 --> 02:04:40,520
배워볼 건데 나머지 이것도 비슷한 자료라고 지금은 큰
그림에서 이해하신 다음에 뒤에 한 번 더 설명드리도록 하겠습니다

1942
02:04:40,640 --> 02:04:44,620
지금 이렇게 챕터별로 폴더를
만들어서 파일을 작성해 보고 있었죠

1943
02:04:44,660 --> 02:04:51,280
그래서 2-4가 튜플이니까 그러면
2-4.py라는 파이썬 파일을 만들어 줬고요

1944
02:04:52,040 --> 02:04:55,420
그러면 하나씩 위키독스를
보면서 실습을 해 보도록 하겠습니다

1945
02:04:55,600 --> 02:04:58,260
2-4 튜플 자료형을 보겠습니다

1946
02:04:59,060 --> 02:05:01,520
튜플은 리스트랑 거의 비슷하다고 나와있죠

1947
02:05:01,580 --> 02:05:02,580
진짜 거의 비슷합니다

1948
02:05:02,780 --> 02:05:04,240
튜플은 어떻게 만들까?

1949
02:05:04,640 --> 02:05:06,540
여러 가지 모습으로 생성할 수 있습니다

1950
02:05:06,980 --> 02:05:08,920
이게 튜플을 만드는 방법입니다

1951
02:05:09,540 --> 02:05:13,840
리스트를 만들 때는 대괄호를
쓰고 1, 2, 3 이렇게 썼었죠

1952
02:05:13,920 --> 02:05:15,420
튜플은 어떻게 만드냐?

1953
02:05:15,660 --> 02:05:16,876
괄호로 만듭니다

1954
02:05:16,900 --> 02:05:17,920
소괄호죠, 소괄호

1955
02:05:18,040 --> 02:05:20,617
얘는 대괄호고 얘는 소괄호로 만듭니다

1956
02:05:20,641 --> 02:05:25,580
그래서 소괄호를 열고 닫고 하는 걸로
이제 튜플이라는 데이터가 만들어지고요

1957
02:05:25,640 --> 02:05:28,740
바로 찍어보면 타입을 찍어 볼 수 있었죠

1958
02:05:28,820 --> 02:05:36,820
프린트 타입에 t1을 넣으면 실행을 해 보면 타입을 찍으면 이 자료형이
무슨 타입인지 볼 수 있는데 클래스는 튜플이란 걸 확인할 수가 있습니다

1959
02:05:37,920 --> 02:05:40,620
샵 만드는 단축키 이게 컨트롤 슬래시입니다

1960
02:05:40,800 --> 02:05:43,260
이렇게 이제 튜플을 만들어 볼 수가 있었고요

1961
02:05:43,340 --> 02:05:50,820
또 나머지 것들을 하나씩 보면 이렇게 하고 출력하면
그냥 이렇게 1이란 게 들어가고 없는 게 되는데 이것도 돼요

1962
02:05:51,060 --> 02:05:59,060
미리 좀 보자면 0번째 이렇게 인덱싱 리스트랑 거의 같은
개념이기 때문에 이렇게 뽑아올 수 있고 이거는 레인지가 없다, 이죠

1963
02:06:00,140 --> 02:06:01,220
뒤에 값은 없습니다

1964
02:06:01,440 --> 02:06:03,160
그러니까 1번 인덱스는 없는 거죠

1965
02:06:03,320 --> 02:06:05,880
하나의 값이 들어갈 때는 콤마가 들어가야 됩니다

1966
02:06:06,260 --> 02:06:14,260
튜플을 표현할 때는 그냥 괄호랑 헷갈릴 수 있으니까 콤마를 넣어줘야지 이게
튜플이다라는 걸 알 수 있으니 이렇게 하나의 값이 있을 때는 이렇게 써줍니다

1967
02:06:15,760 --> 02:06:19,980
그다음에 뭐 기본적으로 이렇게 만들 수도 있고 심지어
이렇게 만들 수도 있고 심지어 이렇게 만들 수도 있습니다

1968
02:06:42,140 --> 02:06:46,160
그리고 리스트랑 마찬가지로 튜플
안에 또 튜플을 넣을 수가 있습니다

1969
02:06:46,280 --> 02:06:50,240
여기도 보면 지금 튜플 안에 튜플이 또 들어가 있죠

1970
02:06:50,760 --> 02:06:55,020
그래서 이렇게 리스트랑 거의 특성이
비슷하다고 보시면 될 것 같습니다

1971
02:06:55,220 --> 02:06:58,620
그래서 튜플 만드는 방법에 대해서 간략하게 살펴봤고요

1972
02:06:58,740 --> 02:06:59,540
여기도 나와 있죠

1973
02:06:59,620 --> 02:07:03,857
T2 이런 거 하나의 요소를 넣을
때는 쉼표를 반드시 붙여야 된다

1974
02:07:03,881 --> 02:07:05,300
이거 기억하시면 좋을 것 같습니다

1975
02:07:05,440 --> 02:07:11,520
그러면 이제 변경이 불가능하다고 굉장히 강조를
드렸는데 지우려고 하면 어떻게 되는지 보도록 하겠습니다

1976
02:07:11,720 --> 02:07:13,360
그래서 이 코드를 한번 실행을 해보겠습니다

1977
02:07:13,960 --> 02:07:19,444
리스트 지난 시간에 기억나실지 모르겠지만
이렇게 del, delete 키를 쓰고 그다음에

1978
02:07:19,504 --> 02:07:25,600
t1의 0번째 인덱스, 즉 이거를 없애겠다고
하면 리스트는 그게 빠진 상태로 나왔죠

1979
02:07:25,660 --> 02:07:27,900
이거를 실행해 보면 이렇게 오류가 납니다

1980
02:07:28,160 --> 02:07:30,820
Tuple object doesn't
support item deletion.

1981
02:07:30,980 --> 02:07:33,160
Tuple은 삭제를 지원하지 않는다

1982
02:07:33,200 --> 02:07:36,740
즉 변경이 불가능하다고 알려주고 있습니다

1983
02:07:36,980 --> 02:07:41,520
그래서 tuple의 가장 큰 특징이 변경
불가능한 것이라고 보시면 되겠습니다

1984
02:07:41,740 --> 02:07:46,860
변경하면 안 될 값들의 데이터가 있을 때
그거를 tuple로 감싸서 만들고, 만들면 좋겠죠

1985
02:07:46,980 --> 02:07:50,020
그래서 이게 가장 큰 특징이라고 소개를 드릴 수 있겠고요

1986
02:07:50,100 --> 02:07:56,660
Tuple 다루기는 리스트랑 거의 같기 때문에 사실상 거의
리스트를 복습한다는 개념으로 보셔도 좋을 것 같습니다.

1987
02:07:56,820 --> 02:07:58,860
Tuple은 인덱싱, 슬라이싱 이런 게 다 됩니다

1988
02:07:59,080 --> 02:08:03,380
그래서 인덱싱부터 보면 그래서 이
0번째 프린트하면 똑같이 나옵니다

1989
02:08:03,440 --> 02:08:04,936
출력해 보면 1이 나오죠

1990
02:08:04,960 --> 02:08:05,500
0번째니까

1991
02:08:05,900 --> 02:08:09,620
1번째는 2가 나오겠고 3번째는 2가 나오겠죠

1992
02:08:09,740 --> 02:08:10,740
2, 3번이니까

1993
02:08:10,840 --> 02:08:15,157
이거는 리스트 복습을 해 보는
거랑 거의 똑같다고 볼 수가 있겠고요

1994
02:08:15,181 --> 02:08:16,620
슬라이싱하기도 됩니다

1995
02:08:16,860 --> 02:08:22,620
근데 여기서 아마 헷갈리는 분들이 좀 있을 텐데
슬라이싱이라고 하면 자른다는 느낌으로 보이잖아요

1996
02:08:22,720 --> 02:08:26,400
여기 t1 이거를 슬라이싱으로 자른다?

1997
02:08:26,500 --> 02:08:32,380
그러면 출력을 해 보면 이거 복습 겸 1,
땡땡 아무것도 없으면 이게 무슨 뜻일까요?

1998
02:08:32,520 --> 02:08:34,500
1번 인덱스 이상이죠

1999
02:08:34,620 --> 02:08:36,220
1번 인덱스가 이거죠

2000
02:08:36,280 --> 02:08:37,460
1번 인덱스 이상

2001
02:08:37,560 --> 02:08:39,720
그리고 끝까지 이렇게 자르는 거죠

2002
02:08:39,840 --> 02:08:41,220
그럼 2ab가 나오겠죠

2003
02:08:41,420 --> 02:08:44,860
이렇게 해서 실행을 해 보면 2ab가 나옵니다

2004
02:08:45,180 --> 02:08:47,156
근데 튜플인데 잘라도 되나?

2005
02:08:47,180 --> 02:08:48,520
라는 생각이 들 수가 있잖아요

2006
02:08:48,700 --> 02:08:56,700
프린트를 찍어 보면 이 슬라이싱을 한 다음에 다시 t1을 찍어
보면 슬라이싱된 거는 따로 선택을 해서 가져오는 개념이고요

2007
02:08:57,300 --> 02:08:59,200
그냥 t1은 변하지 않았습니다

2008
02:08:59,320 --> 02:09:02,560
잠깐 잘라서 보여준다라는
개념으로 기억하시면 좋을 것 같습니다

2009
02:09:02,820 --> 02:09:04,920
이게 좀 시각적이면 이해가 좋잖아요

2010
02:09:05,220 --> 02:09:13,220
이 사이트로 들어와서 실제로 튜플이 어떻게 생긴 것이며
그거를 변형한다는 거나 이런 게 무슨 말인지 같이 보도록 하겠습니다

2011
02:09:13,700 --> 02:09:16,140
여기서 보면은 이 t1인데 t1이라는 걸 정의했잖아요

2012
02:09:16,260 --> 02:09:19,860
그래서 t1이라는 걸 정의하면은
t1이라는 변수 얘가 상자입니다

2013
02:09:20,100 --> 02:09:26,760
얘 상자 안에 튜플이라는 이 리스트랑 거의
비슷하게 생긴 이런 데이터가 들어가 있는 거예요

2014
02:09:26,880 --> 02:09:29,340
그래서 넣는다의 개념이 이런 개념이고요

2015
02:09:29,480 --> 02:09:33,840
이 프린트 t 이거는 여기에
아무런 변형을 가하지가 않습니다

2016
02:09:33,960 --> 02:09:41,960
그냥 프린트로 이 t1에서 여기 1번째부터 1번째 이상
끝까지를 보여주는 것뿐이지 이거를 자르는 개념은 아닙니다

2017
02:09:44,120 --> 02:09:45,120
네

2018
02:09:45,180 --> 02:09:49,940
그래서 이런 것도 마찬가지 인덱싱도 이렇게
한다고 해서 이걸 자르는 개념이 아니잖아요

2019
02:09:50,080 --> 02:09:58,080
그래서 그냥 보여주는 개념이고 그러면 리스트랑 차이가 뭐냐
여기 t1에 0에 얘를 뭐 5로 바꾼다라고 하면 지금 오류가 났죠

2020
02:09:58,160 --> 02:10:04,180
그래서 튜플은 아이템 어사인먼트를 지원하지
않는다라고 나와 있는데 이걸 리스트로 바꿔보겠습니다

2021
02:10:04,440 --> 02:10:12,440
리스트로 바꾸면은 이렇게 리스트가 똑같이 있는데 이 리스트는
주석을 풀어서 0번을 5로 바꾸면 실제로 이 리스트가 바뀌었습니다

2022
02:10:13,401 --> 02:10:15,617
0번째 인덱스가 5로 바뀌었죠

2023
02:10:15,641 --> 02:10:22,300
그러니까 이전 단계에서는 이거 주석 처리했을
때는 1이었는데 이게 실제로 5로 바뀝니다

2024
02:10:22,360 --> 02:10:25,340
그래서 이렇게 보시면은 좀 더
이해하시기가 좋을 것 같습니다

2025
02:10:25,420 --> 02:10:26,980
이렇게 바뀌면 5로 실제로 바뀌었죠

2026
02:10:27,040 --> 02:10:31,060
이런 개념을 이제 시각화를 통해서
하나씩 소개를 드리도록 하겠습니다

2027
02:10:31,280 --> 02:10:35,100
그래서 튜플은 바꿀 수 없다라는
거를 좀 기억해 두시면 좋을 것 같고요

2028
02:10:35,180 --> 02:10:35,357
네

2029
02:10:35,381 --> 02:10:40,440
인덱싱 슬라이싱 그러면 이게 진짜 자르지 않다는
거를 좀 이해하시면 좋을 것 같고 더하기도 됩니다

2030
02:10:40,660 --> 02:10:40,980
어?

2031
02:10:41,060 --> 02:10:43,357
변형이 불가능하다는데 더하기가 어떻게 되나요?

2032
02:10:43,381 --> 02:10:44,400
라고 생각할 수 있잖아요

2033
02:10:44,480 --> 02:10:45,960
이거를 보여드리도록 하겠습니다

2034
02:10:46,220 --> 02:10:48,517
일단은 그냥 코드에서 실행해보면 네

2035
02:10:48,541 --> 02:10:55,260
이렇게 그럼 t1이 이렇게 튜플이 생긴 게 있고
t2가 있고 t1 더하기 t2를 하면은 리스트가 똑같죠

2036
02:10:55,320 --> 02:11:00,120
리스트라고 하면은 여기 a, b 뒤에 3, 4가
추가되는 형태일 텐데 튜플도 똑같습니다

2037
02:11:00,240 --> 02:11:01,957
그래서 프린트 t3를 해보면 네

2038
02:11:01,981 --> 02:11:03,240
이렇게 더해져서 나옵니다

2039
02:11:03,320 --> 02:11:04,000
근데 어?

2040
02:11:04,080 --> 02:11:04,780
의문이 들죠

2041
02:11:04,840 --> 02:11:07,680
왜 튜플은 변형 불가능하다는데 더하기가 어떻게 된 거지?

2042
02:11:07,780 --> 02:11:11,360
라고 생각해보면 하나씩 그러면
코드를 실행을 해보도록 하겠습니다

2043
02:11:11,880 --> 02:11:13,356
그래서 이때 시각화 도구가 좀 있습니다

2044
02:11:13,380 --> 02:11:14,180
도움이 되는 것 같아서

2045
02:11:14,320 --> 02:11:18,040
그럼 한 줄씩 코드를 만들어보면
먼저 t1은 이렇게 만들어졌어요

2046
02:11:18,140 --> 02:11:19,560
그리고 t2도 만들어보겠습니다

2047
02:11:19,820 --> 02:11:23,620
그러면 t2도 t2란 상자에 이렇게 나오게 됩니다

2048
02:11:23,800 --> 02:11:30,180
각각 다른 상자에 있는 거고 t3는 t1 플러스 t2라는
거는 여기 보시면은 새로운 튜플이 만들어진 겁니다

2049
02:11:30,360 --> 02:11:36,140
즉 더하기를 한다는 건 이 t1 자체로 들어가서
막 얘를 회집고 추가하고 이런 게 아니고요

2050
02:11:36,280 --> 02:11:42,700
그 t1, t2를 더해서 새로운 튜플을
만들어서 그거를 t3에 넣는다의 개념입니다

2051
02:11:42,900 --> 02:11:43,080
네

2052
02:11:43,380 --> 02:11:47,180
그래서 새로운 걸 만드는 거기
때문에 얘네는 변형이 되질 않았습니다

2053
02:11:47,320 --> 02:11:55,320
이 개념을 이해하시면 튜플은 실제로 변형되지 않는데 이제 리스트처럼
이렇게 더하고 슬라이싱하고 할 수도 있구나라는 걸 이해해 볼 수가 있겠습니다

2054
02:11:55,880 --> 02:12:01,080
질문에 좀 답변을 드리면 여기에 리스트
더하기 튜플은 되나요 했는데 타입 에러가 났죠

2055
02:12:01,120 --> 02:12:03,440
튜플을 더할 수 있는데 리스트는 안 된다라고 나오죠

2056
02:12:03,580 --> 02:12:07,020
어 이윤수님 t1, t2를 한
튜플 안에 넣을 수도 있나요?

2057
02:12:07,060 --> 02:12:08,520
그러니까 얘네는 변경이 불가능하거든요

2058
02:12:08,620 --> 02:12:13,057
아예 다른 거를 넣어서 상자를 바꿔치기
하거나 실제로 더하기는 안 됩니다

2059
02:12:13,081 --> 02:12:16,220
그러니까 실제로 더하기라는 건
얘를 변형해서 더하는 건 안 되고요

2060
02:12:16,320 --> 02:12:17,320
이런 건 가능합니다

2061
02:12:17,500 --> 02:12:19,860
T1, t2를 더해서 다시 t1에 넣는 거예요

2062
02:12:20,020 --> 02:12:22,220
그러니까 스탭별로 보면은 한 줄씩 볼게요

2063
02:12:22,320 --> 02:12:25,900
T1 만들고 t2 만들고 그럼 이렇게 각각 있죠

2064
02:12:26,060 --> 02:12:34,060
그러면 t1, t2가 만들어지고 그거를 다시 넣으면은
새롭게 생기면서 그거를 t1이라는 상자에 넣은 겁니다

2065
02:12:34,980 --> 02:12:38,440
그렇다는 거는 변형된 게 아니고
여기도 새로운 튜플이 생긴 겁니다

2066
02:12:38,760 --> 02:12:43,037
요거는 이제 변수 단원에서 좀 더 자세하게 설명드릴 텐데요

2067
02:12:43,061 --> 02:12:47,220
지금은 이렇게 새롭게 생긴다라고
생각하시면 좋을 것 같습니다

2068
02:12:47,880 --> 02:12:49,800
523대부님, sorted은 안 됩니다

2069
02:12:49,960 --> 02:12:53,080
이게 변형이 불가능해서 하면은 오류가 나네요

2070
02:12:53,500 --> 02:12:55,100
튜플은 sort가 없습니다

2071
02:12:55,420 --> 02:12:56,880
그다음에 튜플 곱하기도 됩니다

2072
02:12:57,120 --> 02:13:00,540
마찬가지로 변형이 아니라 새롭게 생성해서 넣는 개념입니다

2073
02:13:00,880 --> 02:13:06,060
요것도 리스트 기억나시면 아마 343434
반복되는 그대로 튜플이 보여주고 있죠

2074
02:13:06,180 --> 02:13:08,200
그래서 튜플은 거의 리스트랑 같습니다

2075
02:13:08,860 --> 02:13:12,577
정신차려님, 리스트랑 다른 점이 변형 유무 정도입니다

2076
02:13:12,601 --> 02:13:15,480
변형이 불가능하다 정도고 나머지는 똑같습니다

2077
02:13:15,520 --> 02:13:17,160
그리고 길이 구하기도 똑같습니다

2078
02:13:17,280 --> 02:13:21,260
Sort 랭을 하면 리스트에서도 쓸
수 있었고 스트링에서도 쓸 수 있었죠

2079
02:13:21,300 --> 02:13:22,880
그래서 이렇게 하면 4가 나옵니다

2080
02:13:23,100 --> 02:13:28,040
대신에 또 특징이 변형이 불가능하다라는
그 큰 특징 때문에 이런 게 안 됩니다

2081
02:13:28,180 --> 02:13:32,260
아까 sort 안 되고 insert,
remove, pop 이런 것들이 안 됩니다

2082
02:13:32,440 --> 02:13:34,920
그래서 이런 내장 함수가 쓸 수가 없습니다

2083
02:13:35,440 --> 02:13:37,160
네, 이렇게 해서 튜플을 배워봤습니다

2084
02:13:37,440 --> 02:13:44,220
지금은 이렇게 튜플이 조금 헷갈릴 수 있는데 뒤에
변수 배우면서 다시 한 번 설명을 드리도록 하겠습니다

2085
02:13:44,420 --> 02:13:47,540
그 다음에 이제 dictionary라는
자료형을 배워보도록 하겠습니다

2086
02:13:47,740 --> 02:13:50,440
아마 아시는 분들 아시겠지만 사전이라는 뜻입니다

2087
02:13:50,600 --> 02:13:53,000
정말 그 사전의 특징을 갖고 있어요

2088
02:13:53,140 --> 02:13:59,420
나이가 어리신 분들은 이거를 잘 못 보신 분도 있을 텐데
그러니까 사전을 펼쳐보면 단어가 있고 단어에 대한 뜻이 있잖아요

2089
02:13:59,680 --> 02:14:06,200
요즘엔 다 네이버 사전이나 이런 걸 쓸 텐데 사전이 이렇게
어떤 단어가 있고 그거에 대한 뜻이 이렇게 달려있잖아요

2090
02:14:06,360 --> 02:14:09,637
키 값이 있고 그에 대한 밸류라는 값이 있습니다

2091
02:14:09,661 --> 02:14:17,661
그냥 사전처럼 단어가 있고 그 단어에 대한 뜻이 있는 것처럼 어떤 키가
되는 어떤 단어라는 값이 있고 그리고 그걸 설명하는 밸류라는 값이 있습니다

2092
02:14:18,420 --> 02:14:26,420
그래서 다른 언어를 혹시 배우신 분들은 hash라던가
map이라던가 object라던가 json, 자바스크립트의

2093
02:14:26,658 --> 02:14:32,620
object랑 json 데이터 이런 것들이 다
dictionary랑 같은 형태라고 보시면 됩니다

2094
02:14:32,800 --> 02:14:39,557
그래서 키 밸류로 이루어진 자료를 말하는데 이것도
서랍장처럼 좀 예시를 설명드리면 좀 쉬울 것 같은데요

2095
02:14:39,581 --> 02:14:43,260
A라는 변수가 사물함이라고 생각하시면 좋을 것 같습니다

2096
02:14:43,380 --> 02:14:45,380
이름표가 붙어있는 사물함인 거죠

2097
02:14:45,540 --> 02:14:53,540
예를 들어 이렇게 사물함이 있다고 하면 이렇게 민지 사물함을 열어보면
2004라는 숫자가 들어있고 뭐 다니엘을 열어보면 2005고 이렇게 각각

2098
02:14:53,901 --> 02:14:58,560
이름에 맞는 값을 가지고 있을 때
이런 거를 dictionary라고 부릅니다

2099
02:14:58,700 --> 02:15:02,360
언제 활용되냐라고 보면 api에 자주 활용됩니다.

2100
02:15:02,760 --> 02:15:08,080
Api에서 데이터를 json으로 전송한다
이런 얘기를 많이 들으실 거예요

2101
02:15:08,140 --> 02:15:09,560
아마 실제로 웹개발 강의를 들어보셨을 텐데요

2102
02:15:10,720 --> 02:15:13,580
Json이라는 것도 사실 그
dictionary의 한 형태입니다

2103
02:15:13,720 --> 02:15:19,960
실제 이런 데이터를 보면 이름은 홍길동
그리고 나이는 25 성별은 여자 이런 거 있죠

2104
02:15:20,060 --> 02:15:25,340
그 키 지표가 있고 그에 대한 값이 있고
이렇게 되어 있는 게 dictionary 자료형입니다

2105
02:15:25,500 --> 02:15:28,400
그럼 여기 특기는 하고 여기에 리스트가 들어가 있죠

2106
02:15:28,480 --> 02:15:34,391
이런 식으로 특기라는 키에 농구와 도술이
특기일 때 이렇게 두 가지 데이터도 들어갈 수 있는

2107
02:15:34,415 --> 02:15:39,536
이런 키 밸류로 구성된 이런 자료를
json이라고도 부르는데 이거랑 같은 형태가 있어요

2108
02:15:39,560 --> 02:15:41,620
파이썬에서는 dictionary라고 부릅니다.

2109
02:15:41,720 --> 02:15:45,560
Dictionary 자료형 위키독스를
보면서 진행을 해보도록 하겠습니다

2110
02:15:45,820 --> 02:15:51,740
사람은 누구든지 이름은 홍길동 생일은 몇 월 며칠
등 사람이 가진 정보를 이렇게 나타낼 수가 있겠죠

2111
02:15:51,900 --> 02:15:53,000
키와 밸류로

2112
02:15:53,060 --> 02:15:56,280
그래서 그런 자료형을
dictionary라고 파이썬에서는 부릅니다

2113
02:15:56,400 --> 02:16:01,320
그리고 연관 배열이라고도 하고 hash라고도
하고 같은 개념이라고 보시면 될 것 같습니다.

2114
02:16:01,940 --> 02:16:09,300
Dictionary란 말 그대로 사전이라는 뜻이고 베이스볼은
야구다 이런 영한 사전 이런 것처럼 키와 밸류로 구성된

2115
02:16:09,560 --> 02:16:11,520
그런 데이터라고 보시면 되겠습니다

2116
02:16:11,660 --> 02:16:16,120
그럼 dictionary 예제를 하나 붙여넣어
보면서 코드로 보도록 하겠습니다

2117
02:16:16,420 --> 02:16:18,400
이번에는 중괄호를 씁니다

2118
02:16:18,480 --> 02:16:26,480
아까 리스트는 대괄호 그리고 튜플은 소괄호였는데 dictionary는
중괄호를 쓰고 그 다음에 이 안에 키와 밸류를 콜론을 통해서 구분해서 키,

2119
02:16:29,680 --> 02:16:36,600
밸류, 또 콤마, 키, 밸류, 콤마,
키, 밸류 이런 형태로 쓰게 됩니다

2120
02:16:36,800 --> 02:16:44,800
이게 dictionary다 라고 설명드릴 수 있겠고 프린트를 찍어서
타입을 보면 실제로 이렇게 dictionary라고 나온 것을 확인할 수 있죠

2121
02:16:45,400 --> 02:16:48,840
그리고 그냥 출력해 봐도 이거 그대로 나오게 됩니다

2122
02:16:49,040 --> 02:16:52,620
그래서 dictionary는 이렇게 만든다
라고 이해하시면 좋을 것 같습니다

2123
02:16:52,740 --> 02:16:54,180
일단 큰 개념 설명은 드렸고요

2124
02:16:54,320 --> 02:16:59,520
이 키가 될 수 있는 것도 하나 더 만들어 보면
하나만 만들 때 이런 식으로 만들어 볼 수도 있겠습니다

2125
02:16:59,940 --> 02:17:03,740
하나만 있을 때는 이렇게 표현하고
이렇게 만들어 볼 수가 있겠습니다

2126
02:17:03,920 --> 02:17:05,800
그리고 밸류에 리스트도 넣을 수 있습니다

2127
02:17:06,000 --> 02:17:13,900
그래서 a라는 변수에 a라는 key를 넣고 밸류로 리스트
이렇게 넣을 수도 있고 리스트는 여러 개를 넣을 수도 있습니다

2128
02:17:14,000 --> 02:17:15,900
이 안에 또 dictionary를 또 넣을 수도 있어요

2129
02:17:16,040 --> 02:17:20,760
그 다음에 이제 dictionary의 특성들을 하나씩
실습을 하면서 진행을 해 보도록 하겠습니다.

2130
02:17:21,080 --> 02:17:24,980
Dictionary에 새로운 값을 추가하려면
어떻게 해야 되냐를 알아보도록 하겠습니다.

2131
02:17:25,540 --> 02:17:29,500
A라는 dictionary가 있으면 여기에 새로운
값을 한번 추가를 해 보도록 하겠습니다

2132
02:17:30,080 --> 02:17:32,380
새로운 값을 추가하려면 이렇게 하면 됩니다

2133
02:17:33,280 --> 02:17:38,457
A에 e라는 key를 추가하고 여기에
대한 밸류를 이렇게 추가하면 됩니다

2134
02:17:38,481 --> 02:17:46,481
그러면 프린트 A를 해보면, 1이라는 키, A라는 밸류 밖에 없었는데,
이제는 2라는 키, B라는 밸류를 이렇게 추가를 해줄 수가 있었습니다

2135
02:17:48,060 --> 02:17:50,780
그러면 이게 꼭 1, 2, 3을 따라가야 되냐?

2136
02:17:50,840 --> 02:17:51,840
그렇진 않습니다

2137
02:17:52,180 --> 02:17:57,300
여기에 빠진파뇨님이 채팅을
쳐주셔서 이렇게 쳐드리도록 하겠습니다

2138
02:17:58,020 --> 02:17:59,480
이렇게 추가가 됩니다

2139
02:17:59,800 --> 02:18:02,580
그러니까 키와 밸류가 어디에 들어가냐?

2140
02:18:02,640 --> 02:18:03,717
그 위치의 차이지

2141
02:18:03,741 --> 02:18:10,431
이런 식으로 여기에 대괄호 안에 키가
들어가고, 여기에 밸류가 들어가면, 이걸

2142
02:18:10,455 --> 02:18:16,120
실행해봤을 때 이렇게 콤마 뒤쪽으로
키와 밸류가 이렇게 추가가 되게 됩니다

2143
02:18:16,320 --> 02:18:21,360
이렇게 추가할 수 있다는 거 기억을 해두시고,
이렇게 리스트도 추가할 수가 있겠습니다

2144
02:18:22,020 --> 02:18:24,580
여기에 리스트도 밸류로 추가할 수 있습니다

2145
02:18:24,720 --> 02:18:32,720
그러니까 키, 여기 대괄호 안에 키를 넣고, 여기 밥스로 밸류를
넣으면, 그게 키 밸류 형태로 이렇게 딕셔너리에 추가가 됩니다

2146
02:18:33,181 --> 02:18:40,460
그전에 리스트랑 좀 비교해보면 리스트에 추가할
때는 여기도 거의 리스트랑 겹치는 부분이 많습니다

2147
02:18:40,560 --> 02:18:43,040
리스트 바꿔치기 할 때 이런 거 했었죠

2148
02:18:43,080 --> 02:18:51,080
그래서 a의 0번째를 5로 바꾼다 할 때 이렇게
선택하고 값을 넣어서 바꿔줄 수가 있었잖아요

2149
02:18:51,360 --> 02:18:54,160
딕셔너리는 추가할 때 이런 식으로 사용을 하게 됩니다

2150
02:18:54,740 --> 02:18:56,100
그 다음에 삭제하는 걸 해보겠습니다

2151
02:18:56,420 --> 02:19:01,077
딕셔너리에 어떤 키밸류 데이터가 있으면
그거를 삭제할 때 진행을 해보도록 하겠습니다

2152
02:19:01,101 --> 02:19:03,240
이것도 거의 리스트랑 비슷합니다

2153
02:19:03,640 --> 02:19:09,460
Del 키워드를 써서 a에 그러면
삭제할 요소의 키를 선택해주면 됩니다

2154
02:19:09,680 --> 02:19:10,800
그럼 키가 뭐냐?

2155
02:19:10,840 --> 02:19:13,240
이 콜론 앞에 있는 것들이 키죠

2156
02:19:13,720 --> 02:19:16,100
키를 이용해서 선택을 해서 지울 수가 있습니다

2157
02:19:16,580 --> 02:19:21,360
예를 들어 이거 세 번째 네임 이 한
쌍을 지우고 싶으면 키로 선택을 합니다

2158
02:19:21,600 --> 02:19:24,180
키로 선택한다는 건 네임을 선택하면 되겠죠

2159
02:19:24,260 --> 02:19:31,076
그리고 프린트 a를 해보면 이렇게 지금
네임은 페이라는 게 없어진 것을 확인합니다

2160
02:19:31,100 --> 02:19:35,520
그래서 이렇게 삭제를 할 수 있다라고 소개를 드렸습니다

2161
02:19:35,780 --> 02:19:36,460
어?

2162
02:19:36,540 --> 02:19:38,580
여러 개를 한 번에 삭제할 수도 있나요?

2163
02:19:38,860 --> 02:19:45,300
이은수님께서 질문 주셨는데 그냥 delete 키에 여러 개를
이렇게 콤마로 나열하면 한 번에 삭제를 할 수도 있겠습니다

2164
02:19:45,600 --> 02:19:50,180
이제 딕셔너리를 실제로 활용하려면 어떻게
활용하게 되냐 이거를 보도록 하겠습니다

2165
02:19:50,480 --> 02:19:57,200
딕셔너리에서 키를 사용해서 밸류를 얻기 그러니까 어떤 데이터를
저장해 놨으면 이걸 가져오고 변형하고 이런 걸 할 수 있어야 되잖아요

2166
02:19:57,380 --> 02:19:59,860
Grade라는 데이터가 있으면 뭐 성적이겠죠

2167
02:20:00,020 --> 02:20:01,057
그래서 페이라는 사람을 사용하면 되죠

2168
02:20:01,081 --> 02:20:06,004
줄리엣이라는 사람은 10점이고 줄리엣이라는
사람은 99점이고 이런 데이터를 저장할 때 사용이

2169
02:20:06,028 --> 02:20:12,100
되는데 점수를 가지고 오고 싶다라고
하면 print grade에 대괄호에 키를 써줍니다

2170
02:20:12,160 --> 02:20:17,276
페이라는 키를 써주면 이렇게
10이라는 밸류를 가져올 수가 있었죠

2171
02:20:17,300 --> 02:20:20,180
그러니까 이 데이터를 가져와서 여기에 밸류를 얻고 싶다

2172
02:20:20,220 --> 02:20:23,640
이렇게 키를 통해서 밸류를 가져올 수가 있겠습니다

2173
02:20:23,920 --> 02:20:24,920
너무 뻔하죠

2174
02:20:25,020 --> 02:20:32,380
거의 비슷한 예제인데 a에 1이라는 키로 가져오면 당연히
a가 나올 거고 그럼 2라는 키로 가져오면 당연히 b가 나오죠

2175
02:20:32,420 --> 02:20:34,280
그럼 없는 걸 가져오면 어떻게 될까요?

2176
02:20:34,440 --> 02:20:36,000
이게 3을 가져온다

2177
02:20:36,060 --> 02:20:37,500
근데 3이라는 키가 없죠

2178
02:20:37,560 --> 02:20:38,940
지금 여기서는 이렇게 오류가 납니다

2179
02:20:39,180 --> 02:20:39,780
Key error

2180
02:20:39,940 --> 02:20:45,480
여기에 이런 딕셔너리에 이런 키가 없는데
어떤 걸 찾는 거야 라고 오류를 뱉어냅니다

2181
02:20:45,660 --> 02:20:50,800
그래서 키를 통해서 밸류를 찾을 수 있는 이런
딕셔너리를 이렇게 활용을 할 수가 있겠습니다

2182
02:20:51,140 --> 02:20:53,800
이런 데이터 이제 약간 실전에서 어떻게 쓰이냐

2183
02:20:53,860 --> 02:20:55,040
이런 식으로 씁니다

2184
02:20:55,220 --> 02:20:57,180
그 정보가 이런 식으로 날라와요

2185
02:20:57,220 --> 02:21:02,200
Json 데이터 아까 말씀드렸는데 이런
딕셔너리 데이터도 json이랑 똑같은 형태입니다

2186
02:21:02,340 --> 02:21:03,340
그래서 이렇게 생겼습니다

2187
02:21:03,540 --> 02:21:05,660
그래서 어떤 회원 정보 같은 게 넘어오잖아요

2188
02:21:05,840 --> 02:21:13,820
이 회원의 이름, 전화번호, 생년월일 이런 데이터가
쫙 json 형태 즉 이런 딕셔너리 형태로 날아오게 되고요

2189
02:21:13,980 --> 02:21:17,700
이거를 이제 하나씩 쪼개서 사용해야 될 일이 많습니다

2190
02:21:18,260 --> 02:21:19,640
그래서 쪼개서 사용한다는 건 뭐냐

2191
02:21:19,820 --> 02:21:21,480
이름을 따로 가져오고 싶어요

2192
02:21:21,560 --> 02:21:26,758
그러면 어떻게 해야 되냐면 print
dictionary에 name이라는 key를 입력하면

2193
02:21:26,782 --> 02:21:31,420
key에 해당하는 이름에 해당하는 실제 이
사람의 이름을 가져와서 출력을 해주겠죠

2194
02:21:31,500 --> 02:21:38,766
이렇게 pay라고 출력하고 그럼 전화번호를
가져오려면 이렇게 phone이라고 쓰면 전화번호를 가져올

2195
02:21:38,790 --> 02:21:45,780
수 있고 또 생년월일 birth를 출력하라고 하면 이
데이터에 생년월일을 이렇게 가져올 수가 있겠죠.

2196
02:21:46,120 --> 02:21:49,980
Value를 이용해서 키 찾기 할
수는 있는데 다 불러올 수 있잖아요

2197
02:21:50,200 --> 02:21:56,227
이게 뒤에 나올 수 있는데 뭐 반복문 이용해서
각각 키들을 다 살피거나 아니면 items라고 그

2198
02:21:56,251 --> 02:22:02,140
value들만 쫙 가져올 수도 있고 거기서 찾을
수는 있는데 그냥 기본 기능으로 제공하지는 않아요

2199
02:22:02,240 --> 02:22:04,760
그래서 할 수는 있지만 절차가 필요하다

2200
02:22:04,880 --> 02:22:06,820
그렇게 말씀드릴 수 있겠습니다

2201
02:22:07,440 --> 02:22:09,220
한 번에 여러 개 가져올 수 있나요?

2202
02:22:09,700 --> 02:22:14,960
Birth랑 phone을 한 번에 가져와서 프린트를
하고 싶다라고 하면 이렇게 그냥 두 번 써주면 되겠죠.

2203
02:22:15,220 --> 02:22:18,140
Birth랑 전화번호 이렇게 가져올 수가 있었습니다

2204
02:22:18,320 --> 02:22:19,520
그리고 주의사항이 있습니다

2205
02:22:20,060 --> 02:22:25,560
Dictionary의 가장 큰 특징을 설명해보자면
key를 통해 value를 찾는다잖아요

2206
02:22:25,720 --> 02:22:28,557
같은 key가 있으면 안 되겠다는 생각이 들죠.

2207
02:22:28,581 --> 02:22:33,647
Key를 통해 value를 찾는데 예를
들어 name이 철수도 있고 name이

2208
02:22:33,671 --> 02:22:38,280
영희도 있고 라고 하면 name을 불러오면
어떤 값을 가져와야 될지 모를 거잖아요

2209
02:22:38,320 --> 02:22:42,980
그래서 어떤 값을 가져와야 될지 모르기
때문에 key는 무조건 하나여야 됩니다.

2210
02:22:43,360 --> 02:22:46,640
A라는 dictionary가
있는데 얘는 지금 key가 같죠

2211
02:22:46,740 --> 02:22:52,620
그래서 1이라는 key에 a라는 value도 있고
또다시 1이라는 key에 b라는 value가 있어요

2212
02:22:52,780 --> 02:22:54,460
그럼 이게 좀 말이 안 되죠

2213
02:22:54,540 --> 02:22:57,357
그래서 실제로 실행을 해보면 하나만 남습니다

2214
02:22:57,381 --> 02:23:03,420
이렇게 두 개를 정의했는데 실제로 이
a를 출력해보면 뒤에 거 하나만 남아요

2215
02:23:03,460 --> 02:23:05,060
왜냐하면 이제 덮어써진 거죠

2216
02:23:05,260 --> 02:23:09,680
사실 1이라는 key에 b라는 value가
들어있는데 이걸 덮어써버린 겁니다

2217
02:23:09,900 --> 02:23:13,240
그래서 이렇게 주의사항을 꼭
기억을 해두시면 좋을 것 같고요

2218
02:23:13,360 --> 02:23:17,760
그래서 key는 중복되면 안 되고 또
다른 특징은 key가 변형되면 안 됩니다.

2219
02:23:18,000 --> 02:23:21,940
Key를 통해서 value를 찾기
때문에 그 key가 변하면 안 되거든요

2220
02:23:22,140 --> 02:23:25,038
그렇다는 거는 mutable, immutable
잠깐 소개를 드렸는데 그렇다는 거는

2221
02:23:25,062 --> 02:23:29,460
mutable, immutable 잠깐 소개를
드렸는데 여기 list 자료형이 들어왔어요

2222
02:23:29,500 --> 02:23:37,500
근데 list는 제가 ppt에서 설명드린 것처럼 list는
대표적으로 mutable, 즉 변형이 가능한 자료형입니다

2223
02:23:38,100 --> 02:23:42,280
이렇게 값을 추가하거나 삭제하거나 이런 걸 할 수가 있었죠

2224
02:23:42,820 --> 02:23:47,169
그렇다는 거는 이렇게 변형이 가능한
거기 때문에 key를 통해서 value를

2225
02:23:47,193 --> 02:23:51,580
찾아야 되는 dictionary 특성상 이런
게 key로 들어가 있으면 안 좋겠죠

2226
02:23:52,000 --> 02:23:54,520
그래서 이렇게 하면 오류가 납니다

2227
02:23:54,680 --> 02:23:57,160
Type error가 났는데 unhashable type.

2228
02:23:57,380 --> 02:24:05,380
Iist라고 돼 있는 게 이 key가 list여서 이게 변형 가능한 자료이기
때문에 이런 자료는 지금 key로 사용할 수 없다라는 에러를 보여주고 있죠

2229
02:24:07,260 --> 02:24:09,360
변형 가능한 거는 쓸 수가 없다

2230
02:24:09,480 --> 02:24:13,560
즉 immutable 자료형을 써야
된다라고 말씀드릴 수 있겠습니다

2231
02:24:13,900 --> 02:24:16,500
이렇게 해서 dictionary 주의사항을 같이 살펴봤고요

2232
02:24:17,050 --> 02:24:19,620
그다음에 dictionary 관련
함수를 보도록 하겠습니다.

2233
02:24:20,120 --> 02:24:21,740
Keys라는 게 있는데요

2234
02:24:22,000 --> 02:24:25,980
이거를 보면 a.keys라는 함수를 사용하면 뭐가 나오냐

2235
02:24:27,480 --> 02:24:29,136
안쪽에 list가 들어있죠.

2236
02:24:29,160 --> 02:24:36,180
Name, font, verse라는 게 나와 있는데 이게 어떤 걸 한
거냐면 아마 결과를 보시면 아시겠지만 이 key들 name, font,

2237
02:24:36,300 --> 02:24:43,060
verse만 따로 모아서 얘를 뭉쳐서 하나의
list로 만드는 그런 명령어가 keys 명령어입니다

2238
02:24:43,100 --> 02:24:45,440
그래서 이렇게 list로 하나에 만드는 게 keys고요

2239
02:24:45,560 --> 02:24:51,940
여기 좀 특징이 있는데 dictkeys라는 객체
return한다라고 돼 있는데 이렇게 돼 있죠.

2240
02:24:52,040 --> 02:24:53,040
Dictkeys

2241
02:24:53,140 --> 02:24:54,200
이게 그럼 뭐냐

2242
02:24:54,240 --> 02:24:57,940
사실 파이썬 이전 버전에서는 이게 그냥 list로 나왔어요

2243
02:24:58,020 --> 02:25:03,660
그래서 이걸 list로 변형해보면 list로 변형하려면
이렇게 list라는 함수로 감싸하면 됩니다.

2244
02:25:03,860 --> 02:25:09,657
Iist 괄호 열고 괄호 닫고를 하면 얘가
list로 변형돼서 이렇게 나오는데 이

2245
02:25:09,681 --> 02:25:14,900
list보다 좀 메모리를 덜 차지하는 그런
자료를 만들어가지고 일부러 넣었습니다

2246
02:25:15,060 --> 02:25:21,020
왜냐하면 보통 이렇게 keys를 할 때는 반복문을
쓰기 위해서 이 keys를 하는 경우가 많거든요

2247
02:25:21,260 --> 02:25:25,836
근데 이거는 지금 소개해드리기에는
반복문을 모르는 상태에서 보면 헷갈리실 거예요

2248
02:25:25,860 --> 02:25:31,504
그냥 이렇게 keys라고 하면 이 keys를
담은 list가 나오는데 그 list를 좀 더

2249
02:25:31,528 --> 02:25:36,540
자료를 아끼기 위해서 이렇게 dictkeys라는
자료로 나온다라고 이해하시면 좋을 것 같습니다

2250
02:25:36,680 --> 02:25:41,000
그래서 특징은 거의 list랑 비슷한데 좀
간략하다 정도로 이해하시면 좋을 것 같습니다

2251
02:25:41,120 --> 02:25:42,840
파이썬 3 이후에 추가된 겁니다

2252
02:25:43,020 --> 02:25:51,020
그래서 반복문에 쓰이는데 한번 그냥 잠깐 이거는 뒤에
배울 개념이니까 예시로 간략하게만 보면 반복문이라는 게

2253
02:25:51,616 --> 02:25:59,236
있는데 그 각각 그 딕셔널을 하나씩 돌면서 모든 걸 다
꺼내서 꺼내오려면 이런 for문이라는 반복문을 씁니다

2254
02:25:59,260 --> 02:26:05,458
그래서 이거는 지금 이해하기보다는 바로
실행만 해보면 이렇게 name, font, verse를 하나씩

2255
02:26:05,482 --> 02:26:10,460
가져와서 출력을 할 때 이렇게 keys들이 뭐가
있는지 전체 list를 뽑아오고 싶을 수 있잖아요

2256
02:26:10,660 --> 02:26:13,640
그래서 그때 이런 a.keys라는 거를 사용하게 됩니다

2257
02:26:13,900 --> 02:26:18,380
이렇게 배워도 그냥 그렇구나 정도로
이해한 다음에 나중에 다 개념들이 합쳐집니다

2258
02:26:18,460 --> 02:26:21,120
그래서 list 변환하려면 이렇게 list로 감싸면 되고요

2259
02:26:21,220 --> 02:26:26,200
그다음에 values만 뽑아오고 싶다라고
하면 이렇게 .values를 쓰면 됩니다.

2260
02:26:26,840 --> 02:26:30,840
Pay하고 010 어쩌고 전화번호
나오고 그리고 날짜가 나오죠

2261
02:26:30,900 --> 02:26:38,900
즉 여기 있는 값들만 따로 모아서 values는 여기 있는 값들만
따로 모아서 이거를 하나의 list로 만든 거라고 보시면 되겠습니다

2262
02:26:40,700 --> 02:26:43,600
그다음에 key와 value 쌍으로 얻는 방법이 있습니다

2263
02:26:43,800 --> 02:26:45,060
쌍으로 얻으려면 어떻게 하냐

2264
02:26:45,520 --> 02:26:46,800
Items라는 걸 쓰면 됩니다.

2265
02:26:47,020 --> 02:26:50,260
A.items라고 함수를 쓰면 어떻게 되냐

2266
02:26:50,340 --> 02:26:51,340
이렇게 됩니다

2267
02:26:52,040 --> 02:26:55,240
Dictitems라는 어떻게 되냐면 list가 생기고요

2268
02:26:55,340 --> 02:27:03,340
그리고 각각 key values들이 이렇게 tuple에 들어가서 쭉쭉쭉
반복되는 각각 다 뽑아져서 나오는 것을 확인할 수가 있습니다

2269
02:27:05,720 --> 02:27:08,920
그래서 이렇게 뽑아주는 것이 items라는 함수입니다

2270
02:27:09,180 --> 02:27:16,600
그래서 이걸 왜 배우나라는 생각이 들 텐데 이게 다 반복문에서는
이걸 써야지 되게 편리하게 자료들을 뽑아볼 수가 있거든요

2271
02:27:16,860 --> 02:27:21,315
그래서 이건 좀 뒤에 나올 개념이랑
연결이 돼서 지금은 조금 이해 안 갈 수 있어도

2272
02:27:21,339 --> 02:27:25,861
이런 게 있구나 하고 넘어가시면 나중에
반복문 할 때 쭉쭉쭉 다 사용이 됩니다

2273
02:27:25,960 --> 02:27:28,480
그다음에 key values 상 모두 지우기가 있습니다

2274
02:27:28,620 --> 02:27:36,620
이거는 delete랑 같은데 이제 한 번에 다 지울 때 모든 걸 지울 때는
a.clear를 하게 되면 이거는 clear라는 함수고 그래서 printa를

2275
02:27:39,321 --> 02:27:45,597
뒤에서 다시 해보면 a라는 dictionary가 있는데
이거를 clear한 다음에 실행해 보니까 dictionary가 나왔죠

2276
02:27:45,621 --> 02:27:51,137
긴 dictionary가 나오게 clear라는 걸 쓰면 값을
싹 다 날린다라고 이해하시면 좋을 것 같습니다

2277
02:27:51,161 --> 02:27:54,476
그래서 이렇게 dictionary에 쓰일
수 있는 함수들을 살펴봤습니다.

2278
02:27:54,500 --> 02:28:00,000
Key로 value 얻기 중에 이제 key로
value 얻는 기본은 이렇게 a의 name 이렇게

2279
02:28:00,024 --> 02:28:06,180
dictionary를 가져와서 대괄호를 쓰고 여기 안에
key를 넣으면 그 해당하는 value를 가져올 수 있잖아요.

2280
02:28:06,360 --> 02:28:07,360
Pay라는 거 이렇게

2281
02:28:07,460 --> 02:28:09,800
근데 이렇게 안 쓰고 다른 방법도 있습니다

2282
02:28:10,080 --> 02:28:11,860
Get이라는 함수를 쓸 수가 있습니다

2283
02:28:12,360 --> 02:28:17,980
.Get을 쓰고 여기에 key를 입력해 주면
name이라는 key를 입력해 주면 두 개의 값이 갖죠

2284
02:28:18,020 --> 02:28:18,700
출력된 값이

2285
02:28:18,760 --> 02:28:22,800
그렇다는 거는 이거랑 이거랑
사실상 같은 기능을 하고 있는 겁니다

2286
02:28:22,980 --> 02:28:24,700
차이가 있다면 어떤 게 있냐

2287
02:28:24,780 --> 02:28:27,540
없는 key를 쓸 때 차이가 발생하는데요

2288
02:28:27,680 --> 02:28:30,040
예를 들어 high라는 key가 지금 없죠

2289
02:28:30,080 --> 02:28:30,220
여기에

2290
02:28:30,300 --> 02:28:34,800
처음 배운 방식으로 이렇게 대괄호 안에
key를 넣는 방식을 해보면 key 에러가 났죠.

2291
02:28:34,880 --> 02:28:39,460
High라는 key가 없어라고 에러를
뱉어 주는데 get을 쓰면 어떻게 되냐

2292
02:28:39,540 --> 02:28:40,540
오류가 안 납니다

2293
02:28:40,680 --> 02:28:43,140
오류가 안 나고 none이라는 값이 나오죠

2294
02:28:43,220 --> 02:28:48,240
그래서 이렇게 get을 쓰면 none이라는 값이
나오고 그냥 대괄호를 쓰면 key 에러가 난다

2295
02:28:48,320 --> 02:28:52,180
이거는 이전에 배운 그
index랑 find의 차이랑 비슷하죠.

2296
02:28:52,540 --> 02:28:57,360
String에서 쓸 수 있는 그런 함수
중에 index랑 find의 차이가 오류가

2297
02:28:57,384 --> 02:29:01,340
나냐 아니면 안 나냐의 차이였는데
이거랑 비슷한 개념이라고 보시면 되겠습니다

2298
02:29:01,580 --> 02:29:03,940
Get으로 값을 얻는 거 또 배워봤고요

2299
02:29:04,040 --> 02:29:06,340
그래서 차이는 오류에 나는 여부다

2300
02:29:06,380 --> 02:29:07,900
라고 설명드릴 수 있겠습니다

2301
02:29:08,080 --> 02:29:15,300
또 약간 get은 또 응용해 볼 수 있는 게 있는데 high라는 값을
찾아보고 없다면 어떤 거를 돌려줄지도 정해줄 수가 있습니다

2302
02:29:15,600 --> 02:29:17,920
그냥 없으면 지금은 none이라는 값을 줬잖아요

2303
02:29:18,060 --> 02:29:21,660
근데 이렇게 안 하고 콤마를 쓰고
이런 메시지를 써줄 수도 있겠죠

2304
02:29:21,800 --> 02:29:24,700
값이 없습니다라는 걸 돌려주고 싶어요

2305
02:29:24,780 --> 02:29:26,160
이렇게 프린트를 해주고 싶어요

2306
02:29:26,240 --> 02:29:31,840
그렇다는 건 high라는 건 일단 찾아보고
high가 없으면 값이 없습니다를 리턴해

2307
02:29:31,900 --> 02:29:38,720
리턴은 이제 함수 뒤에 배울 건데 아무튼 돌려줘 라는
개념인데 이걸 실행해보면 이렇게 값이 없습니다라고 나옵니다

2308
02:29:38,760 --> 02:29:43,460
왜냐하면 high가 들어갔기 때문에 여기에 그러면
phone 이런 게 들어가면 이렇게 전화번호가 나오죠

2309
02:29:43,500 --> 02:29:50,660
왜냐하면 값이 없지 않기 때문에 이 뒤에 거가 출력이 안 되고
값이 없을 때만 출력하는 것을 이 get 뒤에 넣어줄 수가 있습니다

2310
02:29:51,120 --> 02:29:54,140
그래서 get은 좀 더 다양한
기능을 활용할 수가 있겠습니다

2311
02:29:54,380 --> 02:29:55,260
또 이런 것도 있습니다

2312
02:29:55,400 --> 02:29:59,640
해당 키 안에 dictionary가 있는지
조사하기 in이라는 키워드를 쓸 수가 있는데요

2313
02:29:59,880 --> 02:30:05,193
그 해당 키가 존재하는지를 뭐 이렇게
get을 써서 이 뒤에 설정한 값이 나오게 할

2314
02:30:05,217 --> 02:30:09,540
수도 있고 아니면 오류를 뱉게 할 수도
있는데 더 간편하게 볼 수 있는 방법도 있습니다

2315
02:30:09,800 --> 02:30:17,800
이렇게 name이라는 값이 a에 있니라고 그냥 in이라는 키워드를
통해서 이 name이라는 키가 a에 있나라고 검사를 해볼 수가 있습니다

2316
02:30:18,441 --> 02:30:21,240
이렇게 검사를 해보면 실제로 name이라는 키가 있죠

2317
02:30:21,340 --> 02:30:23,920
그렇기 때문에 true라는 값이 나옵니다

2318
02:30:23,980 --> 02:30:30,196
이거는 뒤에 불 자료형을 배울 때도 배울 텐데
in이라는 키워드를 쓰면 이게 있는지 없는지가

2319
02:30:30,220 --> 02:30:35,040
true 혹은 false로 나와서 이렇게 두
가지 중에 하나의 값을 얻을 수가 있습니다

2320
02:30:35,260 --> 02:30:36,440
그러면 없는 거 한번 넣어볼까요?

2321
02:30:36,540 --> 02:30:38,580
뭐 hi 다시 넣으면 false가 나오죠

2322
02:30:38,620 --> 02:30:43,700
그래서 true false가 나오도록 이렇게 in이라는
키워드로 되게 간편하게 검사를 할 수도 있습니다

2323
02:30:43,920 --> 02:30:51,920
그러면 이제 dictionary 한번 쭉 배워봤는데 dictionary랑
list랑 조금 비교해서 생각해보면 사실은 list가 dictionary에

2324
02:30:54,261 --> 02:30:59,000
index가 0, 1, 2로 시작되는
dictionary라고 생각하셔도 편할 것 같아요

2325
02:30:59,160 --> 02:31:02,920
그래서 어떤 말이냐면 이거 list할 때 많이 썼었죠

2326
02:31:02,980 --> 02:31:07,100
그러니까 a는 1, 2, 3 이렇게
쓰면 a에 0 이렇게 가져오잖아요

2327
02:31:07,300 --> 02:31:11,680
그러면 0번째가 1이니까 이렇게
이렇게 1을 가져오게 되잖아요

2328
02:31:11,900 --> 02:31:15,037
근데 이게 사실 개념이 이거랑 비슷합니다

2329
02:31:15,061 --> 02:31:22,524
Dictionary로 바꿔버리고 이게 0, 1, 2
이렇게 되면 그러면 0이라는 키에 1이라는

2330
02:31:22,548 --> 02:31:27,000
value가 들어가 있고 1이라는 키에
2라는 value가 들어가 있고 이런 형태잖아요

2331
02:31:27,120 --> 02:31:29,960
그래서 이거랑 거의 비슷하게 쓸 수가 있습니다

2332
02:31:30,420 --> 02:31:31,420
3이 나오겠죠

2333
02:31:31,480 --> 02:31:32,240
왜냐하면 2번째니까

2334
02:31:32,440 --> 02:31:38,030
그래서 이런 거랑 비슷하게 볼 수 있는데 물론
method나 이런 건 좀 다르기 때문에 다른데 좀 개념을

2335
02:31:38,054 --> 02:31:43,837
이해하실 때 이렇게 key value라는 개념이 좀
안 와 닿으시다면 list에도 이런 비슷한 걸 했었다

2336
02:31:43,861 --> 02:31:45,800
라고 생각하시면 좋을 것 같습니다

2337
02:31:45,960 --> 02:31:49,660
그래서 이 리스트랑 좀 비교를 통해서 한번 복습을 해봤고요

2338
02:31:49,760 --> 02:31:52,400
그 다음에 집합을 나가보도록 하겠습니다

2339
02:31:52,640 --> 02:31:59,840
한국 사람들이 집합을 가장 잘한다고 하던데 예전에는
막 이랑 중학교 수학도 가장 첫 단원이 집합이었죠

2340
02:31:59,900 --> 02:32:05,280
아마 요즘 교육과정은 어떻게 바뀌었는지
모르겠는데 아마 많은 분들이 집합은 잘 아실 것 같습니다

2341
02:32:05,480 --> 02:32:11,020
근데 학창시절이 좀 오래되신 분들은 약간 기억이 안
날 수 있는데 개념을 짚어드리면 집합의 특성이 있었죠

2342
02:32:11,080 --> 02:32:18,540
이런 집합이 있다고 하면은 a는 1, 2고
b가 2, 3이면 이렇게 표시할 수가 있죠

2343
02:32:18,640 --> 02:32:19,500
이거 기억나시나요?

2344
02:32:19,600 --> 02:32:22,580
같은 걸 공유하는 게 교집합이고 이게 교집합이죠

2345
02:32:22,760 --> 02:32:28,400
아무튼 이런 교집합, 합집합, 여집합
이런 개념을 파이썬에 구현해놨습니다

2346
02:32:28,540 --> 02:32:30,080
다른 언어에서는 이런 게 없거든요

2347
02:32:30,220 --> 02:32:36,640
기본 자료형으로 들어있지는 않고 만들거나 불러와서
써야 되는데 이런 집합을 파이썬은 자료형으로 제공합니다

2348
02:32:36,820 --> 02:32:39,020
그래서 굉장히 편리하게 쓸 수가 있습니다

2349
02:32:39,320 --> 02:32:44,780
집합 자료형은 집합에 관련된 것을
쉽게 처리하기 위해서 만든 자료형입니다

2350
02:32:44,880 --> 02:32:48,380
그래서 집합을 set이라고 영어로
부르는데 키워드로 쓸 수가 있겠습니다

2351
02:32:48,540 --> 02:32:49,920
그래서 집합은 어떻게 만드냐?

2352
02:32:49,980 --> 02:32:51,200
이렇게 만들 수 있습니다

2353
02:32:51,280 --> 02:32:54,920
두 가지 방법, 뭐 더 여러 가지도
있는데 하나씩 보도록 하겠습니다

2354
02:32:55,340 --> 02:33:03,340
이거는 다른 데서도 비슷하게 뭐 리스트로 바꾼다 하면
리스트로 감싸주고 스트링 자료형으로 바꾼다 하면 str로

2355
02:33:03,602 --> 02:33:10,460
감싸주고 이런 것처럼 집합 자료형을 리스트로부터 만들
수도 있고 뭐 스트링으로부터 만들 수도 있고 그렇습니다

2356
02:33:10,580 --> 02:33:13,280
이렇게 안에는 지금 대괄호로 된 리스트가 들어있죠

2357
02:33:13,860 --> 02:33:15,960
그거를 set이라는 함수로 감쌌습니다

2358
02:33:16,040 --> 02:33:21,820
프린트 S1을 해보면 중괄호, 아까 딕셔너리
배울 때 중괄호의 키 밸류로 구성된 게 딕셔너리였죠

2359
02:33:21,900 --> 02:33:27,780
근데 얘는 키 밸류가 아니라 그냥 값들이 쭉
들어있는 이런 것을 집합, set 자료형이라고 부릅니다

2360
02:33:27,900 --> 02:33:31,400
그래서 타입을 찍어보면 이렇게
클래스가 set인 걸 확인할 수 있죠

2361
02:33:31,520 --> 02:33:33,780
그러면 이렇게 만드는 방법 말고 또 뭐 있냐?

2362
02:33:33,840 --> 02:33:35,340
그냥 이대로 넣어도 됩니다

2363
02:33:36,120 --> 02:33:44,120
딕셔너리는 키 밸류가 꼭 들어가야 된다면 그냥 이렇게 중괄호 안에
키 밸류 없이 그냥 하나의 값들만 쭉 쓰면 이거가 집합의 의미가 됩니다

2364
02:33:45,320 --> 02:33:50,420
괄호로 바꿔서 만들 수도 있고 그냥 아예
중괄호로 여러 가지 요소를 넣어서 만들 수가 있습니다

2365
02:33:50,740 --> 02:33:54,960
여기 문자열 자료형을 넣으면
set으로 바꾸면 똑같이 집합이 됩니다

2366
02:33:55,180 --> 02:34:00,160
근데 여기서 좀 특징을 볼 수가 있는데
hello라는 문자열을 집합으로 바꿔보겠습니다

2367
02:34:00,480 --> 02:34:01,540
그러면 어떻게 되냐?

2368
02:34:01,580 --> 02:34:03,320
한번 출력을 해보면 이렇게 됩니다

2369
02:34:03,500 --> 02:34:05,240
굉장히 좀 뭐가 달라졌죠?

2370
02:34:05,360 --> 02:34:13,360
그러니까 집합은 집합인데 이 문자열 자료형을 각각 하나씩
나눠서 그거를 만들었는데 지금 hello라는 것은 l이 두 개잖아요

2371
02:34:14,660 --> 02:34:17,460
근데 여기 집합에서는 l이 하나밖에 없습니다

2372
02:34:17,840 --> 02:34:21,700
이게 글자가 총 다섯 글자인데 여기는 네 글자밖에 없죠

2373
02:34:21,780 --> 02:34:22,840
이게 어떻게 된 거냐?

2374
02:34:22,880 --> 02:34:24,360
이 순서도 뒤죽박죽이죠

2375
02:34:24,540 --> 02:34:26,860
그래서 이게 어떻게 된 거냐면 집합의 특성이 그렇습니다

2376
02:34:27,000 --> 02:34:30,820
집합은 아까도 그림에서 보셨다시피 순서가 딱히 없습니다

2377
02:34:31,100 --> 02:34:39,100
여기에 어떤 값들이 1, 3, 5 이렇게 집합 안에 들어
있다고 하면 그 순서가 원래 집합이라는 개념은 없습니다

2378
02:34:40,080 --> 02:34:43,560
그게 어떤 a라는 영역 안에 들어있는 값들인 거지

2379
02:34:43,860 --> 02:34:45,180
특별히 집합에는 순서가 없습니다

2380
02:34:45,400 --> 02:34:53,100
그렇기 때문에 아까 출력을 해봤을 때 순서 없이 이렇게 랜덤하게
나오게 되는 이유가 집합이기 때문에 그 특성이 반영돼서 그렇습니다

2381
02:34:53,240 --> 02:34:54,960
실행할 때마다 지금 바뀌는 걸 볼 수가 있죠

2382
02:34:55,100 --> 02:34:56,260
그래서 순서를 알 게 없습니다

2383
02:34:56,580 --> 02:34:58,560
그래서 얘는 이렇게 접근을 못하죠

2384
02:34:58,660 --> 02:35:00,940
인덱스로 접근한다는 게 말도 안 됩니다

2385
02:35:01,100 --> 02:35:06,760
왜냐하면 특별히 순서가 정해진 게 아니기 때문에
집합의 개념, 이 그림을 통해 생각하시면 더 편할 것 같아요

2386
02:35:06,860 --> 02:35:11,197
여기 1, 2, 3이 있다고 해서
이게 어떤 순서로 있는 게 아닙니다

2387
02:35:11,221 --> 02:35:13,660
그리고 이렇게 만들 수 있다는 걸 배워봤고요

2388
02:35:13,760 --> 02:35:17,300
Hello 이렇게 쪼개지되 순서도
바뀌고 그리고 중복된 걸 제거됩니다

2389
02:35:17,680 --> 02:35:22,360
또 집합의 큰 특징 중에 하나가
집합은 원소가 각각 고유하죠

2390
02:35:22,480 --> 02:35:25,580
그래서 1, 2, 2, 3 이런 게 있지 않습니다

2391
02:35:25,880 --> 02:35:30,500
집합에서는 각 원소가 고유해서 중복을 허용하지 않습니다

2392
02:35:30,640 --> 02:35:32,400
중복된 거는 없어지게 되겠죠

2393
02:35:32,520 --> 02:35:33,540
하나만 남게 됩니다

2394
02:35:33,660 --> 02:35:34,180
중복된 거는

2395
02:35:34,280 --> 02:35:35,600
중복을 허용하지 않는다

2396
02:35:35,780 --> 02:35:37,620
순서가 없다는 큰 특징이 있습니다

2397
02:35:37,800 --> 02:35:40,597
그래서 이걸 이용해서 이런 것들을 할 수가 있어요

2398
02:35:40,621 --> 02:35:44,940
그래도 이렇게 집합을 만들었는데
얘를 안 쓰기가 너무 아까운 거예요

2399
02:35:45,040 --> 02:35:51,560
그래서 프린트 S1을 해보면 이렇게 있는데
이걸 굳이 어떤 값을 좀 가져오고 싶어요

2400
02:35:51,640 --> 02:35:52,640
그럴 수가 있겠죠

2401
02:35:52,700 --> 02:35:53,840
그럴 때는 어떻게 하냐

2402
02:35:53,920 --> 02:35:55,420
리스트로 감싸줍니다

2403
02:35:55,520 --> 02:35:58,740
리스트로 감싸주면 이게 자료형을 변환하는 거죠

2404
02:35:58,900 --> 02:36:04,740
그러면 이제 S1 자료형이 리스트로
바뀌게 될 텐데 출력해보면 리스트가 돼버리죠

2405
02:36:04,820 --> 02:36:08,760
그래서 이걸 이용해서 이제
여기서 값을 뽑아낼 수가 있겠습니다

2406
02:36:08,980 --> 02:36:13,840
그래서 집합 자료형은 이렇게 있는데 인덱싱 할
수가 없다라고 좀 소개를 드릴 수가 있겠습니다

2407
02:36:13,960 --> 02:36:16,760
또 특징이 뭐 이거 당연히 튜플로도 바꿀 수 있습니다

2408
02:36:16,920 --> 02:36:23,800
튜플 배웠는데 튜플도 이렇게 바꿔서
찍어보면 이렇게 튜플로도 바꿀 수가 있겠습니다

2409
02:36:24,660 --> 02:36:29,000
그래서 집합에서 뭐 값을 선택하고
인덱싱하고 이러려면 데이터 변환을 해야 된다

2410
02:36:29,440 --> 02:36:30,880
그러면 이 집합을 왜 쓰냐

2411
02:36:31,500 --> 02:36:33,920
집합에서 할 수 있는 되게 좋은 것들 있죠

2412
02:36:34,300 --> 02:36:39,620
예를 들어 집합을 배울 때 막 교집합이니
합집합이니 이런 거를 배우잖아요

2413
02:36:40,620 --> 02:36:41,620
교직 제거할 때도 많이 쓰입니다

2414
02:36:41,740 --> 02:36:49,680
그러면 교집합, 합집합, 차집합 이런 개념들을 되게 쉽게 활용할
수 있게 함수를 제공해주고 뭐 자료형에서 제공해주는 게 있습니다

2415
02:36:49,860 --> 02:36:51,140
그래서 하나씩 보도록 하겠습니다

2416
02:36:51,380 --> 02:36:55,139
일단 집합 두 개를 놓고 1,
2, 3, 4, 5, 6, 4, 5, 6, 7, 8,

2417
02:36:55,163 --> 02:37:00,100
9가 있으면 이거를 어떻게 활용할 수
있는지 S & E 교집합 구하기를 해보겠습니다

2418
02:37:00,460 --> 02:37:03,920
그래서 프린트 S & 기호 있죠

2419
02:37:04,020 --> 02:37:06,600
이거 쉬프트하고 7번 누르면 나오는 거

2420
02:37:06,640 --> 02:37:08,240
이 & 기호를 쓰면 어떻게 되냐

2421
02:37:08,800 --> 02:37:09,800
교집합이 나옵니다

2422
02:37:10,540 --> 02:37:15,420
교집합이라고 하면 이 두 개
S1, S2 집합에서 겹치는 부분이죠

2423
02:37:15,500 --> 02:37:19,240
그러니까 그림으로 보면 교집합
기억을 떠올려 보시면 이 부분이죠

2424
02:37:19,320 --> 02:37:19,620
이 부분

2425
02:37:19,740 --> 02:37:24,500
이 겹치는 부분은 이 A와 B가 둘
다 가지고 있는 거를 가져오면 되겠죠

2426
02:37:24,800 --> 02:37:30,500
그래서 그거는 1, 2, 3, 4, 5, 6이고 4, 5, 6,
7, 8, 9니까 4, 5, 6, 2 이렇게 두 개 겹치죠

2427
02:37:30,580 --> 02:37:31,940
이게 교집합이 이렇게 나옵니다

2428
02:37:31,980 --> 02:37:34,220
그래서 이렇게 굉장히 간단한 기호로 쓸 수가 있어요

2429
02:37:34,440 --> 02:37:40,800
이거 다른 언어에서 하려면 꽤 하나씩 막 비교하고 굉장히
어려울 텐데 얘는 이렇게 기호 하나로 간단하게 할 수가 있습니다

2430
02:37:40,920 --> 02:37:42,220
아니면 이런 것도 있어요

2431
02:37:42,740 --> 02:37:44,720
Intersection이라는 함수도 제공해요

2432
02:37:44,840 --> 02:37:50,505
그래서 Intersection이라는 함수를 사용하면
이 & 기호랑 똑같은 건데 Intersection을

2433
02:37:50,529 --> 02:37:56,100
쓰고 괄호 열고 닫고를 통해서
S1.IntersectionS2를 하면 이것도 똑같습니다

2434
02:37:56,200 --> 02:37:58,720
출력을 해보면 이렇게 교집합이 구해지게 되죠

2435
02:37:58,780 --> 02:38:03,200
그래서 집합의 개념을 활용해야 될 일이
있을 때는 파이썬만큼 편리한 게 없습니다

2436
02:38:03,580 --> 02:38:07,140
교집합 구했으면 나머지 합집합,
차집합 이런 것도 보도록 하겠습니다

2437
02:38:08,560 --> 02:38:10,100
합집합은 이렇게 쓰면 됩니다

2438
02:38:11,240 --> 02:38:13,700
Backslash에 Shift를 누르면
이걸 출력할 수 있습니다.

2439
02:38:14,200 --> 02:38:17,440
Shift를 누르고 Backslash를
누르면 이렇게 출력이 됩니다.

2440
02:38:17,900 --> 02:38:22,080
Shift Backslash를 누르면 이게 그냥
Backslash이고 Shift Backslash면 이렇게 됩니다

2441
02:38:22,540 --> 02:38:24,940
이걸 쓰면 이제 합집합이 됩니다

2442
02:38:25,760 --> 02:38:32,340
합집합은 어떤 개념인지 보면 1, 2, 3, 4, 5, 6,
4, 5, 6, 7, 8, 9가 있으면 4, 5, 6은 겹치잖아요

2443
02:38:32,520 --> 02:38:35,380
그러니까 겹치는 거는 한 번만 포함해서 나오는 거죠

2444
02:38:35,500 --> 02:38:37,000
왜냐하면 다시 그림으로 보면

2445
02:38:37,140 --> 02:38:39,420
합집합은 이게 합집합의 개념이죠

2446
02:38:39,500 --> 02:38:44,920
그래서 A, B를 다 출력하고 대신 중복되는
거는 나오면 안 되니까 한 번만 나오게 되겠죠

2447
02:38:45,040 --> 02:38:48,520
그리고 마찬가지로 union이라는 함수를 써도 됩니다

2448
02:38:48,800 --> 02:38:54,300
그래서 union이라는 함수를 써보면 이렇게
똑같이 결과가 나오는 걸 확인할 수 있습니다

2449
02:38:54,600 --> 02:38:56,876
그래서 union, intersection 다 영어잖아요

2450
02:38:56,900 --> 02:39:00,360
그래서 영어를 좀 쓰시는 분들은 되게 직관적일 거예요

2451
02:39:00,440 --> 02:39:00,540
더

2452
02:39:00,740 --> 02:39:04,457
그래서 그냥 교집합, 합집합 그대로 쓰는 형태가 되겠죠

2453
02:39:04,481 --> 02:39:05,580
그럼 차집합 구하기

2454
02:39:05,900 --> 02:39:07,140
차집합 기억나시나요?

2455
02:39:07,540 --> 02:39:11,240
차집합은 약간 빼기의 개념인데 A 빼기 B 같은 개념이죠

2456
02:39:11,400 --> 02:39:16,360
그래서 A에서 B를 뺀 개념이니까 이렇게 이게 차집합입니다

2457
02:39:16,960 --> 02:39:18,780
차집합은 정말 직관적입니다

2458
02:39:19,460 --> 02:39:21,200
빼기라는 기호로 표시를 할 수가 있어요

2459
02:39:21,460 --> 02:39:24,700
그래서 S 빼기 2를 하면 이렇게 1, 2, 3이 남죠

2460
02:39:24,760 --> 02:39:25,960
왜 1, 2, 3이 남냐?

2461
02:39:26,040 --> 02:39:33,817
1, 2, 3, 4, 5, 6이라는 집합이니까 그중에 겹치는 거 4, 5,
6이 겹치니까 얘가 날아가고 그다음에 1, 2, 3만 남게 되겠죠

2462
02:39:33,841 --> 02:39:39,040
그래서 이렇게 집합 그림이랑 같이
생각해보시면 좀 더 이해하시기 좋을 것 같습니다

2463
02:39:39,180 --> 02:39:41,580
그럼 S2 빼기 S1 하면 어떻게 될까요?

2464
02:39:41,840 --> 02:39:46,980
이렇게 차집합을 하면 7, 8, 9가 나오는데
순서는 바뀌어서 나온 거 확인할 수 있죠

2465
02:39:47,040 --> 02:39:50,780
7, 8, 9가 남고 4, 5, 6만 날아가서
이렇게 나올 수가 있겠습니다

2466
02:39:51,320 --> 02:39:52,160
굉장히 쉽죠

2467
02:39:52,220 --> 02:39:59,280
이게 다른 언어에서 구하려면 말도 안 되는 되게 어렵게 막
복잡하게 해야 되는데 얘는 진짜 간단하게 할 수가 있겠습니다

2468
02:40:00,140 --> 02:40:01,320
Difference라는 함수도 있습니다

2469
02:40:01,520 --> 02:40:03,797
그래서 빼기라는 기호로 직관적일 거예요

2470
02:40:03,821 --> 02:40:10,717
직관적으로 알 수 있지만 difference를 통해서
S2에서 difference S1을 하게 되면 똑같이 이렇게 8,

2471
02:40:10,741 --> 02:40:14,720
9, 7 이게 순서는 바뀌었는데 7,
8, 9가 나온 걸 볼 수가 있겠습니다

2472
02:40:14,880 --> 02:40:17,800
그다음에 집합도 마찬가지로
함수들을 좀 살펴보도록 하겠습니다

2473
02:40:18,460 --> 02:40:24,760
더하고 업데이트, 수정하고 리무브 이런
거를 해줄 수 있는데 하나씩 보도록 하겠습니다

2474
02:40:25,100 --> 02:40:28,940
일단 더하는 거, 집합에 값
추가하는 거 이런 거 너무 많죠

2475
02:40:29,040 --> 02:40:33,317
그래서 이것도 리스트나 이런 것처럼 어떻게 추가할 수 있냐

2476
02:40:33,341 --> 02:40:35,220
Add라는 키워드로 쓸 수 있습니다

2477
02:40:35,320 --> 02:40:36,700
리스트는 append였죠

2478
02:40:36,760 --> 02:40:37,960
근데 얘는 add입니다

2479
02:40:38,480 --> 02:40:41,000
그래서 이걸 막 구구절절 외워야 되냐는 아닙니다

2480
02:40:41,040 --> 02:40:45,840
왜냐하면 집합이 있는데 여기에 값을 추가할 때
어떻게 했지라고 검색해보면 이런 거 다 나오잖아요

2481
02:40:46,040 --> 02:40:53,060
아니면 채찍피티에 질문하면 나오고 그렇기 때문에
그냥 이런 게 있구나 아신 다음에 그걸 찾아서 쓰시면 됩니다

2482
02:40:53,460 --> 02:41:00,757
Add라는 키워드로 S1에 add 4를 하면 print
S1을 하면 이렇게 추가된 채로 나오게 됩니다

2483
02:41:00,781 --> 02:41:03,260
그리고 업데이트도 해보도록 하겠습니다

2484
02:41:03,460 --> 02:41:08,640
이게 여러 개를 추가할 때 print 그러니까
add는 하나씩 값을 추가할 때 add고요

2485
02:41:09,000 --> 02:41:15,220
업데이트는 이렇게 통째로 여러 개를 한 번에
추가할 때 456을 추가하려면 업데이트를 씁니다

2486
02:41:15,320 --> 02:41:21,200
123에 여러 개 456을 추가된
123456이라는 집합이 생긴 걸 볼 수가 있죠

2487
02:41:21,340 --> 02:41:25,820
여기서 약간 또 응용을 해보면 이렇게
두 개를 추가하면 이게 어떻게 될까요

2488
02:41:25,900 --> 02:41:30,677
리스트는 이렇게 두 개가 되지만 여기
집합으로 넘어오면 중복이 제거가 되죠

2489
02:41:30,701 --> 02:41:33,940
왜냐하면 원소는 고유해야 되니까 add 쓰면 오류 날까요.

2490
02:41:34,020 --> 02:41:35,680
Add를 한 번 써보도록 하겠습니다.

2491
02:41:35,720 --> 02:41:37,040
Add 쓰면 오류가 납니다

2492
02:41:37,180 --> 02:41:42,830
왜냐하면 리스트기 때문에 add는 고유하게
이렇게 하나씩 값을 추가해야 되는데 이렇게

2493
02:41:42,854 --> 02:41:47,520
추가해야 되지만 이제 업데이트는 여러 개의
리스트를 한 번에 추가를 할 수가 있겠습니다

2494
02:41:47,740 --> 02:41:52,160
특정 값 제거하기 제거하기는
remove라는 함수를 쓰면 됩니다

2495
02:41:52,380 --> 02:41:54,340
여기에 remove 2를 하면 어떻게 되냐.

2496
02:41:54,400 --> 02:41:57,720
Print 여기서 착각하시면 안
되는 게 이게 인덱스가 아닙니다

2497
02:41:57,760 --> 02:41:59,797
인덱스가 아니고 실제 값입니다

2498
02:41:59,821 --> 02:42:01,160
왜냐하면 인덱스가 없죠

2499
02:42:01,200 --> 02:42:01,580
집합에는

2500
02:42:01,700 --> 02:42:04,680
이렇게 보면 1, 3만 남고 그 값이 날아가게 됩니다

2501
02:42:05,000 --> 02:42:08,880
그래서 이렇게 다 살펴봤는데 아까
이거 설명을 좀 덜 드린 것 같아요

2502
02:42:09,000 --> 02:42:11,400
언제 자주 활용하냐 이런 게 있습니다

2503
02:42:11,860 --> 02:42:14,620
예를 들어 리스트를 만들었는데 l1이라고 할게요

2504
02:42:14,820 --> 02:42:17,720
얘를 1, 2, 2, 3, 3, 3, 4

2505
02:42:18,040 --> 02:42:23,740
그런데 리스트로 계속 활용하고 싶은데 고유한
하나씩만 남기고 싶을 때 집합을 많이 사용합니다

2506
02:42:23,900 --> 02:42:28,877
Set으로 감싸서 얘를 집합으로 만들면
이게 집합이 돼서 중복이 다 제거가 돼요

2507
02:42:28,901 --> 02:42:32,060
이걸 중복을 싹 제거하고 고유한 거 하나씩만 남게 됩니다

2508
02:42:32,200 --> 02:42:33,460
왜냐하면 집합의 특성이니까

2509
02:42:33,560 --> 02:42:39,440
그러면 다시 또 이거를 집합으로써 활용하기보다는
이걸 리스트로써 활용하고 싶을 수 있잖아요

2510
02:42:39,640 --> 02:42:41,840
그러면 다시 리스트로 이렇게 감싸줍니다

2511
02:42:42,000 --> 02:42:45,680
그러면 이렇게 활용을 해볼 수가 있겠습니다

2512
02:42:46,180 --> 02:42:52,500
그럼 이 리스트가 중복이 싹 제거된 상태로 4개
값만 남게 되는 이런 리스트로 바꿀 수가 있겠습니다

2513
02:42:52,740 --> 02:42:54,700
중복 제거되면 순서도 랜덤이 되나요?

2514
02:42:54,800 --> 02:42:56,877
그런데 사실 순서가 랜덤이 되긴 하거든요

2515
02:42:56,901 --> 02:42:58,880
왜냐하면 집합을 거칠 때 랜덤이 되니까

2516
02:42:58,960 --> 02:43:02,740
그런데 다시 리스트로 바꾸면
이거를 어느 정도 유지하긴 합니다

2517
02:43:02,900 --> 02:43:05,880
이거는 그래도 파이썬이 어느 정도 반영을 해주는 것 같아요

2518
02:43:06,040 --> 02:43:13,620
이게 원래 실제로 완전 집합 진짜 만든다면 랜덤으로 나와야
되는데 이렇게 set으로 감쌌다 리스트로 하면 그 순서는 유지가 됩니다

2519
02:43:14,000 --> 02:43:16,120
그래서 집합 자료형을 끝냈습니다

2520
02:43:16,180 --> 02:43:18,960
어떻게 활용할지까지 해서 끝낼 수가 있었습니다

2521
02:43:19,700 --> 02:43:22,600
그다음에 불 자료형에 대해서 살펴보도록 하겠습니다

2522
02:43:22,860 --> 02:43:24,460
불 자료형은 정말 간단합니다

2523
02:43:24,660 --> 02:43:25,417
참 거짓

2524
02:43:25,441 --> 02:43:27,840
들 나타내는 자료형이 불 자료형입니다

2525
02:43:27,940 --> 02:43:31,280
불린 자료형의 약자로 이제 불이라고 줄여서 부르고요

2526
02:43:31,360 --> 02:43:35,880
그리고 약간 TMI인데 약간 지적
허용심이 좀 충족이 되고 싶은 분들이 있죠

2527
02:43:36,000 --> 02:43:40,160
소개를 드리면 불리언 자료형은 이제
불리언의 약자라서 이제 불이라고 쓰고요

2528
02:43:40,260 --> 02:43:42,120
이게 놀랍게도 사람 이름입니다

2529
02:43:42,340 --> 02:43:45,780
조지 불이라는 분을 이름에서 따왔다고 합니다

2530
02:43:46,240 --> 02:43:54,240
그래서 이분을 보니까 굉장한 영국의 수학자 논리학자인데 엄청난
논리적인 이분의 이름을 기려서 불이라는 걸 여기서 따왔다고 합니다

2531
02:43:55,640 --> 02:43:58,320
그래서 조지 불에서 따온 게 불리언이다

2532
02:43:58,420 --> 02:43:59,840
그래서 불 자료형이라 부르고요

2533
02:43:59,960 --> 02:44:01,980
그래서 논리라 하면 트루폴스잖아요

2534
02:44:02,480 --> 02:44:03,820
트루폴스를 의미합니다

2535
02:44:04,000 --> 02:44:05,600
그래서 보면 언제 활용되냐

2536
02:44:05,660 --> 02:44:13,420
뭔가 지금 개념이 트루폴스 이게 어디 쓰이는 거지라고 할 수 있는데
뒤에서 나오는 개념을 미리 땡겨서 소개를 해드리면 이런 게 있습니다

2537
02:44:13,640 --> 02:44:20,137
앞에서 잠깐 소개해드렸는데 등호를 쓰면
넣는다의 개념이고 등호 두 개가 되면 이게 같니?

2538
02:44:20,161 --> 02:44:22,837
라고 하면서 값이 트루 아니면 폴스가 나와요

2539
02:44:22,861 --> 02:44:27,980
여기에 이게 트루인지 아니면 폴스인지가 나오게 됩니다

2540
02:44:28,140 --> 02:44:31,500
여기에 만약 트루가 된다면 if문 안에서 쓰입니다

2541
02:44:31,720 --> 02:44:39,720
그래서 if 트루라면 이걸 실행해라 라는 조건문과 반복문을 쓸
수가 있는데 그때 사용되는 게 이제 불 자료형이 그때 쓰입니다

2542
02:44:41,660 --> 02:44:45,420
그래서 참과 거짓이다 라고 이해하시면 좋을 것 같고요

2543
02:44:45,520 --> 02:44:48,640
A는 트루인데 이게 스트링이랑 달라요

2544
02:44:48,680 --> 02:44:55,920
그러니까 스트링으로 그냥 쓰려면 이렇게 대괄호에 트루
이렇게 쓰는 게 이거랑 같냐라고 생각할 수 있는데 같지 않습니다

2545
02:44:56,000 --> 02:44:58,340
왜냐하면 얘는 따옴표가 없죠

2546
02:44:58,380 --> 02:45:04,380
그래서 따옴표가 없는 상태로 출력을 해보면 얘는
트루라고 나오긴 하는데 이 스트링 트루랑 다릅니다

2547
02:45:04,660 --> 02:45:08,340
타입을 찍어보면 타입을 찍어보면 얘는 불 자료형이에요

2548
02:45:08,420 --> 02:45:11,780
불 자료형이고 이 타입은 불리한 자료형입니다

2549
02:45:11,940 --> 02:45:14,020
그래서 얘도 폴스도 마찬가지고요

2550
02:45:14,060 --> 02:45:17,300
근데 여기서 중요한 건 맨 앞에가 무조건 대문자여야 됩니다

2551
02:45:17,480 --> 02:45:20,437
대문자가 아니고 소문자로 쓴다 하면은 오류가 납니다

2552
02:45:20,461 --> 02:45:25,645
이게 false가 잘못 쓴 거 아니야
하고 name error가 났는데 이거는 첫

2553
02:45:25,669 --> 02:45:30,521
글자를 대문자로 써줘야 이제 불
자료형인 true나 false를 쓰는 개념이 됩니다

2554
02:45:30,580 --> 02:45:36,300
이거 등호 두 개를 쓰는 거 잠깐 소개해드렸는데
등호 두 개를 쓰면은 이게 불 자료형이 나옵니다

2555
02:45:36,400 --> 02:45:38,200
1은 a는 1이라는 거

2556
02:45:38,260 --> 02:45:40,760
1이라는 값을 넣는다의 개념이죠

2557
02:45:40,840 --> 02:45:41,520
A라는 상자에

2558
02:45:41,580 --> 02:45:43,636
등호가 두 개면 이게 같니?

2559
02:45:43,660 --> 02:45:44,660
하고 물어보는 겁니다

2560
02:45:44,720 --> 02:45:46,236
그래서 1은 1이랑 같니?

2561
02:45:46,260 --> 02:45:48,400
라고 물어보면 a를 출력해보겠습니다

2562
02:45:48,500 --> 02:45:49,637
그러면 true라고 나오죠.

2563
02:45:49,661 --> 02:45:51,860
True라고 나오는 게 이게 등호 두 개이기 때문입니다

2564
02:45:51,900 --> 02:45:52,976
그럼 1은 2랑 같니?

2565
02:45:53,000 --> 02:45:54,000
라고 물어보면 뭐가 나옵니까?

2566
02:45:54,100 --> 02:45:54,840
False가 나오죠

2567
02:45:54,900 --> 02:45:58,480
그래서 이렇게 등호 두 개를
이용해서 true false를 만들 수도 있다

2568
02:45:58,560 --> 02:46:00,500
라는 거를 설명을 드렸고요

2569
02:46:00,640 --> 02:46:01,200
부등호 있죠

2570
02:46:01,280 --> 02:46:01,600
부등호

2571
02:46:01,680 --> 02:46:02,900
1은 2보다 크니?

2572
02:46:02,940 --> 02:46:04,420
라고 하면 false가 나오죠

2573
02:46:04,480 --> 02:46:07,456
그래서 이렇게 부등호도 반대로 하면 2가 1보다 크니?

2574
02:46:07,480 --> 02:46:07,820
이거죠

2575
02:46:07,900 --> 02:46:10,920
그래서 이렇게 하면 true가 나오고
그래서 부등호도 쓸 수가 있겠습니다

2576
02:46:11,300 --> 02:46:14,860
이제 다음으로 자료형의 참과
거짓에 대해서 배워보도록 하겠습니다

2577
02:46:15,200 --> 02:46:22,540
자료형의 참과 거짓이 무슨 소린가 아예 좀 이상하게
들리겠지만 참과 거짓이 자료형마다 정해져 있는 게 있습니다

2578
02:46:22,700 --> 02:46:25,040
매우 중요한 특징이며 실제로 자주 쓰입니다

2579
02:46:25,180 --> 02:46:32,320
어떤 느낌이냐면 마치 스페인어 이런 거 배우신
분들은 스페인어의 남성 표현, 여성 표현 이런 게 있거든요

2580
02:46:32,620 --> 02:46:39,740
그러니까 she나 he가 다른 남자 여자 표현한
것처럼 이것도 참 거짓을 표현하는 값이 따로 있습니다

2581
02:46:39,900 --> 02:46:40,280
자료형이

2582
02:46:40,360 --> 02:46:42,540
실 사례를 보면 좀 더 이해가 좋을 것 같습니다

2583
02:46:43,320 --> 02:46:44,480
문자열 자료형

2584
02:46:44,540 --> 02:46:47,740
어떤 문자가 들어 있으면 참이라고 치고요

2585
02:46:47,860 --> 02:46:49,617
문자가 없으면 거짓이라고 치고요

2586
02:46:49,641 --> 02:46:51,500
그러니까 이게 속성 같은 개념이에요

2587
02:46:51,580 --> 02:46:54,860
어떤 값이 있다가 참이고 보통 없다가 거짓입니다

2588
02:46:55,020 --> 02:46:58,820
123이라는 리스트도 있으면 참이고 없으면 거짓입니다

2589
02:46:59,000 --> 02:46:59,820
튜플도 마찬가지예요

2590
02:46:59,860 --> 02:47:02,556
튜플도 뭔가 값이 들어 있으면 참, 없으면 거짓

2591
02:47:02,580 --> 02:47:03,580
다 패턴이 비슷합니다

2592
02:47:03,800 --> 02:47:06,356
딕셔너리마저도 있으면 참, 없으면 거짓

2593
02:47:06,380 --> 02:47:11,040
숫자형 자료형은 굉장히 특별한 게
숫자가 1 혹은 1 이상이어도 참이라고 치고요

2594
02:47:11,180 --> 02:47:12,640
0은 거짓이라고 칩니다

2595
02:47:12,800 --> 02:47:17,877
그래서 각 값에 어떤 속성이 달려있다고
생각하시면 편할 것 같은데 또 none이라는 거

2596
02:47:17,901 --> 02:47:22,520
아무것도 없는 none이라는
값도 거짓이라는 속성이 있습니다

2597
02:47:22,760 --> 02:47:24,640
그래서 이렇게 볼 수가 있겠습니다

2598
02:47:25,320 --> 02:47:27,380
While문이라는 반복문이 있는데요

2599
02:47:28,020 --> 02:47:30,680
반복문에서 list, pop 기억나시죠?

2600
02:47:30,780 --> 02:47:38,780
Pop이 하나 퍽 뽑아서 버린다의 개념인데 1, 2, 3, 4가
있으면 a라는 리스트가 있는데 여기에 a가 처음에는 true예요

2601
02:47:41,180 --> 02:47:42,180
왜냐하면 값이 있으니까

2602
02:47:42,660 --> 02:47:47,377
그래서 true 값이어서 프린트를
하고 pop으로 하나씩 끝에 걸 날립니다

2603
02:47:47,401 --> 02:47:53,500
그럼 처음에 1, 2, 3, 4였다가 그다음에 1, 2, 3만
남았다가 왜냐하면 하나씩 뒤에 빠지니까, pop을 통해서

2604
02:47:53,620 --> 02:47:58,100
그리고 1, 2만 남았다가 1만
남았다가 마지막에는 없이 되겠죠

2605
02:47:58,220 --> 02:48:04,320
그러니까 빈 리스트가 되면 여기 빈 리스트이기
때문에 얘가 false가 돼서 이거를 빠져나와 버리게 됩니다

2606
02:48:04,560 --> 02:48:11,360
반복문은 아직 안 배워서 이게 무슨 개념인지 잘 이해가 안 될 수
있는데 그냥 미리 좀 소개를 드린다라는 개념으로 보시면 좋을 것 같습니다

2607
02:48:11,560 --> 02:48:14,840
다음에 프린트문 적용할 때 꼭
띄어쓰기를 적용하고 적용해야 되나요?

2608
02:48:15,300 --> 02:48:17,680
근데 이거는 좀 뒤에 나올 개념이라 무조건 해야 됩니다

2609
02:48:17,860 --> 02:48:18,940
이게 안 그러면 오류가 납니다

2610
02:48:19,180 --> 02:48:21,040
파이썬에서는 이런 규칙들이 좀 있어요

2611
02:48:21,240 --> 02:48:23,680
무조건 이렇게 해야 된다라는 규칙이 있습니다

2612
02:48:23,820 --> 02:48:24,880
아무튼 이런 데 활용이 된다

2613
02:48:24,940 --> 02:48:29,560
그래서 이 값은 자료형의 참가 거짓
이거는 종종 살펴보도록 하겠습니다

2614
02:48:29,840 --> 02:48:34,200
지금 보시면 이해가 안 될 수 있는데 쓰일
때가 있을 때 다시 한번 소개를 드릴게요

2615
02:48:34,340 --> 02:48:36,760
그래서 이렇게 일단 어떤 속성이 있다

2616
02:48:36,880 --> 02:48:43,786
예를 들어 스페인어에서 어떤 단어가 남성적
속성인지 여성적 속성인지 이런 게 있는 것처럼

2617
02:48:43,810 --> 02:48:49,560
자료형의 어떤 값도 이게 참인 속성이 있고
거짓인 속성이 있다고 이해하시면 좋을 것 같습니다

2618
02:48:49,720 --> 02:48:52,360
그래서 이거는 이 정도로 이해를 하시면 좋을 것 같고요

2619
02:48:52,640 --> 02:49:00,640
이것도 조건문인데 조건문도 너무 뒤에 있는 게 여기 조금 앞에
미리 나오는 개념들이 좀 있어서 이렇게도 구분을 해볼 수가 있겠습니다

2620
02:49:01,600 --> 02:49:09,080
뒤에 나온 개념은 그냥 이해 안 되시더라도 그냥 이런 게 있구나 뒤에서 이런
게 쓰이는구나 정도로만 보시면 되는데 이걸 실행해 보시면 거짓이 나옵니다

2621
02:49:09,140 --> 02:49:09,640
왜냐?

2622
02:49:09,680 --> 02:49:14,140
리스트가 비어 있기 때문에 그러면
리스트에 뭔가 차 있으면 뭐가 나오냐?

2623
02:49:14,340 --> 02:49:15,177
참이 나옵니다

2624
02:49:15,201 --> 02:49:23,201
그래서 이렇게 이 속성을 통해서 참인 속성인지 거짓인
속성인지를 이용하는 경우가 있다라고 소개해 드릴 수가 있겠습니다

2625
02:49:24,160 --> 02:49:29,980
그러면 이 속성이 참인 속성인지 거짓인
속성인지를 실제로 출력해 볼 수가 있는데요

2626
02:49:30,420 --> 02:49:31,800
불이라고 감싸면 됩니다

2627
02:49:32,080 --> 02:49:33,540
어떻게 보면 형변환을 하는 거죠

2628
02:49:33,680 --> 02:49:39,160
불이라고 그 리스트를 감싸면 이게 참인 속성이
있는지 거짓인 속성이 있는지를 볼 수가 있습니다

2629
02:49:39,300 --> 02:49:44,117
프린트 A를 해보면 지금 리스트에 값이 들어
있기 때문에 얘는 참인 속성을 가지고 있겠죠

2630
02:49:44,141 --> 02:49:45,800
그래서 true가 나옵니다

2631
02:49:45,840 --> 02:49:47,960
그러면 빈 리스트를 넣으면 어떻게 되냐?

2632
02:49:48,100 --> 02:49:49,500
거짓인 속성이 나옵니다

2633
02:49:49,560 --> 02:49:53,680
괄호 열고 닫고 안에 어떤 걸 넣음으로써
이게 어떤 속성인지를 검사할 수가 있습니다

2634
02:49:53,840 --> 02:50:00,620
이렇게 각각 실험해보시면 0이면 false고 1 이상인 값이면
true고 이렇게 나오는데 속성들을 알아볼 수가 있겠습니다

2635
02:50:00,800 --> 02:50:03,460
그래서 이렇게 해서 불자료형까지 살펴봤습니다

2636
02:50:03,580 --> 02:50:05,297
모든 자료형을 다 살펴봤는데요

2637
02:50:05,321 --> 02:50:13,321
그 다음에 이제 약간 어려울 수 있는데 이거를 잡고 가야지 뒤에서 헷갈리지
않는 부분이 있어서 변수에 대해서 조금 더 디테일하게 알아보도록 하겠습니다

2638
02:50:15,360 --> 02:50:18,480
변수에 대한 개념을 좀 소개를 드리도록 하겠습니다

2639
02:50:18,920 --> 02:50:22,840
변수는 처음에도 소개해드린
것처럼 어떤 상자라고 소개해드렸죠

2640
02:50:22,900 --> 02:50:30,536
A는 1 이런 게 있으면 1이라는 값을 a라는 상자에 담는다
정도로 소개해드렸는데 당연히 이거는 좀 비유적인 표현이기도 하고요

2641
02:50:30,560 --> 02:50:33,577
그래서 실제로 조금 더 들어가서 보면 이런 구조입니다

2642
02:50:33,601 --> 02:50:41,601
그 변수에 값을 담는다라고 말씀드렸는데 실제로는 주소 값을 a라는
상자 안에 담는 거고 그리고 메모리에 실제적인 값이 들어가 있습니다

2643
02:50:44,880 --> 02:50:49,683
이 객체라고 하는데 객체는 이제 뒤에
클래스 배우면서 좀 더 소개를 드리고

2644
02:50:49,707 --> 02:50:54,020
변수는 그냥 좀 추상적인 개념이고 메모리
실제로 컴퓨터에 그 램 메모리 있잖아요

2645
02:50:54,300 --> 02:50:56,620
이게 그 디램이라고 하죠

2646
02:50:56,660 --> 02:50:59,360
이렇게 말해서 방들이 여러 개 있는데 이제 주소가 있습니다

2647
02:50:59,540 --> 02:51:03,576
마치 들어가면 이제 호텔에
102호 103호 104호 이렇게 있어요

2648
02:51:03,600 --> 02:51:05,920
메모리에 있는 것처럼 메모리 안에도 주소가 있고요

2649
02:51:06,040 --> 02:51:07,940
이 주소 안에 값이 들어가 있습니다

2650
02:51:08,140 --> 02:51:11,680
여기에 메모리에 있는 특정 주소
값을 이 변수가 가지고 있습니다

2651
02:51:11,880 --> 02:51:19,220
지금 보시면 당연히 엄청 어려운 개념이고 잘 이해가 안 될 수 있는데
일단은 이 정도로 설명을 드리고 뒤에서 한 번 더 하면서 설명을 드리겠습니다

2652
02:51:19,420 --> 02:51:26,440
그래서 이렇게 돼있다라고 이해하신 다음에 위키독스를
따라서 한번 어떤 게 변수인지 좀 더 상세히 알아보도록 하겠습니다

2653
02:51:26,640 --> 02:51:29,160
프로그램이 초보자가 쉽게 이해할 수 있는 부분은 아닙니다

2654
02:51:29,220 --> 02:51:30,920
그래서 이거 이해가 안 된다

2655
02:51:30,960 --> 02:51:33,317
그냥 뭐 이런 게 있거나 하고 넘어가셔도 되는 부분이에요

2656
02:51:33,341 --> 02:51:39,740
약간은 조금 직접 허용심이 그 되는 부분이긴
한데 그래도 알면은 뭐 나쁘지 않은 개념이긴 합니다

2657
02:51:39,840 --> 02:51:41,300
자연스럽게 알게 되기도 하고요

2658
02:51:41,340 --> 02:51:47,940
그러면은 변수를 어떻게 만드는지 뭐 지금까지 계속
사용해 왔는데 그 는 기호에 대해서 다시 한 번 설명하고 있죠

2659
02:51:48,080 --> 02:51:51,120
는은 assignment 즉 이렇게 할당한다

2660
02:51:51,260 --> 02:51:55,600
즉 이 오른쪽에 있는 거 왼쪽에
넣는다라는 개념 이거는 먼저 소개를 드렸었죠

2661
02:51:55,720 --> 02:52:03,316
그 실제로 변수의 여기 뒤에 있는 값을 뭐 객체라고
하는데 이 객체라는 개념은 이제 클래스 배우는 개념입니다

2662
02:52:03,340 --> 02:52:11,340
그러면서 뒤에 5장에서 좀 더 자세히 소개를 드릴 텐데 메소드나 뭐 함수들을
쓸 수 있고 뭐 기능적인 단위인데 객체를 저장하는 게 이제 실제 변수의

2663
02:52:12,721 --> 02:52:17,700
개념이고 그거는 메모리에 실제 저장돼 있고
변수에 들어가 있는 거는 주소가 들어가 있습니다

2664
02:52:17,840 --> 02:52:21,180
그래서 이 정도로만 이해하신 다음에 뭐
시각화를 통해서 좀 더 보도록 하겠습니다

2665
02:52:21,360 --> 02:52:22,540
A라는 상자에 있죠

2666
02:52:22,740 --> 02:52:25,180
A라는 상자에 얘가 어떻게 보면 메모리입니다

2667
02:52:25,500 --> 02:52:33,500
메모리 위에 이 리스트라는 값이 들어있고 이 a는 이 리스트를
바라보고 있다고 하는데 이 를 보면은 실제로 주소가 들어 있습니다

2668
02:52:34,740 --> 02:52:41,380
얘가 예를 들어 뭐 104호라면은 104호에 이
리스트가 있어라고 주소가 여기에 들어가 있는 겁니다

2669
02:52:41,540 --> 02:52:48,340
A에 a라는 값을 찍어 봤을 때 print ID a라고
하면은 ID가 그 주소 값을 보는 함수입니다.

2670
02:52:48,460 --> 02:52:51,600
A에 주소 값 1400975 이렇게 나온 거 있죠?

2671
02:52:51,700 --> 02:52:54,300
실제로 이 리스트가 올라간 주소입니다

2672
02:52:54,520 --> 02:52:57,120
그러니까 이게 복잡하지만 뭐 104호 이런 개념이죠

2673
02:52:57,240 --> 02:52:59,340
그래서 이렇게 소개를 드릴 수가 있을 것 같고요

2674
02:52:59,800 --> 02:53:05,600
그러면은 리스트를 복사하고자 할 때, 라는
개념으로 좀 시각화해서 하나씩 보도록 하겠습니다

2675
02:53:05,920 --> 02:53:12,140
A라는 변수가 있고 b라는 변수를 만들어서
같은 거, 이 1, 2, 3이라는 값을 a에 담았잖아요

2676
02:53:12,300 --> 02:53:18,020
그 다음에 b에 a를 담는다라고
하면 이 주소값을 담는 게 됩니다

2677
02:53:18,620 --> 02:53:21,100
이 오른쪽에 있는 걸 왼쪽에 담는다고 했잖아요

2678
02:53:21,500 --> 02:53:24,660
오른쪽에 있는 주소값을 왼쪽에 담게 됩니다

2679
02:53:25,160 --> 02:53:30,415
주소값을 담는다라는 개념에 대해서 이해하신
다음에 이걸 보시면 좀 이해가 되실 텐데

2680
02:53:30,439 --> 02:53:35,720
리스트를 복사하고자 할 때 좀 흔하게
혼동하는 사례에 대해서 보도록 하겠습니다

2681
02:53:35,900 --> 02:53:43,769
A랑 b랑 이렇게 담은 다음에
print ID a를 해보고 print ID b를

2682
02:53:43,793 --> 02:53:50,440
해보면 이렇게 실행을 해보면 a라는
값의 주소와 b라는 값의 주소가 같습니다

2683
02:53:50,800 --> 02:53:52,160
완전히 똑같죠, 두 개가?

2684
02:53:52,200 --> 02:53:55,300
실제로 파이썬 비주얼라이저로 보면 왜 같은지 알겠죠?

2685
02:53:55,480 --> 02:54:02,528
여기 실제로 이 1, 2, 3이라는 값이
생성이 되고 그거의 주소가 a에 할당이 된

2686
02:54:02,552 --> 02:54:08,360
다음에 a는 그 주소값을 b에 넣는 거니까
이렇게 같은 곳을 바라보는 형태가 되겠죠?

2687
02:54:08,460 --> 02:54:10,900
A is b라는 거를 볼 수가 있습니다

2688
02:54:11,100 --> 02:54:12,800
이게 a is b는 뭐냐?

2689
02:54:12,860 --> 02:54:16,580
이 주소값이 같은지를 직관적으로 비교를 할 수가 있어요

2690
02:54:16,740 --> 02:54:19,400
A is b를 하게 되면 true가 나오게 됩니다

2691
02:54:19,560 --> 02:54:27,560
왜냐하면 동일한 주소이기 때문에 아이디가 같기 때문에 그러면 하나씩
변경을 해보면 a의 1번째, 즉 두 번째 값을 4로 한번 바꿔보겠습니다.

2692
02:54:28,601 --> 02:54:36,200
Print a를 하고 print b를 하면 print를
찍어보면 조금 이상하다는 생각이 들 수가 있어요

2693
02:54:36,300 --> 02:54:40,940
그 주소값이라는 개념을 하나도 모르고
이 코드를 본다고 하면 좀 이상하죠?

2694
02:54:41,080 --> 02:54:44,500
1, 2, 3이라는 리스트가 있고 이거를 b에도 담았어요

2695
02:54:44,720 --> 02:54:51,340
그러면 그냥 대충 생각에는 b는 지금 1, 2, 3일 것
같고 a만 변형해서 이 1번째 요소를 4로 바꿨어요

2696
02:54:51,440 --> 02:54:55,020
그러면 a를 찍으면 1, 4,
3이 나오는 게 이해가 되겠죠?

2697
02:54:55,200 --> 02:54:56,080
B를 찍었는데?

2698
02:54:56,200 --> 02:54:58,156
B를 찍었는데 1, 4, 3이 나와요

2699
02:54:58,180 --> 02:54:58,400
어?

2700
02:54:58,600 --> 02:54:59,820
B는 1, 2, 3 아니었나?

2701
02:54:59,860 --> 02:55:00,840
라는 생각이 들잖아요

2702
02:55:00,880 --> 02:55:01,880
그래서 이걸 배운 겁니다

2703
02:55:02,020 --> 02:55:06,020
이게 이런 헷갈리는 개념이 있기
때문에 원리를 파서 보면은 이해가 됩니다

2704
02:55:06,240 --> 02:55:07,060
원리를 파보면?

2705
02:55:07,200 --> 02:55:08,940
요거를 비주얼라이저로 보면 좀 좋겠죠?

2706
02:55:09,160 --> 02:55:10,620
자, 한 줄씩 실행을 해볼게요

2707
02:55:10,860 --> 02:55:16,340
하나 진행하면 a 값에 이제 리스트 메모리에
올라간 1, 2, 3이라는 리스트가 a에 담겼죠?

2708
02:55:16,440 --> 02:55:18,920
B에 a를 담는 건 주소를 담는 겁니다

2709
02:55:19,120 --> 02:55:24,998
즉, 같은 값을 가진 이 같은 주소에 있는
예를 들어 뭐 104호라고 하면 104호에

2710
02:55:25,022 --> 02:55:29,320
있는 이 리스트를 그대로 그냥 b에
바라보게 해서 같은 걸 바라보고 있어요

2711
02:55:29,400 --> 02:55:33,740
그 다음에 이 1번째 요소, 얘를
4로 바꿨더니 이렇게 143이 됐죠?

2712
02:55:33,840 --> 02:55:36,620
근데 프린트 a를 하면 143이 나오고 당연히

2713
02:55:36,660 --> 02:55:42,640
그리고 프린트 b를 했을 때도 같은 것을
바라보고 있기 때문에 143이 나옵니다

2714
02:55:42,720 --> 02:55:50,720
네, 그래서 a랑 b랑 같은 주소를 바라보고 있어서 같은 메모리 이거에 변형된
거를 바라보고 있기 때문에 a랑 b랑 프린트했을 때 같은 결과가 나옵니다

2715
02:55:52,900 --> 02:55:57,841
그래서 이 개념을 몰랐다면 굉장히 헷갈릴
수 있는데 이제 이 주소라는 개념을 이해한

2716
02:55:57,865 --> 02:56:01,840
다음에 다음에는 아, 이게 이래서 이렇게
바뀌는구나 라는 것을 알 수가 있습니다

2717
02:56:01,980 --> 02:56:09,060
네, 그래서 새로 만든 게 아니에요라고 생각할 수 있는데 그냥
이렇게 등호로 넣게 되면 오른쪽에 있는 주소 값을 넣게 됩니다

2718
02:56:09,240 --> 02:56:10,460
그 변수를 그냥 쓰게 되면

2719
02:56:10,580 --> 02:56:14,340
요거를 헷갈리지 않기 위해서 이런
예제가 나오고 이런 단원이 있습니다

2720
02:56:14,680 --> 02:56:18,560
그러면 원래 원하던 거, 그러니까 b는
독립적으로 두고 싶을 수가 있잖아요.

2721
02:56:18,760 --> 02:56:23,900
A만 바꾸고 싶은데 b가 따라서
바뀌니까 약간 좀 직관적이지 않잖아요

2722
02:56:24,060 --> 02:56:25,820
그래서 이걸 방지하려면 어떻게 되냐

2723
02:56:26,360 --> 02:56:27,780
네, 이렇게 보시면 되겠습니다

2724
02:56:28,780 --> 02:56:36,780
여기서는 마찬가지로 1번째를 4로 바꾸면 프린트
a랑 프린트 b를 하면 네, 이제는 원하는 대로 됐습니다

2725
02:56:37,840 --> 02:56:39,040
슬라이싱이라고 하죠

2726
02:56:39,160 --> 02:56:41,180
슬라이싱, 처음부터 끝까지죠

2727
02:56:41,240 --> 02:56:41,840
이상, 미만

2728
02:56:41,880 --> 02:56:42,360
기억나시죠?

2729
02:56:42,480 --> 02:56:50,480
그래서 a라는 리스트가 있는데 얘를 슬라이싱해서 슬라이싱이 아까
말씀드렸듯이 잘라서 걔 자체를 변한다가 아니라 자른 부분을 가져오는 거죠

2730
02:56:52,420 --> 02:57:00,420
인덱싱도 그 부분을 가져오는 것처럼 그냥 자른 이렇게 처음부터
끝까지 잘라서 새로운 리스트를 가져와서 그 리스트를 b에다 넣어준 겁니다

2731
02:57:02,260 --> 02:57:07,620
그러면 같은 공간을 바라보는 게 아니고 새로
복사한 값을 넣어준 거기 때문에 이런 개념이죠

2732
02:57:07,820 --> 02:57:11,320
슬라이싱이 좀 헷갈리시면 인덱싱으로
보시면 이해가 더 좋을 것 같아요

2733
02:57:11,440 --> 02:57:12,540
1, 2, 3이라는 게 있어요

2734
02:57:13,280 --> 02:57:18,460
인덱싱도 잘라서 그 자체를 변형시키는
게 아니라 걔를 하나만 가져오는 거잖아요

2735
02:57:18,620 --> 02:57:21,940
그러니까 얘도 이걸 가져와서 b에
넣은 거니까 그래서 b가 안 변하겠죠

2736
02:57:22,040 --> 02:57:22,720
그런 개념입니다

2737
02:57:22,880 --> 02:57:23,440
E가 됩니다

2738
02:57:23,600 --> 02:57:26,800
왜냐하면 얘는 값을 하나 가져와서 그걸 넣은 거니까

2739
02:57:26,880 --> 02:57:28,456
네, 그래서 이것도 비주얼라이징이니까

2740
02:57:28,480 --> 02:57:29,540
비주얼라이징으로 보도록 하겠습니다

2741
02:57:29,700 --> 02:57:31,720
A는 1, 2, 3이라는 리스트죠

2742
02:57:31,960 --> 02:57:34,040
B는 이게 갑자기 어떻게 됐냐

2743
02:57:34,380 --> 02:57:39,345
슬라이싱을 통해서 여기 있던 이 리스트
자체를 처음부터 끝까지 슬라이싱한 거를

2744
02:57:39,369 --> 02:57:43,660
그대로 b에 다시 넣어준 거라서 어떻게
보면 슬라이싱해서 새로 생성한 겁니다

2745
02:57:43,800 --> 02:57:45,280
그래서 이걸 바꾸면 얘만 바뀌게 되겠죠

2746
02:57:45,560 --> 02:57:50,220
A1번은 4로 바꾸면 이것만 바뀌고
얘는 다른 걸 보기 때문에 안 바뀌었다

2747
02:57:50,340 --> 02:57:54,800
다시 그 인덱싱이라는 개념으로
바꿔서 보면 좀 이해가 쉬울 수 있는데요

2748
02:57:54,960 --> 02:57:56,040
인덱싱이라고 바꿔볼게요

2749
02:57:56,160 --> 02:57:58,456
그러면 여기에 있는 이거를 뽑아오는 게 있어요

2750
02:57:58,480 --> 02:57:59,080
이게 인덱싱이죠

2751
02:57:59,200 --> 02:58:03,220
그럼 2라는 걸 뽑아와서 2라는 값을 여기에 넣어준 거예요

2752
02:58:03,280 --> 02:58:08,340
B라는 거에 들어가 있는데 그러면 이제
a에 1을 변형한다고 해서 얘를 변형했어요

2753
02:58:08,540 --> 02:58:10,200
그렇다고 해서 얘가 바뀌지는 않죠

2754
02:58:10,260 --> 02:58:11,000
그런 개념입니다

2755
02:58:11,160 --> 02:58:17,660
어떤 값을 복사해서 그걸 새로운 메모리에 등록하고
그다음에 변수에 넣어주는 그런 과정이 필요합니다

2756
02:58:17,880 --> 02:58:24,360
그래서 이 교재를 보시면 복사하는 방법 중에 슬라이싱을
이용하면 복사를 할 수 있다라고 1번으로 소개가 되고 있고요

2757
02:58:24,540 --> 02:58:26,440
카피라는 모듈을 이용할 수도 있습니다

2758
02:58:26,780 --> 02:58:28,417
이거는 또 되게 뒤에 나온

2759
02:58:28,441 --> 02:58:35,380
내용이어서 이걸 지금 보는 게 더 헷갈릴 수도 있을 것
같은데 그냥 실제로 복사하는 기능을 가진 그런 모듈이 있습니다

2760
02:58:35,540 --> 02:58:42,020
그래서 이거는 빠르게 보면은 from copy import copy
이게 뭐냐면 뒤에 나올 개념인데 그냥 카피라는 모듈이 있어요

2761
02:58:42,140 --> 02:58:48,273
즉 기능을 누가 만들어 놓고 이거를 가져와서 쓸
수 있게 된 건데 그래서 카피라는 모듈을 가져와서

2762
02:58:48,297 --> 02:58:54,520
카피라는 함수를 이용해서 이렇게 a라는 걸
감싸주면 이 a라는 리스트 자체를 복사해서 줍니다

2763
02:58:54,640 --> 02:58:56,360
이 a랑 b랑은 다른 값이 됩니다

2764
02:58:56,580 --> 02:58:58,160
그래서 비주얼라이저로 보면은

2765
02:58:58,440 --> 02:59:03,520
이것도 카피라는 걸 가져와서 a라는
거와 b라는 게 아예 독립적인 게 되겠죠

2766
02:59:03,620 --> 02:59:06,620
그래서 a가 뭔가 변형을 취해도 b가 변하지가 않습니다

2767
02:59:06,760 --> 02:59:07,820
아 카피 함수도 있어요

2768
02:59:07,980 --> 02:59:14,300
함수 이거는 모듈 이게 더 편한데 사실 그
리스트에 들어있는 뭐 append니 이런 함수 써봤잖아요

2769
02:59:14,440 --> 02:59:16,100
점 append하면 값을 추가하는 거

2770
02:59:16,140 --> 02:59:18,740
그런 것 중에 카피라는 메소드도 있습니다

2771
02:59:19,040 --> 02:59:21,060
즉 카피라는 함수도 있습니다

2772
02:59:21,340 --> 02:59:27,317
그래서 이 함수를 쓰면 이것도 값 복사여서
얘도 독립적으로 메모리에 값이 할당이 됩니다

2773
02:59:27,341 --> 02:59:30,600
얘도 독립적으로 이렇게 할당이
돼서 나온 거를 볼 수가 있죠

2774
02:59:30,720 --> 02:59:36,540
이 메모리라는 개념을 도대체 왜 알아야
되냐라는 거를 그냥 하나의 사례를 통해서 봤습니다

2775
02:59:36,700 --> 02:59:38,140
그래서 이런 게 너무 헷갈릴 수 있잖아요

2776
02:59:38,320 --> 02:59:44,260
만약 실전 개발하다가 이런 일이 생기면은 물론
그때 배워도 되지만 그래도 미리 경험을 하면 좋으니까

2777
02:59:44,460 --> 02:59:50,100
메모리 안에 값이 있고 그게 같은
주소를 바라본다의 개념이 이런 개념이구나

2778
02:59:50,200 --> 02:59:51,957
지금은 좀 더 이해가 되실 것 같습니다

2779
02:59:51,981 --> 02:59:58,800
변수를 왜 쓰고 그 메모리란 개념 왜 알아야
되고를 좀 이런 예제를 통해 살펴봤습니다

2780
02:59:58,880 --> 03:00:01,980
그 다음에 변수를 만드는 여러가지
방법을 배워보도록 하겠습니다

2781
03:00:02,180 --> 03:00:07,540
이게 파이썬에서 또 편리한 기능인데
뒤에 tuple이 있으면 이렇게 쓰면 귀찮잖아요

2782
03:00:07,700 --> 03:00:11,200
이렇게 는 이 두 번 써야 되고,
이렇게 한 번에 쓸 수가 있습니다

2783
03:00:11,420 --> 03:00:12,880
그래서 이거랑 이거랑 같습니다

2784
03:00:13,120 --> 03:00:21,077
프린트 A를 하고 프린트 B를 해 보면 이게 똑같이 앞에
있는 게 이렇게 A로 들어가고 뒤에 있는 게 베이로 들어갑니다

2785
03:00:21,101 --> 03:00:21,940
이게 앞에 있는 게 이렇게 A로 들어가고
뒤에 있는 게 이렇게 B로 들어갑니다

2786
03:00:21,980 --> 03:00:23,860
그래서 이렇게 할당할 수도 있다

2787
03:00:23,960 --> 03:00:25,980
라고 설명을 드릴 수가 있겠고요

2788
03:00:26,100 --> 03:00:27,740
이때 a, b가 튜플인가요?

2789
03:00:28,440 --> 03:00:29,440
그렇다고 볼 수 있습니다

2790
03:00:29,580 --> 03:00:33,640
여기서 이렇게 튜플로 감싸도
되는데 근데 안에 있는 이 값은 변수죠

2791
03:00:33,800 --> 03:00:41,140
왜냐하면 얘는 특정 자료형 이렇게 문자열 자료형 이런 게
아니고 아무것도 없는 진짜 변수이기 때문에 이렇게 쓴 거랑 같습니다

2792
03:00:41,580 --> 03:00:44,660
타입 찍어보면 이 변수 안에
들어가 있는 값의 타입이 나오겠죠

2793
03:00:44,800 --> 03:00:48,117
그래서 이렇게 찍어보면 이렇게 튜플이랑 같습니다

2794
03:00:48,141 --> 03:00:55,700
그래서 튜플을 배울 때도 이거랑 없는 거 기본적으로 콤마로
연결되어 있으면 튜플이라고 말씀드렸는데 이렇게도 똑같습니다

2795
03:00:55,840 --> 03:00:59,400
그래서 여기에 괄호를... 여기만
써도 되고 이게 자체가 튜플입니다

2796
03:00:59,540 --> 03:01:04,780
여기만 써도 되고 여기만 써도 되고 둘 다 안 써도
되고 둘 다 써도 되고 이렇게 여러 가지 케이스가 있습니다

2797
03:01:05,040 --> 03:01:08,400
그래서 이렇게 할 수도 있고 아니면
심지어 리스트를 할 수도 있어요

2798
03:01:08,700 --> 03:01:10,820
리스트로 이렇게 변수를 할당할 수도 있습니다

2799
03:01:11,880 --> 03:01:17,840
이렇게 할당하도 마찬가지로 순서에 맞춰서 첫
번째 거 이렇게 들어가고 두 번째 거 이렇게 들어갑니다

2800
03:01:18,140 --> 03:01:19,140
이런 방법도 있습니다

2801
03:01:19,300 --> 03:01:20,460
A는 b는 파이썬

2802
03:01:20,500 --> 03:01:22,020
같은 값을 넣고 싶을 때

2803
03:01:22,100 --> 03:01:30,100
그럴 때는 그냥 귀찮게 두 줄로 a는 파이썬, b는
파이썬을 안 써도 그냥 한 줄로 통일해서 a는 b는 파이썬

2804
03:01:31,080 --> 03:01:37,240
이렇게 써도 프린트 a랑 프린트
b를 해보면 둘 다 파이썬이 들어갑니다

2805
03:01:37,480 --> 03:01:40,940
그래서 이렇게도 만들 수 있다는
거 알아두시면 좋을 것 같습니다

2806
03:01:41,160 --> 03:01:42,920
그래서 파이썬은 이런 편리한 기능이 많아요

2807
03:01:43,020 --> 03:01:47,537
그리고 굉장히 편리한 기능이 있는데
이거는 가끔 좀 쓰일 때가 있을 것 같아요

2808
03:01:47,561 --> 03:01:48,817
실제로 다른 언어

2809
03:01:48,841 --> 03:01:50,860
일단 다른 언어의 사례를 먼저 보여드릴게요

2810
03:01:51,040 --> 03:01:55,220
A는 3, b는 5가 있는데 둘이 위치를 바꾸고 싶어요

2811
03:01:55,340 --> 03:02:00,300
그러니까 a에다가 5를 담고 b에다가 3을 담고 싶어요

2812
03:02:00,380 --> 03:02:02,040
바꾸고 싶을 때 어떻게 하냐

2813
03:02:02,120 --> 03:02:05,600
다른 언어는 어떻게 해야 되냐면 임시변수를 막 만듭니다

2814
03:02:05,960 --> 03:02:13,960
임시변수를 만들어서 여기에 뭐 그냥 아무거나 해놓은 다음에 이
임시변수를 일단은 템프라는 값에 a라는 값을 담아두고 이렇게 해야 되죠

2815
03:02:16,881 --> 03:02:19,320
이제 a에 b 값을 집어넣습니다

2816
03:02:19,400 --> 03:02:25,040
그 다음에 b에 다시 템프를 넣으면
이제 이렇게 해야 바꿔치기가 되죠

2817
03:02:25,100 --> 03:02:25,940
무슨 말이냐

2818
03:02:26,040 --> 03:02:32,770
A라는 자리가 있고 여기에 3이 들어있고
b라는 자리가 있고 이게 5가 돼 있는데 템프라는

2819
03:02:32,794 --> 03:02:37,760
게 있어야 이 애를 담아놓으면 없어지니까
3이라는 값을 임의로 여기에 담아놓습니다

2820
03:02:38,000 --> 03:02:46,000
그러면 이제 b를 이렇게 넣어서 얘를 없앤 다음에 5로 바꾸고 이제
a가 없어졌으니까 템프에서 가져와서 b를 바꿔서 3을 담아놓습니다

2821
03:02:46,880 --> 03:02:48,120
얘를 3으로 바꾸는 겁니다

2822
03:02:48,280 --> 03:02:56,280
이렇게 해야 되는 게 다른 언어의 기본적인 값을
바꾸는 개념인데 a, b를 b , a 이런 문법이 딴 데는 없거든요

2823
03:02:57,680 --> 03:02:59,300
그런데 이렇게 바꿀 수가 있습니다

2824
03:02:59,720 --> 03:03:01,940
프린트 a, b를 하면 이렇게 됩니다

2825
03:03:02,180 --> 03:03:03,140
5와 3이 바뀌었죠

2826
03:03:03,180 --> 03:03:04,840
A가 5가 되고 b가 3이 됐죠

2827
03:03:04,900 --> 03:03:10,540
그래서 엄청나게 간단한 문법으로 쓸
수가 있어서 파이썬의 엄청난 특장점입니다

2828
03:03:10,780 --> 03:03:12,820
그래서 파이썬은 이러한 장점이 있습니다

2829
03:03:13,140 --> 03:03:16,856
그래서 이렇게까지 해서 오늘 진도를 다 나갔습니다

2830
03:03:16,880 --> 03:03:24,020
그래서 2-8까지 2장, 파이썬 프로그램의
기초, 자료형에 대해서 다 배워봤습니다

2831
03:03:24,420 --> 03:03:32,420
그 되게 유명한 여기 말이 있는데 자료형을 알고 이해할 수
있다면 이미 그 언어의 절반을 터득한 것이나 다름없다 라고 합니다

2832
03:03:34,280 --> 03:03:41,260
즉 여러분들은 이 언어의 파이썬의 절반을 터득한
것이나 다름없다 라고 생각하시면 좋을 것 같습니다

2833
03:03:41,440 --> 03:03:46,840
그래서 이제 복습 빡세게 한번
숫자형, 문자열, 리스트, 튜플, 딕셔널

2834
03:03:47,640 --> 03:03:53,664
이게 각각 어떤 특징이 있었고 어떤
함수들을 써서 바꿀 수 있었고 어떻게 값을

2835
03:03:53,688 --> 03:03:59,301
조정할 수 있었고 특징이 뭐였는지 이런
것들을 한번씩 쭉 복습을 해보시기 바랍니다

2836
03:03:59,460 --> 03:04:02,560
그리고 변수의 개념에 대해서 얘는 좀 어렵거든요

2837
03:04:02,760 --> 03:04:05,260
그러니까 이 주소값 이런 게 너무 머리 아프잖아요

2838
03:04:05,440 --> 03:04:13,440
그래서 이게 잘 이해가 안 되시면 너무 이렇게 신경 쓰려고 하시지
않으셔도 그냥 이런 주소값 때문에 생각보다 이런 오류가 발생할 수 있구나

2839
03:04:15,901 --> 03:04:20,680
이 정도만 이해하신 다음에 그냥
넘어가셔도 사실 큰 부분은 아닙니다

2840
03:04:20,760 --> 03:04:23,816
점프 투 파이썬 3장 프로그램의 구조를 쌓는다

2841
03:04:23,840 --> 03:04:25,420
제어문을 들어가 보도록 하겠습니다

2842
03:04:25,660 --> 03:04:29,480
제어문이 뭐냐면 크게 조건문과 반복문이 있습니다

2843
03:04:29,800 --> 03:04:37,560
그 어떤 프로그래밍을 하든 굉장히 필수적인 개념이기 때문에
이거는 진짜 반드시 알아두셔야 된다라고 말씀드릴 수 있겠고요

2844
03:04:37,640 --> 03:04:41,260
조건문과 반복문을 파이썬에서 어떻게
활용하는지 배워보도록 하겠습니다

2845
03:04:41,640 --> 03:04:43,540
조건문부터 알아보도록 하겠습니다

2846
03:04:44,140 --> 03:04:45,876
If문이라고 부를 수도 있겠습니다

2847
03:04:45,900 --> 03:04:48,120
이런 거를 처리할 때 씁니다

2848
03:04:48,160 --> 03:04:52,736
예를 들어서 돈이 있으면 택시를 타고 돈이 없으면 걸어간다

2849
03:04:52,760 --> 03:04:54,500
이런 상황 굉장히 많죠

2850
03:04:54,940 --> 03:05:02,940
그래서 어떤 조건에 따라서 돈이 있냐 없냐에 따라서 행동을
달리해야 될 때 이런 상황들을 처리하는 것을 조건문이라고 합니다

2851
03:05:03,640 --> 03:05:07,740
그래서 이거를 프로그래밍에서 어떻게
처리하냐 이런 식으로 표현해 볼 수가 있겠죠

2852
03:05:07,860 --> 03:05:15,177
이게 순서도라는 건데 어떤 사실이 참일 때와
거짓일 때를 나눠서 이런 논리회로를 그려볼 수가 있겠죠

2853
03:05:15,201 --> 03:05:17,976
돈이 있으면 택시를 타고 돈이 없으면 걸어간다

2854
03:05:18,000 --> 03:05:26,000
이것을 좀 이런 논리회로로 그려보면 시작을 해서 돈이
있는가를 만나서, 돈이 있으면 참이니까 참쪽으로 가서 택시를 탄다

2855
03:05:27,840 --> 03:05:32,680
를 선택하고 돈이 없으면 거짓이니까 걸어간다를 선택합니다

2856
03:05:32,860 --> 03:05:35,820
이런 식으로 구성이 되는 게 조건문입니다

2857
03:05:35,980 --> 03:05:38,480
그래서 이것은 굉장히 흔하게 쓰는 개념이니까요

2858
03:05:38,560 --> 03:05:40,500
이것은 반드시 알아두셔야 됩니다

2859
03:05:40,780 --> 03:05:48,780
그래서 혹시나 이제 프로그래밍을 블록 코딩으로 처음 접해 봤을 때,
접해보신 분들을 위해서 스크래치나 엔트리에서는 뭔가를 클릭해서 시작했을 때

2860
03:05:50,141 --> 03:05:55,237
머니가 있다고 true라고 정해주면
만약 머니가 true라면 택시를 타고 가라

2861
03:05:55,261 --> 03:05:56,440
아니면 걸어가라

2862
03:05:56,480 --> 03:05:58,820
이런 식으로 표현을 할 수 있는 게 조건문입니다

2863
03:05:59,000 --> 03:06:02,440
그래서 이거를 파이썬으로 어떻게
하는지 이번 시간에 배워보도록 하겠습니다

2864
03:06:02,620 --> 03:06:05,740
마찬가지로 위키독스를 이용해서 학습을 해보겠습니다

2865
03:06:06,060 --> 03:06:08,140
그러면 if문 부터 들어가보도록 하겠습니다.

2866
03:06:08,400 --> 03:06:09,700
If문은 왜 필요할까?

2867
03:06:09,760 --> 03:06:14,437
아까 말씀드린 것처럼 이런 돈이 있으면
택시를 타고 가고 돈이 없으면 걸어간다

2868
03:06:14,461 --> 03:06:20,320
이런 상황이 있을 때 이거를 이런 식으로
파이썬으로 표현해서 처리를 할 수가 있겠습니다

2869
03:06:20,620 --> 03:06:24,440
순서도로 그려보면 아까 본
것처럼 이렇게 표현을 할 수가 있겠죠

2870
03:06:24,600 --> 03:06:27,960
이거를 파이썬 코드로 한번 표현을 해서 보도록 하겠습니다

2871
03:06:28,420 --> 03:06:33,520
그러려면 vs코드 항상 쓰는 이
환경으로 들어오셔서 챕터 3를 나갑니다

2872
03:06:33,640 --> 03:06:35,360
여기에 파일을 구성을 해보겠습니다

2873
03:06:35,960 --> 03:06:40,440
그럼 위키독스의 기본 if구문을
가져와서 실행을 해보겠습니다

2874
03:06:41,020 --> 03:06:48,880
이거는 반복 설명드렸다시피 아이들 창이나 이런 레펠 창에서
이용되기 때문에 이런 꺽쇠가 있고 이거는 지워주시면 됩니다

2875
03:06:48,980 --> 03:06:50,160
깔끔하게 정리를 해보겠습니다

2876
03:06:50,460 --> 03:06:52,340
그러면 이렇게 표현을 해볼 수 있겠습니다

2877
03:06:52,600 --> 03:06:56,648
Money는 true라고 일단 설정을
해놓은 거는 이거는 지난 시간에 배웠던

2878
03:06:56,672 --> 03:07:01,040
불자료형, true, false 자료형을 일단
money라는 변수 안에 넣어준 거고요.

2879
03:07:01,300 --> 03:07:04,040
If가 이제 이번에 오늘 배울 조건문이고요.

2880
03:07:04,160 --> 03:07:12,160
Money가 들어가 있는데 이 money가 참인지 거짓인지에
따라서 실행하는 코드가 달라지는 그런 구문이 if문입니다.

2881
03:07:14,140 --> 03:07:15,020
Money가 현재 true죠

2882
03:07:15,080 --> 03:07:18,760
그렇기 때문에 print 택시를
타고 가라가 출력이 될 거고요

2883
03:07:18,800 --> 03:07:24,940
그리고 money가 거짓일 때 else 쪽 아래에
있는 걸어가라라는 구문이 출력이 됩니다

2884
03:07:25,160 --> 03:07:33,160
그래서 이렇게 구성되는 형태가 조건문이라고 부르고 실제로 한번
실행을 해보면 이렇게 택시를 타고 가라가 출력이 된 것을 볼 수 있습니다

2885
03:07:33,820 --> 03:07:35,560
왜냐하면 money가 true기 때문이죠

2886
03:07:35,680 --> 03:07:39,680
그러면 money가 없을 때,
money가 false일 때는 어떻게 되냐

2887
03:07:39,720 --> 03:07:44,960
그러면 false니까 if문에서 false를
만나면 else 쪽에 있는 게 실행이 됩니다

2888
03:07:45,220 --> 03:07:50,360
실행을 해보면 false기 때문에
else를 만나서 걸어가라라고 나옵니다

2889
03:07:50,500 --> 03:07:56,260
그래서 이 구조는 순서대로 보는 게 더
와닿으실 것 같은데 이 구조랑 완전히 똑같죠

2890
03:07:56,320 --> 03:07:59,960
그래서 이렇게 구성되는 게 조건문이라고 보시면 되겠습니다

2891
03:08:00,200 --> 03:08:01,480
이런 상황이 굉장히 많습니다

2892
03:08:01,680 --> 03:08:09,680
프로그래밍에서는 이런 조건을 걸고 뭐일 때 어떻게 하고 뭐일 때 어떻게
하고 이렇게 나눠지는 경우가 되게 많은데 그 가장 중요한 걸 배우고 있습니다

2893
03:08:10,300 --> 03:08:12,500
If문의 기본 구조를 보도록 하겠습니다.

2894
03:08:12,640 --> 03:08:12,676
If문의 기본 구조를 보도록 하겠습니다.

2895
03:08:12,700 --> 03:08:14,700
If문의 구조는 굉장히 단순합니다.

2896
03:08:14,780 --> 03:08:21,480
If 뒤에 조건문이라고 되어있는 게 이게 true
혹은 false가 될 수 있는 그런 구문을 여기 써주고요

2897
03:08:21,560 --> 03:08:23,840
이게 참일 때 실행할 거, 이게 참

2898
03:08:23,960 --> 03:08:26,997
그리고 거짓일 때 실행할 거는 이렇게 거짓

2899
03:08:27,021 --> 03:08:31,380
이렇게 그 인덴트라고 하는데
이렇게 들여쓰기로 구분을 합니다

2900
03:08:31,620 --> 03:08:36,460
그래서 if 아래쪽에 한 칸 들여
써진 이 웅탱이는 참일 때 실행할 거

2901
03:08:36,500 --> 03:08:39,600
아래쪽 else 뒤에 있는 건 거짓일 때 실행할 거

2902
03:08:39,640 --> 03:08:41,097
이렇게 나눌 수가 있겠습니다

2903
03:08:41,121 --> 03:08:45,480
네, 들여쓰기 말씀드렸는데 이
들여쓰기는 어떻게 되어있는 거냐

2904
03:08:45,540 --> 03:08:48,280
그 탭을 누르면 한 칸 들여쓰기가 되는데요

2905
03:08:48,440 --> 03:08:54,220
혹은 뭐 띄어쓰기 4개, 스페이스 4번을 탁탁탁탁
치면은 그렇게도 띄어쓰기를 할 수가 있습니다

2906
03:08:54,480 --> 03:08:58,340
그 인덴트가 굉장히 중요한 게
이게 안 맞으면 오류가 납니다

2907
03:08:58,480 --> 03:09:04,116
보통 다른 프로그래밍 언어에서는 이런
들여쓰기를 막 강제하는 언어는 잘 없는데 파이썬

2908
03:09:04,140 --> 03:09:09,120
언어는 특이하게 들여쓰기를 굉장히
강제를 하고 그걸 맞춰야지만 잘 실행이 됩니다

2909
03:09:09,690 --> 03:09:11,077
그래서 오류가 나는 거에요

2910
03:09:11,101 --> 03:09:14,880
이 구문을 한번 실행을 해봐서 어떻게
오류가 나는지 보도록 하겠습니다

2911
03:09:15,100 --> 03:09:16,620
예제를 그대로 가져와봤는데요

2912
03:09:16,760 --> 03:09:18,280
벌써 이렇게 밑줄이 생겼죠

2913
03:09:18,340 --> 03:09:23,680
이게 어떤 거냐면 실행을 해봤을 때
일단 오류가 났는데 인덴테이션 에러

2914
03:09:24,020 --> 03:09:27,500
인덴트가 들어가 있다라고 지금 오류가 발생을 했습니다

2915
03:09:27,840 --> 03:09:28,660
이게 왜 그러냐

2916
03:09:28,700 --> 03:09:34,768
아까 설명드렸다시피 money는
true고 if money를 만나서 true일 때는 이

2917
03:09:34,792 --> 03:09:40,980
들여쓰기 안쪽에 구문을 실행한다고 말씀드렸는데
이 그냥 들여쓰기가 끝난 거는 일반 코드에요

2918
03:09:41,100 --> 03:09:46,680
즉 if문과 관계없이 진행되는 코드인데
갑자기 들여쓰기가 들어가 버렸죠

2919
03:09:46,720 --> 03:09:49,060
그래서 이렇게 오류가 발생한 겁니다

2920
03:09:49,540 --> 03:09:56,233
그래서 이걸 제대로 맞추려면 탭을 써서 줄을
다 안쪽으로 한줄씩 인덴트를 넣어서 안쪽으로

2921
03:09:56,257 --> 03:10:01,680
들여쓰기를 통일하면 이렇게 taxi를 타고 가라가
모두 출력이 되는 것을 확인해 줄 수 있습니다

2922
03:10:01,860 --> 03:10:04,880
그런데 이걸 둘 다 들여쓰기를 풀어도 돼요

2923
03:10:04,980 --> 03:10:12,980
그런데 풀면 의미가 달라지는 게 이걸 풀게 되면 똑같이 taxi를 타고
가라가 정상적으로 나와서 그런데 이것은 조건문은 여기까지만 조건문이 되고요

2924
03:10:15,900 --> 03:10:21,900
아래쪽은 이 조건문의 true, false 여부와 상관없이
그냥 쭉 실행되는 일반적인 코드 흐름이 됩니다

2925
03:10:22,180 --> 03:10:23,260
이게 무슨 말이냐?

2926
03:10:23,320 --> 03:10:31,320
이거를 true를 false로 바꾸면 타고 가라는 이 true, false와
관계없이 지금 money가 false여서 사실 이 구문이 실행이

2927
03:10:32,321 --> 03:10:37,180
안 됐는데 그 아래쪽 거는 이 true,
false랑 관계없는 그냥 프린트 문인 거죠

2928
03:10:37,320 --> 03:10:40,357
그래서 타고 가라는 출력이 된 것을 확인할 수 있습니다

2929
03:10:40,381 --> 03:10:45,500
즉, 이런 인덴트를 굉장히 잘 맞춰야
된다라고 이해하시면 좋을 것 같습니다

2930
03:10:45,700 --> 03:10:48,480
그래서 이 인덴트 관련해서 좀 재밌는 것도 있습니다

2931
03:10:48,740 --> 03:10:49,740
이런 것도 있는데요

2932
03:10:49,800 --> 03:10:52,060
이게 엄청 싸우는 소재 중에 하나입니다

2933
03:10:52,260 --> 03:10:56,740
개발자들이 싸우는 소재 중에 하나인데
개발자들 왜 코드 빈칸 때문에 싸우지?

2934
03:10:56,880 --> 03:11:00,000
라는 게 있는데 사람마다 이제 습관이 좀 다양하잖아요

2935
03:11:00,140 --> 03:11:06,160
그래서 코드 컨벤션이라고 하는데 띄워쓰기를
할지 탭을 쓸지 이게 사람마다 좀 취향이 다릅니다

2936
03:11:06,280 --> 03:11:14,280
그래서 지금은 탭으로 이렇게 탭키를 눌러서 이렇게 딱 들여쓰기를
했는데 이거 말고 띄워쓰기로 하나 둘 셋 넷 칸을 떼어도 똑같습니다

2937
03:11:14,920 --> 03:11:20,100
그래서 이렇게 쓰나 저렇게 쓰나 똑같은데
이거에 대한 좀 찬반 논쟁이 있습니다

2938
03:11:20,300 --> 03:11:25,700
그래서 뭐 띄워쓰기를 해야 되니 뭐 탭을
눌러야 되니 근데 그거는 중요한 게 아니고요

2939
03:11:25,800 --> 03:11:27,140
이게 탁이냐 이게 탭이죠

2940
03:11:27,560 --> 03:11:35,560
탁탁탁탁이냐 이거는 이제 띄워쓰기 네 개고 요 습관은 다르기 때문에 이거는
당연히 그 뭐 프로젝트 그 회사 그 주변 사람들이 쓰는 거에 맞추면 좋겠죠

2941
03:11:38,620 --> 03:11:39,917
근데 이게 안 맞으면

2942
03:11:39,941 --> 03:11:41,620
되게 갈등이 일어나기도 합니다

2943
03:11:41,900 --> 03:11:47,020
네 아무튼 결국에는 들여쓰기를 잘 맞추는
게 중요하다라고 말씀드릴 수가 있겠습니다

2944
03:11:47,360 --> 03:11:48,780
네 당연히 이것도 안 되겠죠

2945
03:11:48,880 --> 03:11:53,060
이렇게 탭 하나 더 들여쓰는
것도 안 되고 딱 맞춰 써야 됩니다

2946
03:11:53,380 --> 03:11:56,260
그래서 이거 하나 더 들여쓰면 안 됩니다

2947
03:11:56,440 --> 03:12:02,700
왜냐 정확하게 이렇게 한 탭씩 돼가지고
줄이 맞아야 되는데 이거는 오류가 납니다

2948
03:12:03,360 --> 03:12:07,760
네 이거 스페이스바로 하는 게 좋을까 탭으로
하는 게 좋을까 이런 논란에 대해서도 나오죠

2949
03:12:08,080 --> 03:12:09,620
어 콜론을 잊지 말자

2950
03:12:09,940 --> 03:12:11,680
네 콜론은 꼭 있어야 됩니다

2951
03:12:11,860 --> 03:12:19,860
그래서 if 다음에 어떤 조건 true false가 되는 조건을
적어주고 이 콜론을 빼먹으면 또 이 조건문이 맞지가 않습니다

2952
03:12:20,040 --> 03:12:24,380
그래서 항상 콜론을 쓰는 거를 까먹지
않으면은 이거를 잘 쓸 수가 있습니다

2953
03:12:24,660 --> 03:12:27,400
다음에 아래쪽으로 내려가서 조건문이란 무엇인가

2954
03:12:27,680 --> 03:12:30,320
네 조건문은 참 거짓을 판단하는 문장입니다

2955
03:12:30,940 --> 03:12:38,940
그래서 이렇게 쓰는 거는 아까 봤기 때문에 네 money가 true면은
if money를 했을 때 그 if 아래쪽에 한 칸 들여쓰게 된 글자

2956
03:12:39,940 --> 03:12:40,940
구문들이 실행이 되겠죠

2957
03:12:41,280 --> 03:12:43,060
그리고 네 이렇게 쓸 수가 있습니다

2958
03:12:43,360 --> 03:12:45,200
그다음에 비교 연산자

2959
03:12:45,260 --> 03:12:51,000
그래서 이 조건 if money 쪽에 이 money
부분에 어떠한 조건이 들어갈 수가 있는데요

2960
03:12:51,220 --> 03:12:53,040
즉 true false가 될 수 있는 조건

2961
03:12:53,120 --> 03:12:58,001
그런 거는 보통 이제 비교 연산자나
아니면 지난 시간에 배운 걸 가져오면 뭐

2962
03:12:58,025 --> 03:13:02,620
자료형에도 true false의 속성이 있는데
네 그거를 하나씩 배워보도록 하겠습니다

2963
03:13:02,860 --> 03:13:04,540
먼저 비교 연산자

2964
03:13:04,600 --> 03:13:06,020
뭐 크다 작다 이런 거 있죠

2965
03:13:06,140 --> 03:13:09,480
이런 표현들을 쓰는 방법에
대해서 먼저 배워보도록 하겠습니다

2966
03:13:09,940 --> 03:13:15,000
그래서 비교 연산자는 이건 아마 뭐
수학을 배우셨으면 기본적으로 아시겠죠

2967
03:13:15,080 --> 03:13:17,120
이렇게 하는 게 부등호라고도 하죠

2968
03:13:17,180 --> 03:13:23,324
이렇게 부등호, 예를 들어 1하고 2가
있으면 이제 이게 2가 1보다 크니라고 이렇게

2969
03:13:23,348 --> 03:13:29,100
해서 이게 참이면 true가 나오고
거짓이면 false가 나오는데 이거는 true죠

2970
03:13:29,560 --> 03:13:30,400
이건 반대죠

2971
03:13:30,460 --> 03:13:32,280
X가 y보다 크다 이런 거고

2972
03:13:32,340 --> 03:13:34,740
근데 여기서 중요한 거는 등호 두 개

2973
03:13:34,840 --> 03:13:37,600
이게 등호가 같다의 개념이 아니라고 말씀드렸죠

2974
03:13:37,680 --> 03:13:39,860
오른쪽에 있는 거 왼쪽에 넣는다라고 말씀드렸는데

2975
03:13:39,940 --> 03:13:44,876
등호 두 개여야지, 예를 들어
이런 게 있으면 1이 2랑 같니?

2976
03:13:44,900 --> 03:13:46,440
라고 물어보는 게 이런 겁니다

2977
03:13:46,600 --> 03:13:47,160
등호 두 개

2978
03:13:47,240 --> 03:13:50,840
그래서 이게 실제로 같은지를 보려면
등호 하나가 아니라 두 개를 써야 되고요

2979
03:13:51,280 --> 03:13:53,520
이렇게 되면 1이 2랑 같지 않죠

2980
03:13:53,580 --> 03:13:55,500
그래서 이게 false가 나옵니다

2981
03:13:55,620 --> 03:14:00,360
이런 식으로 부등식이나 비교
연산을 통해서 할 수가 있겠습니다

2982
03:14:01,180 --> 03:14:02,800
그 다음에 같지 않다

2983
03:14:02,860 --> 03:14:07,260
같지 않다는 프로그래밍에서는
원래 수학에서는 이렇게 쓰잖아요

2984
03:14:07,480 --> 03:14:08,997
1이 2랑 같지 않다

2985
03:14:09,021 --> 03:14:11,800
이렇게 쓰는데 이거를 어떻게 표현하냐

2986
03:14:12,440 --> 03:14:14,420
느낌표하고 등호로 표현합니다

2987
03:14:14,640 --> 03:14:15,960
왜냐하면 이런 기호가 없잖아요

2988
03:14:16,040 --> 03:14:16,460
키보드에

2989
03:14:16,540 --> 03:14:21,540
그래서 1은 2랑 같지 않다라는 거를
느낌표 등호로 표현할 수가 있겠습니다

2990
03:14:22,180 --> 03:14:24,180
이게 같지 않으니까 이게 전체는 true죠

2991
03:14:25,520 --> 03:14:28,260
이런 식으로 비교 연산을 해볼 수 있겠습니다

2992
03:14:28,920 --> 03:14:29,780
크거나 같다

2993
03:14:29,820 --> 03:14:30,876
작거나 같다

2994
03:14:30,900 --> 03:14:35,740
이런 것도 이렇게 쓸 수가 있는데
이때 중요한 건 등호가 뒤쪽에 있습니다

2995
03:14:36,180 --> 03:14:38,996
그래서 등호를 먼저 쓰고 이렇게 하면 안 됩니다

2996
03:14:39,020 --> 03:14:47,020
그래서 항상 부등호를 먼저 쓰고 그 다음에 등호를 써서 예를
들어 1, 1이면 이거는 등호가 포함된 거기 때문에 true가 되겠죠

2997
03:14:50,140 --> 03:14:52,880
이렇게 비교 연산을 이런 식으로 써볼 수가 있겠습니다

2998
03:14:54,920 --> 03:14:57,480
그리고 그러면 실전 예제를 하나 풀어보겠습니다

2999
03:14:58,440 --> 03:15:06,440
이렇게 실전 예제를 하나 해보면
x는 3, y는 2면 이게 어떻게 될까요?

3000
03:15:08,180 --> 03:15:08,900
True일까요?

3001
03:15:09,020 --> 03:15:10,020
False일까요?

3002
03:15:10,260 --> 03:15:13,700
3이 2보다 크기 때문에 true가 나오겠죠

3003
03:15:14,300 --> 03:15:18,940
그러면 이거를 반대로 바꾸면 당연히 false가 나옵니다

3004
03:15:19,120 --> 03:15:24,960
그래서 이 부등호 등호 이런 걸 비교 연산자를
통해서 true, false를 구분을 할 수가 있겠습니다

3005
03:15:25,600 --> 03:15:26,740
그리고 같지 않다

3006
03:15:26,780 --> 03:15:30,780
같지 않다 한번 써보면 느낌표 등호라고 말씀드렸죠

3007
03:15:30,840 --> 03:15:34,956
그래서 느낌표 등호는 같지
않다의 표현인데 이 두 개가 같나요?

3008
03:15:34,980 --> 03:15:35,420
같지 않다요?

3009
03:15:35,740 --> 03:15:38,617
같지 않기 때문에 true가 나옵니다

3010
03:15:38,641 --> 03:15:40,680
이렇게 쓸 수가 있겠고요

3011
03:15:41,400 --> 03:15:49,400
그 다음에 이제는 좀 더 실전적인 예제 간단한
예제를 해봤는데 실제 상황을 한번 들어보겠습니다

3012
03:15:50,060 --> 03:15:57,120
만약에 3,000원 이상의 돈이 있다면 택시를 타고
그렇지 않으면 걸어가라 라는 조건이 있을 수 있죠

3013
03:15:57,240 --> 03:15:59,640
그거를 프로그래밍으로 표현을 해볼 수 있겠습니다

3014
03:16:00,320 --> 03:16:04,600
그래서 이렇게 표현을 할 수 있을
텐데 이렇게 써보도록 하겠습니다

3015
03:16:05,720 --> 03:16:11,860
탭 맞추는 거 중요하다 말씀드렸는데 탭 맞추는 거
중요하다 말씀드렸는데 이렇게 탭을 맞춰서 써보도록 하겠습니다

3016
03:16:13,100 --> 03:16:15,640
자 그러면 이런 상황이 있다고 해보겠습니다

3017
03:16:16,240 --> 03:16:17,500
머니가 2,000원입니다

3018
03:16:18,020 --> 03:16:26,020
그리고 머니가 만약에 3,000원 이상이면 택시를 타고
아니면 걸어가라 라는 상황이 있다고 하면 그러면 어떻게 될까요?

3019
03:16:27,180 --> 03:16:30,440
현재는 2,000원이기 때문에 false가 나오게 됩니다

3020
03:16:30,700 --> 03:16:32,680
이 전체 구문이 false가 나오죠.

3021
03:16:34,100 --> 03:16:37,517
False가 나오기 때문에 거짓일
때는 어떤 게 실행될까요?

3022
03:16:37,541 --> 03:16:41,000
얘는 실행 안 되고 else 뒤에 있는 이것만 실행됩니다

3023
03:16:41,120 --> 03:16:45,540
그래서 실제로 실행을 해보면 이렇게
걸어가라가 나온 걸 볼 수가 있죠

3024
03:16:45,760 --> 03:16:47,720
And or not이 있습니다

3025
03:16:47,980 --> 03:16:50,000
이거를 쓰도록 하겠습니다

3026
03:16:50,760 --> 03:16:52,200
그러면 예제로 볼까요?

3027
03:16:52,240 --> 03:16:55,220
바로 예제로 이렇게 보도록 하겠습니다

3028
03:16:56,240 --> 03:16:57,740
이번에는 상황이 이렇게 돼요

3029
03:16:57,820 --> 03:17:00,960
돈이 3,000원 이상 있거나 아니면 카드가 있다

3030
03:17:01,340 --> 03:17:04,480
카드가 뭐 신용카드 이러면은 택시를 탈 수 있죠

3031
03:17:04,620 --> 03:17:09,776
그래서 3,000원 이상이거나 카드가 있다면은
택시를 타고 가고 그렇지 않으면 걸어가라

3032
03:17:09,800 --> 03:17:11,380
이거를 표현해 보도록 하겠습니다

3033
03:17:11,980 --> 03:17:13,260
그럼 이런 구문이 되겠고요

3034
03:17:14,160 --> 03:17:16,380
네, 머니가 먼저 2,000원이에요

3035
03:17:16,580 --> 03:17:18,480
근데 이 카드가 있어요

3036
03:17:18,940 --> 03:17:21,340
그러면 현금 안 쓰고 카드로 결제할 수 있겠죠

3037
03:17:22,100 --> 03:17:28,180
그러면 조건식 봤을 때 if 만약에 머니가
3,000원 이상이 일단 여기는 false가 나왔어요

3038
03:17:29,080 --> 03:17:33,120
근데 or 카드가 있냐라고 했을 때 카드는 true입니다

3039
03:17:34,060 --> 03:17:40,680
그러면 이거는 false인데 이거는 true니까 or
조건이면은 그 true가 하나라도 있으면 참이죠

3040
03:17:41,280 --> 03:17:44,940
그래서 이 카드가 있기 때문에
택시를 타고 가라가 실행됩니다

3041
03:17:45,520 --> 03:17:51,920
그러면 한번 실제로 실행을 해보면 네, 택시를
타고 가라가 잘 나온 것을 확인할 수 있습니다

3042
03:17:52,520 --> 03:17:55,440
즉, 이 or, or나 and 이런 조건이 있죠

3043
03:17:55,700 --> 03:17:59,100
이 조건을 여기서 조건문 안에 쓸 수가 있습니다

3044
03:17:59,740 --> 03:18:03,580
이렇게 조건이 or가 있고 and가 있고 not이 있습니다

3045
03:18:04,720 --> 03:18:06,476
그래서 이렇게 or는요.

3046
03:18:06,500 --> 03:18:09,640
Or는 x와 y 둘 중 하나만 참이어도 참이다

3047
03:18:09,950 --> 03:18:15,020
라고 할 수 있겠고 and는
x와 y 모두 참이어야 참이다.

3048
03:18:15,700 --> 03:18:18,580
Not은 x가 거짓이면 참이다

3049
03:18:18,680 --> 03:18:24,000
이거는 그냥 여기 x의 반대라고 그냥
쉽게 생각하면 더 편할 것 같습니다

3050
03:18:24,380 --> 03:18:27,940
그래서 not이 붙으면 x가 뭐든지 간에 반대로 뒤집는다

3051
03:18:27,980 --> 03:18:29,400
라고 생각하시면 됩니다

3052
03:18:29,700 --> 03:18:33,440
그래서 or는 살펴봤으니까 and라고 쓰면 어떻게 될까요?

3053
03:18:34,540 --> 03:18:38,000
And면 둘 다 조건을 만족해야 참입니다

3054
03:18:38,580 --> 03:18:46,580
그렇다는 건 2000원이면 이거는 false고 카드가 있으니까
true인데 하나라도 거짓이니까 얘는 걸어가라가 나옵니다

3055
03:18:47,620 --> 03:18:55,620
그래서 and면 걸어가라가 나오고 그리고 그
not을 또 한 번 써보면 not card라고 해보겠습니다

3056
03:18:56,160 --> 03:18:58,160
그러면 card는 true예요

3057
03:18:58,440 --> 03:19:00,820
근데 not이 붙으면 어떻게 된다고 했죠?

3058
03:19:00,860 --> 03:19:01,900
뒤집어집니다

3059
03:19:01,940 --> 03:19:08,160
즉, true가 뒤집어져서 이게 전체가 false가
돼서 실행을 해보면 걸어가라가 나옵니다

3060
03:19:08,760 --> 03:19:16,340
왜냐하면 이 전체가 false가 되기 때문에
그래서 이렇게 not이나 and, or를 써봤는데요

3061
03:19:16,460 --> 03:19:20,280
이거는 사실 그냥 이렇게 개념적으로
이해하는 게 더 쉬울 수도 있어요

3062
03:19:20,420 --> 03:19:28,420
보통 많이 하는 게 진리표라고 해서 어떤 명제가 참, 참이면 참이고 참,
거짓이면 거짓 이런 거 진리표 같은 걸로 그려서 생각해볼 수도 있겠죠

3063
03:19:31,660 --> 03:19:37,511
And 조건일 때 이거, 이거가 참이면 참이고
하면서 모든 케이스를 쫙 나열해서 생각해볼 수도

3064
03:19:37,535 --> 03:19:45,200
있는데 근데 사실 이렇게 외우고 이런 거 하는
것보다 그냥 상식적으로 이것만 알고 생각해도 좋겠죠

3065
03:19:45,380 --> 03:19:53,380
Or는 둘 중 하나 and는 둘 다 그리고 not은 반대 이것만
기억하셔도 그냥 다 논리적인 구분을 하실 수가 있겠습니다

3066
03:19:54,180 --> 03:19:56,860
그 다음에 in, not in이라는 것도 있습니다

3067
03:19:57,240 --> 03:20:03,884
이거는 어떻게 되어있냐 이거는 다른 프로그래밍
언어에서는 잘 없는데 여기서는 이렇게 in이

3068
03:20:03,908 --> 03:20:10,240
정말 직관적으로 그 어떤 여러 개 있는 것 중
안에 있냐라는 걸 물어보는 그런 구분입니다

3069
03:20:10,400 --> 03:20:16,640
그래서 list나 tuple 문자열 문자열도 여러 가지
캐릭터 즉, 각 글자들이 여러 개 붙어있는 거잖아요

3070
03:20:16,800 --> 03:20:22,920
그래서 list, tuple 문자열 중에 이 x가 포함되어
있니라고 물어봤을 때 true, false가 나오는 겁니다.

3071
03:20:23,180 --> 03:20:25,440
Not은 반대라고 생각하면 편하겠죠

3072
03:20:25,540 --> 03:20:27,360
그래서 이것도 하나 보도록 하겠습니다

3073
03:20:27,700 --> 03:20:31,980
예제를 보면 자, 그러면 1이 in, list가 있어요

3074
03:20:32,040 --> 03:20:32,220
뒤에

3075
03:20:32,340 --> 03:20:32,917
자, 그러면 1이 in, list가 있어요

3076
03:20:32,941 --> 03:20:32,936
뒤에

3077
03:20:32,960 --> 03:20:36,540
그러면 이 list 안에 1이 있니라고 물어보는 구문이죠

3078
03:20:36,640 --> 03:20:38,760
그래서 여기에 포함이 되어 있습니다

3079
03:20:39,000 --> 03:20:41,300
그렇기 때문에 true가 나옵니다

3080
03:20:41,380 --> 03:20:44,120
그래서 한번 출력을 해보면 네, true가 나오죠

3081
03:20:44,540 --> 03:20:46,640
그러면 반대로 not은 어떻게 될까요?

3082
03:20:46,760 --> 03:20:54,760
여기에 포함되어 있지 않니라고 반대로 한 번 반대로 돌린
거기 때문에 사실상 이걸 구하고 반대로 뒤집는 거랑 똑같습니다

3083
03:20:55,700 --> 03:21:01,097
그러면 이게 포함이 돼 있는데 원래는
true인데 not이 붙어있기 때문에 false가 나오겠죠

3084
03:21:01,121 --> 03:21:04,340
네, 그래서 not이 붙으면 그게 뒤집어진다

3085
03:21:04,380 --> 03:21:09,040
네, 이게 처음에 좀 헷갈릴 수 있으니
두고두고 복습하시면 좋을 것 같습니다

3086
03:21:09,340 --> 03:21:12,080
그다음에 뭐 tuple 문자열 이런 것도 다 됩니다

3087
03:21:12,300 --> 03:21:17,260
그래서 그냥 간단하게 tuple 문자열 하나씩만
보면 첫 번째 줄부터 보도록 하겠습니다

3088
03:21:17,580 --> 03:21:18,820
이거 tuple도 똑같죠.

3089
03:21:18,860 --> 03:21:22,580
Tuple도 list랑 거의 똑같기 때문에
변형만 안 된다의 차이뿐이지.

3090
03:21:22,820 --> 03:21:25,420
A가 여기에 있니라고 하면 여기 들어있죠

3091
03:21:25,500 --> 03:21:28,780
그러면 당연히 실행했을 때 true가 나옵니다

3092
03:21:28,860 --> 03:21:30,597
그러면 두 번째 거는 어떨까요?

3093
03:21:30,621 --> 03:21:35,540
J가 파이썬에 있니라고 했을
때 이 j라는 글자는 여기에 없죠

3094
03:21:35,580 --> 03:21:38,760
그렇기 때문에 사실 false가
나와야 되는데 not이 있죠

3095
03:21:38,880 --> 03:21:43,160
그러면 반대로 뒤집어지기 때문에
얘를 실행하면 true가 나옵니다

3096
03:21:43,260 --> 03:21:44,980
네, 이렇게 볼 수가 있겠습니다

3097
03:21:45,500 --> 03:21:46,500
어, 마스타님

3098
03:21:46,540 --> 03:21:50,320
파이썬에서 쌍따옴표는 공백
반영 안 되는 것 같은데 맞을까요?

3099
03:21:50,500 --> 03:21:51,100
아닙니다

3100
03:21:51,140 --> 03:21:52,320
공백이 반영이 됩니다

3101
03:21:52,520 --> 03:21:54,460
반영이 됐는데 약간 이런 거죠

3102
03:21:54,660 --> 03:21:56,960
자, 그럼 p가 파이썬에 있니 하면 맞죠.

3103
03:21:57,020 --> 03:21:57,500
True죠

3104
03:21:57,580 --> 03:21:59,220
근데 공백을 하나 넣어볼게요

3105
03:21:59,660 --> 03:22:00,577
공백을 하나 넣어요

3106
03:22:00,601 --> 03:22:03,940
하나 넣어보면 p 띄어쓰기가
있니라고 하면 false가 나옵니다

3107
03:22:04,000 --> 03:22:04,400
왜냐?

3108
03:22:04,460 --> 03:22:05,900
이 공백이 반영되기 때문이죠

3109
03:22:06,060 --> 03:22:07,460
쌍따옴표도 마찬가지입니다

3110
03:22:07,520 --> 03:22:09,780
쌍따옴표도 해보면 false가 나오죠

3111
03:22:09,820 --> 03:22:11,420
즉, 공백도 반영이 됩니다

3112
03:22:11,840 --> 03:22:18,380
공백을 지우면 p는 포함돼 있는데 p 띄어쓰기
공백까지 포함된 이거는 포함이 안 돼 있죠

3113
03:22:18,500 --> 03:22:21,140
이게 true가 되려면 띄어쓰기를 하나 넣어야 됩니다

3114
03:22:21,380 --> 03:22:23,076
그러면 이제 true가 나오죠

3115
03:22:23,100 --> 03:22:23,360
왜냐?

3116
03:22:23,420 --> 03:22:25,360
이게 다 포함이 돼 있기 때문에

3117
03:22:25,480 --> 03:22:33,480
그러면 이제 그걸 응용해서 실제 상황을 만들어 보면 만약에 주머니에
돈이 있으면 택시를 타고 없으면 걸어가라를 in 조건으로 만들어 보겠습니다.

3118
03:22:36,180 --> 03:22:40,300
Pocket 주머니에 paper,
cell phone, money가 있어요

3119
03:22:40,460 --> 03:22:44,940
그러면 이 중에서 pocket이라는
리스트가 이 안에 들어가 있는 거죠

3120
03:22:45,120 --> 03:22:52,280
그럼 이 리스트 안에 money가 있어라고
in으로 찾아보면 있으니까 여기 money가 있죠

3121
03:22:52,400 --> 03:22:54,440
그러면 이 전체 조건이 true가 됩니다.

3122
03:22:54,620 --> 03:22:57,877
True가 되기 때문에 이게 실행이 되겠죠

3123
03:22:57,901 --> 03:23:02,140
한번 실행을 해보면 택시를 타고
가라가 잘 나온 것을 확인할 수 있습니다

3124
03:23:02,260 --> 03:23:06,360
이렇게 in을 이용해서 true, false를
찾는 조건도 해볼 수 있겠습니다

3125
03:23:06,940 --> 03:23:07,680
이런 것도 있습니다

3126
03:23:07,880 --> 03:23:13,400
이것도 조건문에서 아무 일도 일어나지 않게
설정하고 싶다면 이런 게 있는데 이런 게 있습니다

3127
03:23:14,120 --> 03:23:19,260
예를 들어서 이 조건을 만족했을
때 굳이 뭔가를 출력하고 싶지 않아요

3128
03:23:19,840 --> 03:23:22,680
그렇다면 여기에 비워두면 어떻게 되냐

3129
03:23:22,720 --> 03:23:23,720
오류가 납니다

3130
03:23:25,000 --> 03:23:27,360
If문을 썼는데 이 뒤에 아무것도 없어

3131
03:23:27,900 --> 03:23:32,780
라고 오류가 나는데 그냥 아무것도 하고
싶지 않다일 때 pass라는 걸 써줍니다.

3132
03:23:33,340 --> 03:23:41,340
Pas라는 예약어라고 이제 이미 정해진 키워드 중에 하나인데 pass를 쓰게
되면 말 그대로 그냥 이 줄은 아무것도 안 하고 지나가는 그런 효과를 냅니다

3133
03:23:43,700 --> 03:23:49,000
실행해보면 오류가 없고 그냥 pass를
해서 아무것도 안 하고 넘어가는 걸 볼 수 있죠

3134
03:23:49,620 --> 03:23:55,757
그런데 여기에 만약에 반대로 not을 붙여서
이게 false가 나오면 그대로 이 걸어가라가 나오죠

3135
03:23:55,781 --> 03:24:02,380
즉 true일 때는 아무것도 안 하고 싶을 때 그럴 때는 이
pass라는 키워드가 있다라고 소개를 드릴 수가 있겠습니다

3136
03:24:02,500 --> 03:24:06,480
다양한 조건을 판단하는 elif에
대해서 배워보도록 하겠습니다

3137
03:24:06,780 --> 03:24:08,520
이것도 굉장히 많이 씁니다

3138
03:24:08,600 --> 03:24:13,180
왜냐하면 조건이 하나만 있지 않고
여러 개의 조건이 걸린 경우가 굉장히 많죠

3139
03:24:13,280 --> 03:24:21,280
주머니에 돈이 있으면 택시를 타고 가고 주머니에 돈은 없지만
카드가 있으면 택시를 타고 가고 돈도 없고 카드도 없으면 걸어가라

3140
03:24:21,640 --> 03:24:24,280
이런 조건들이 막 여러 개 걸릴 수가 있겠죠

3141
03:24:25,780 --> 03:24:27,700
그래서 이것들을 코드로 한번 표현해보겠습니다

3142
03:24:27,920 --> 03:24:33,880
그러면 주머니에는 페이퍼와 셀폰이
리스트 안에 들어있고 카드는 true예요

3143
03:24:34,440 --> 03:24:37,496
그러면 if가 포켓 안에 있니?

3144
03:24:37,520 --> 03:24:40,340
라는 물어오면 이 포켓 안에 지금 money가 없죠?

3145
03:24:40,840 --> 03:24:46,840
그래서 false가 나오는데 그러면
this is false일 때 실행할 구문이죠

3146
03:24:47,220 --> 03:24:49,360
이 안에 지금 ifs가 또 있어요

3147
03:24:49,520 --> 03:24:52,440
왜냐하면 이 조건을 한 번 더 보려고 하기 때문에

3148
03:24:52,580 --> 03:24:54,820
그래서 얘는 거짓이라 여기로 들어왔는데

3149
03:24:55,780 --> 03:25:00,640
그래서 카드가 true이기 때문에 카드가
있으면 택시를 타고 가라가 실행이 되겠죠

3150
03:25:01,140 --> 03:25:04,780
그런데 그 카드마저 없으면 걸어가라가 되겠습니다

3151
03:25:05,240 --> 03:25:12,280
그래서 이런 여러 조건이 걸린 경우 이렇게도 쓸 수
있는데 일단 한번 실행을 해보면 택시를 타고 가라가 잘 나오죠

3152
03:25:12,400 --> 03:25:14,560
그런데 이거를 좀 줄여서 쓸 수도 있습니다

3153
03:25:15,420 --> 03:25:16,620
산만한 느낌이 들죠

3154
03:25:16,680 --> 03:25:19,080
여기 굉장히 막 if else,
if else 여러 개 있으니까

3155
03:25:19,360 --> 03:25:23,277
그래서 이거를 줄여 쓰는 표현이
있는데 이렇게 줄일 수가 있겠습니다

3156
03:25:23,301 --> 03:25:28,400
이 else하고 또 다른 조건을 건다
라고 하면 이거를 줄여서 씁니다

3157
03:25:28,440 --> 03:25:31,080
그래서 elif라는 표현이 있습니다

3158
03:25:31,260 --> 03:25:39,260
그래서 elif로 줄여서 검사를 하고 else는 다시 또
else로 쓰고 이렇게 훨씬 더 깔끔하게 쓸 수가 있겠습니다

3159
03:25:40,180 --> 03:25:48,180
그러면 if money를 검사해서 이게 거짓이더라도 한 번
더 다른 조건을 elif라는 것 뒤에 이걸로 검사를 합니다

3160
03:25:49,060 --> 03:25:53,276
그래서 카드 조건을 elif라는 걸 한
번 더 검사해서 true면 이렇습니다

3161
03:25:53,300 --> 03:25:58,680
이렇게 하고 false면 이렇게 하고 이렇게
여러 개를 구분 지어서 나타낼 수도 있겠죠

3162
03:25:58,950 --> 03:26:04,860
그래서 else if, else if를
줄여서 elif라고 씁니다

3163
03:26:05,230 --> 03:26:09,060
그래서 이렇게 쓰는 게 파이썬 여러
조건의 표현식이라고 할 수 있겠습니다

3164
03:26:09,520 --> 03:26:13,420
그래서 이런 식으로 무한정 조건을 계속 늘릴 수도 있습니다

3165
03:26:13,640 --> 03:26:20,747
그래서 어떤 조건이 있고 이게 거짓일 때
elif도 한 번 검사하고 이게 또 거짓이면 elif도

3166
03:26:20,771 --> 03:26:26,260
검사하고 이것도 거짓이면 쭉쭉쭉 내려가서
다 거짓일 때 else 이렇게 쓸 수도 있겠습니다

3167
03:26:26,420 --> 03:26:34,354
그래서 개수 제한 없이 이런 식으로 순서도로 보자면
시작 입력해서 조건문 거쳐서 이게 거짓일 때 한 번 더

3168
03:26:34,378 --> 03:26:42,060
검사하고 이것도 한 거짓일 때 또 검사하고 쭉쭉쭉 해서
다 거짓이면 else로 가도록 이렇게 만들 수도 있겠습니다

3169
03:26:42,620 --> 03:26:45,460
그 다음에 if문을 한 줄로 작성하는 방법도 있습니다

3170
03:26:45,680 --> 03:26:51,340
이런 줄여 쓰는 표현들이 프로그래밍에서는 굉장히
많은데 그 중에 하나인 if문을 한 줄로 쓸 수도 있습니다

3171
03:26:52,100 --> 03:26:53,276
네 이렇게 되겠습니다

3172
03:26:53,300 --> 03:26:54,520
된 거를 한 줄로 한 번 줄여 보겠습니다

3173
03:26:54,680 --> 03:27:02,680
네 파켓이 이런 리스트가 있고 머니가 파켓에 있으면 그냥 지나가고
아니면 카드를 꺼내라 라는 게 출력되도록 하려면 그러면 이렇게 쓸 수가 있겠죠

3174
03:27:06,380 --> 03:27:14,380
얘는 패스는 아무것도 안 한다니까 근데 이렇게 두
줄로 이렇게 막 길게 쓰려니까 약간 복잡한 거예요

3175
03:27:14,800 --> 03:27:18,380
그래서 좀 줄여 쓰고 싶을 때는
어떻게 해야 되냐 이렇게 합니다

3176
03:27:18,660 --> 03:27:24,680
이 패스를 이 콜론으로 어차피 구분이 되니까
패스를 바로 뒤에 이렇게 붙여 쓸 수도 있습니다

3177
03:27:24,860 --> 03:27:29,740
그리고 else 마저도 이 콜론이 있으니까
이 뒤에 바로 이렇게 붙여 쓸 수가 있습니다

3178
03:27:29,960 --> 03:27:37,160
즉 굳이 이런 들여쓰기나 이렇게 다음 줄로 안
하고도 바로 이렇게 한 줄 표현도 할 수가 있겠습니다

3179
03:27:37,440 --> 03:27:43,180
그래서 if 한 줄 else 한 줄로 이렇게 두 줄로
표현을 할 수도 있고 이것도 똑같이 실행이 됩니다

3180
03:27:43,800 --> 03:27:51,800
그래서 얘는 지금 머니가 있기 때문에 패스로 갔고 머니를
지워서 이걸 false로 만들면 그러면 카드를 꺼내라가 출력이 되죠

3181
03:27:53,800 --> 03:27:59,960
근데 보통 이렇게 한 줄로 쓰는 거는 오히려 좀
구분이 어려워서 두 줄로 쓰는 게 일반적입니다

3182
03:28:00,260 --> 03:28:06,340
굳이 좀 줄여 쓰고 싶다 하시는 분들은 이렇게
붙여서 쓸 수도 있다는 그냥 간단한 팁 하나 전해드립니다

3183
03:28:06,820 --> 03:28:08,460
실용적이진 않고 패션 코딩이죠

3184
03:28:08,540 --> 03:28:09,020
패션 코딩

3185
03:28:09,060 --> 03:28:12,280
약간 지척 허영심 같은 거고
기능적으로는 아무 차이가 없습니다

3186
03:28:12,520 --> 03:28:17,137
패션 코딩을 좀 하고 싶다면 그렇게 해도
되고 두 줄로 씌워도 전혀 상관없습니다

3187
03:28:17,161 --> 03:28:19,800
그 다음에 조건부 표현식이라는 것도 있어요

3188
03:28:19,960 --> 03:28:24,500
이것도 줄여 쓰는 방법 중에 하나인데
다른 언어에서도 이런 표현들이 있습니다

3189
03:28:24,760 --> 03:28:31,880
왜냐하면 사망연산자 이런 이름으로 다른 식으로 쓰이기도
하는데 파이썬에서 쓰이는 방법을 배워보도록 하겠습니다

3190
03:28:32,320 --> 03:28:39,700
그러면 스코어가 60점 이상일 때 이런 표현이 굉장히 많은데
이거를 줄여 쓰는 방법에 대해서 이것도 패션 코딩이긴 합니다

3191
03:28:40,020 --> 03:28:42,780
굳이 이렇게 안 써도 되는데 한번 배워보도록 하겠습니다

3192
03:28:43,360 --> 03:28:51,015
이렇게 있을 때 스코어가 60점 이상인가 라고
묻고 100이니까 이상이니까 석세스라는 메시지가

3193
03:28:51,039 --> 03:28:56,500
들어가서 석세스를 출력하는 이런 코드가
있을 텐데 그러면 이게 false면 failure가 나오겠죠

3194
03:28:56,760 --> 03:28:59,420
이거를 줄여 쓰는 방법을 보도록 하겠습니다

3195
03:29:00,020 --> 03:29:04,380
줄여 쓰려면 조건부 표현식 이런
식으로 표현을 할 수가 있겠습니다

3196
03:29:05,260 --> 03:29:08,620
줄여서 이렇게 쓸 수가 있는데 같은 겁니다

3197
03:29:08,840 --> 03:29:11,720
일단 참일 때 조건을 먼저 써요

3198
03:29:11,760 --> 03:29:15,420
참일 때 실행할 거를 가장 기본적으로 박아놓습니다

3199
03:29:15,620 --> 03:29:20,836
그러면 참일 때 무조건 참이면 이렇게
된다를 박아놓고 그 다음에 조건을 써요

3200
03:29:20,860 --> 03:29:24,900
If 하고 조건을 한 다음에 거짓일 땐 이렇게 씁니다

3201
03:29:24,980 --> 03:29:29,037
그래서 이게 정리하면 참, 조건, 얘는 거짓

3202
03:29:29,061 --> 03:29:31,980
이렇게 쓰면 이것도 패션 코딩

3203
03:29:32,040 --> 03:29:36,480
패션 코딩으로 그냥 참일 때
먼저 받고 조건 쓰고 거짓 쓴다

3204
03:29:36,520 --> 03:29:39,720
이렇게 표현할 수도 있는데 굳이 이렇게 안 하셔도 됩니다

3205
03:29:39,980 --> 03:29:43,640
좀 뽐내고 싶을 때 이런 코드로 멋있게 표현할 수도 있겠다

3206
03:29:43,880 --> 03:29:47,136
보여드리는 것 뿐이고 굳이 두
줄, 세 줄, 네 줄로 상관없습니다

3207
03:29:47,160 --> 03:29:49,140
이거는 그냥 스타일입니다, 스타일

3208
03:29:49,340 --> 03:29:50,340
예를 들어 이런 사람 있잖아요

3209
03:29:50,460 --> 03:29:52,160
카라티 입을 때 기 세워 있는 사람들

3210
03:29:52,360 --> 03:29:54,860
세워 입고 싶다 하면 이런 식으로 쓸 수가 있겠습니다

3211
03:29:55,160 --> 03:30:00,420
그래서 이렇게 쓸 수가 있다는 걸 통해서
이제 if문에 패션 코딩까지도 배워봤습니다

3212
03:30:00,940 --> 03:30:03,300
조건문 한번 쫙 다 배워봤습니다

3213
03:30:03,480 --> 03:30:04,440
어렵지 않죠

3214
03:30:04,500 --> 03:30:07,760
왜냐면 그냥 조건을 검사해서
true or false로 나눠진다

3215
03:30:07,800 --> 03:30:09,020
조건이 여러 개일 수도 있다

3216
03:30:09,120 --> 03:30:11,280
이런 거를 다루는 구문이었습니다

3217
03:30:11,720 --> 03:30:19,220
아, 그전에 이거 하나 짚고 넘어갔어야 되는데 지난 시간에
2장 배울 때 자료형에다 참과 거짓이라는 단어를 배웠어요

3218
03:30:19,280 --> 03:30:22,257
어떤 값이 있으면 참, 없으면 거짓

3219
03:30:22,281 --> 03:30:29,180
이런 것들을 쭉 배웠었는데 이게 어떻게 쓰이는지 한
번 더 보자면 이렇게 간단하게 한 번 예제를 보겠습니다

3220
03:30:29,600 --> 03:30:35,720
이거는 if a라는 자리가 true면 이게
출력되고 false면 지나가야 되잖아요

3221
03:30:36,020 --> 03:30:38,120
근데 a가 python이다?

3222
03:30:38,200 --> 03:30:43,440
라고 하면 이게 참인지 거짓인지
보다는 이건 그냥 스트링이잖아요

3223
03:30:43,520 --> 03:30:45,256
그래서 이게 실행이 되나?

3224
03:30:45,280 --> 03:30:50,640
라고 오류가 나지 않을까라고 생각할 수
있는데 실행해보면 오류가 안 나고 참입니다

3225
03:30:50,820 --> 03:30:51,820
라고 잘 나옵니다

3226
03:30:52,020 --> 03:30:58,960
이게 왜 그러냐면 어떤 게 값이 있는 문자열
자료형은 참인 속성을 가지고 있기 때문입니다

3227
03:30:59,700 --> 03:31:02,840
그래서 python이라고 써도
이게 참입니다가 출력이 잘 됩니다

3228
03:31:03,540 --> 03:31:05,740
그러면 빈 문자열이면 어떻게 되냐?

3229
03:31:05,800 --> 03:31:11,140
빈 문자열이면 이게 참이 아니니까
그냥 아무것도 실행이 안 됩니다

3230
03:31:11,460 --> 03:31:16,220
굳이 else를 붙이자면 이렇게 else를
붙이자면 거짓입니다가 출력이 되겠죠

3231
03:31:16,900 --> 03:31:24,900
이런 식으로 어떤 값이 있을 때 참, 없을 때 거짓 이라는 속성이 들어가
있는 게 얘는 불자료형이 아닌데도 이렇게 참 거짓을 나타낼 수가 있습니다

3232
03:31:27,680 --> 03:31:34,570
그래서 python에서는 값이 있으면 참, 없으면
거짓 리스트도 마찬가지고 튜플도 마찬가지고

3233
03:31:34,594 --> 03:31:40,580
숫자도 마찬가지고 숫자는 0일 때만 거짓이고
0보다 크면 어떤 값이 있으면 참이 됩니다

3234
03:31:40,800 --> 03:31:47,960
그리고 난일 때 거짓 지난 시간에 조건물 몰랐기 때문에 잘 이해가
안 될 수도 있는데 여기서 이걸 통해서 한 번 더 이해를 해봤습니다

3235
03:31:48,020 --> 03:31:49,800
그리고 뒤에 계속 나오는 개념이니까요

3236
03:31:49,960 --> 03:31:51,760
뒤에도 하면서 보도록 하겠습니다

3237
03:31:52,000 --> 03:31:54,220
그래서 이렇게 해서 조건문까지 끝냈습니다

3238
03:31:54,360 --> 03:31:56,440
다음 반복문을 들어가 보도록 하겠습니다

3239
03:31:56,820 --> 03:31:59,840
반복문 중에 while문이 있고 for문이 있어요, 크게

3240
03:31:59,980 --> 03:32:02,240
그래서 while문부터 보도록 하겠습니다

3241
03:32:02,800 --> 03:32:04,440
나무를 10번 찍는다

3242
03:32:04,520 --> 03:32:06,520
이런 상황이 있을 수 있겠죠

3243
03:32:06,680 --> 03:32:14,680
나무를 10번 찍는다는 거는 어떤 거를 10번 반복해야 될 때 프로그래밍에서
표현한다면 한 줄씩 한 줄씩 찍게 되면 나무 찍기 코드 작성하고 또 첫

3244
03:32:16,501 --> 03:32:22,620
번째, 나무 찍기 두 번째 작성하고 쭉쭉쭉 해서
10줄을 막 작성하느니 이러면 좀 비효율적이겠죠

3245
03:32:22,820 --> 03:32:29,640
만약에 막 만 번씩 반복하고 이런 작업도 있을 텐데
그걸 한 줄 한 줄 코딩한다는 건 너무 비효율적입니다

3246
03:32:29,840 --> 03:32:34,340
그래서 이런 반복적인 작업들을 한
번에 할 수 있는 게 반복문의 표현입니다

3247
03:32:34,780 --> 03:32:38,900
While문은 문장을 반복적으로
수행할 경우 while문을 사용합니다

3248
03:32:39,120 --> 03:32:41,820
그래서 while문을 반복문이라고 부릅니다

3249
03:32:42,020 --> 03:32:43,700
다음은 while문의 기본 구조이다.

3250
03:32:44,040 --> 03:32:51,920
While 이렇게 되는데 이거를 바로 보면 이해가 안 될 수
있으니까 이것도 마찬가지로 순서도로 보면 이런 구조로 됩니다

3251
03:32:52,100 --> 03:33:00,100
반복문, while문이 어떤 구조냐 이렇게 시작한 다음에
시작을 해서 먼저 찍은 횟수가 10보다 더 작은지를 검사를 합니다

3252
03:33:01,740 --> 03:33:05,780
그래서 10보다 안 작네 하면 나무를 일단 한 번 찍습니다

3253
03:33:05,940 --> 03:33:10,340
그러면 찍은 횟수를 처음에 0이었는데 얘를 1로 올려줍니다

3254
03:33:10,480 --> 03:33:15,320
다시 돌아와서 이제 1이 됐으니까 찍은
횟수가 1이 됐으니까 아직도 10이 안 넘었죠

3255
03:33:15,360 --> 03:33:16,700
그러면 또 한 번 더 찍습니다

3256
03:33:17,160 --> 03:33:25,160
그리고 2가 돼서 들어와도 아직도 안 찍었으니까 또 3으로 올라가고
또 찍은 횟수 다시 들어왔을 때 또 안 넘으니까 이게 계속 반복됩니다

3257
03:33:25,420 --> 03:33:31,417
4로 올라가고 5로 올라가고 쭉 반복된
다음에 찍은 횟수가 6, 7, 8, 9까지 돼서

3258
03:33:31,441 --> 03:33:38,860
들어가고 나무를 한 번 더 찍어서 이게
10이 되면 이제는 이 조건이 거짓이 되죠

3259
03:33:38,920 --> 03:33:42,020
그래서 이렇게 끝나는 이런 구조가 됩니다

3260
03:33:42,260 --> 03:33:48,140
즉 어떤 조건을 놓고 이거가 만족할
때까지 계속 반복하는 이런 구조가 되겠습니다

3261
03:33:48,280 --> 03:33:49,320
이런 구조가 되고요

3262
03:33:49,420 --> 03:33:52,320
그러면 이 조건에 해당하는 게 여기 들어가고요

3263
03:33:52,380 --> 03:34:00,380
While 뒤에 그리고 수행할 문장 얘를 반복적으로 계속
수행하다가 이 조건이 이제 false가 되면 빠져나가는 그런 구조입니다

3264
03:34:00,820 --> 03:34:06,180
이거를 만약 스크래치가 익숙하신 분들을 위해서
이것도 가져와 봤는데 이런 식으로 표현할 수도 있겠죠

3265
03:34:06,340 --> 03:34:13,756
그래서 찍은 횟수가 10번 미만일 때까지 반복하기라고
while문을 걸어놓고 찍은 횟수를 하나씩 올려주면서 계속 반복합니다

3266
03:34:13,780 --> 03:34:14,780
반복하면서 찍습니다

3267
03:34:14,860 --> 03:34:21,960
나무찍기 나무찍기 나무찍기 하면서 계속 찍다가 이게 총
찍은 횟수가 10이 되면 이거를 빠져나가서 종료가 되겠죠

3268
03:34:22,120 --> 03:34:23,840
그래서 이렇게 할 수도 있겠습니다

3269
03:34:24,140 --> 03:34:25,620
그러면 코드로 보도록 하겠습니다

3270
03:34:25,820 --> 03:34:28,820
코드로 표현하면 어떻게 되는지 이 코드를 보겠습니다

3271
03:34:29,200 --> 03:34:31,580
그러면 while문 나무찍기 예제입니다.

3272
03:34:31,840 --> 03:34:33,460
Treeheat 처음에는 0번이죠

3273
03:34:33,560 --> 03:34:38,220
왜냐하면 나무를 아직 한 번도 안 찍었으니까
그러면 while문을 쓰고 뒤에 조건을 달아줍니다

3274
03:34:38,440 --> 03:34:43,540
그래서 이 조건이 만족할 때까지 이 안에
있는 코드를 계속 반복 실행하는 겁니다

3275
03:34:43,780 --> 03:34:46,680
Treeheat가 처음에 0이니까 이 조건을 만족하죠

3276
03:34:47,040 --> 03:34:54,840
그래서 안으로 들어가서 treeheat를 찍어주고 그 treeheat를 1
올려주고 그러면 나무 찍은 횟수가 1 올라가고 이거는 그 포매팅이죠

3277
03:34:54,960 --> 03:34:57,880
그래서 이리로 들어가서 나무를 1번 찍었습니다가 됩니다

3278
03:34:58,080 --> 03:35:03,080
그리고 그 treeheat가 10이 아직까지
안 됐으니까 계속 반복을 하겠죠

3279
03:35:03,180 --> 03:35:06,380
그래서 이런 거를 보기 굉장히 편하게 하는 방법이 있습니다

3280
03:35:06,580 --> 03:35:08,100
그냥 생각하면 좀 어렵잖아요

3281
03:35:08,360 --> 03:35:10,680
그리고 심지어 실행을 해보면 너무 빨리 돼요

3282
03:35:10,800 --> 03:35:13,680
나무 1, 2, 3, 4, 5, 6, 7,
8, 9, 10 하고 넘어갑니다

3283
03:35:13,780 --> 03:35:17,300
나왔는데 이게 어떻게 되는지
머릿속으로 생각하기가 조금 어렵잖아요

3284
03:35:17,440 --> 03:35:18,360
그래서 어떤 게 있냐

3285
03:35:18,400 --> 03:35:20,720
VS 코드에서는 디버깅 기능이라는 게 있습니다

3286
03:35:21,200 --> 03:35:26,520
이거를 이렇게 점을 찍으면 1, 2, 3, 4, 5, 6
적혀있는 이 코드 라인 옆에 이렇게 빨간 점이 있습니다

3287
03:35:26,780 --> 03:35:30,300
이 빨간 점을 찍으면 브레이크
포인트라고 해서 멈출 수가 있는데요

3288
03:35:30,400 --> 03:35:31,080
코드 실행을

3289
03:35:31,140 --> 03:35:36,120
이거를 걸어놓고 브레이크 포인트 걸어놓고
그 런에서 스타트 디버깅을 한번 해보겠습니다

3290
03:35:36,400 --> 03:35:40,140
그리고 파이썬 파일을 누르면 디버깅 모드가 켜집니다

3291
03:35:40,240 --> 03:35:41,840
그래서 디버깅 모드가 어떤 거냐

3292
03:35:41,880 --> 03:35:43,437
한 줄씩 한 줄씩

3293
03:35:43,461 --> 03:35:46,000
어떻게 어떤 게 실행되는지 볼 수 있는 구조입니다

3294
03:35:46,120 --> 03:35:49,720
한 줄씩 한 줄씩 실행하면서 코드가
어떻게 흘러가는지를 보도록 하겠습니다

3295
03:35:49,940 --> 03:35:52,660
그러면 이걸 누르면 한 줄씩 한 줄씩 흘러갑니다

3296
03:35:52,740 --> 03:35:53,340
스텝 오버

3297
03:35:53,420 --> 03:35:59,280
한 줄을 누르면 이제 트리히트가 0이라는
거를 선언했을 때 이렇게 트리히트가 0이 됐죠

3298
03:35:59,360 --> 03:36:01,820
이 while 조건을 통과를 한번 해보겠습니다

3299
03:36:02,220 --> 03:36:04,880
트리히트 얘가 0이기 때문에 이걸 통과를 했죠

3300
03:36:04,940 --> 03:36:06,000
그래서 안으로 들어갔고요

3301
03:36:06,100 --> 03:36:10,780
다음 줄로 넘어가서 더하기 1을
했으니까 이제 트리히트 1로 올라갑니다

3302
03:36:11,060 --> 03:36:14,600
트리히트는 트리히트 더하기 1 이렇게
더해서 더해서 넣는다의 개념이었죠

3303
03:36:14,640 --> 03:36:22,640
그래서 1이 됐고 그러면 이 나무를 몇 번 찍었습니다 해서 이
1이 여기 들어가서 나무를 한 번 찍었습니다가 아래에 출력됐습니다

3304
03:36:23,120 --> 03:36:27,860
그 다음에 if문을 지나갔는데 얘는 조건을 만족을 안 하죠

3305
03:36:27,900 --> 03:36:29,057
왜냐하면 10이랑 같니?

3306
03:36:29,081 --> 03:36:31,780
라고 물어봤을 때 1이니까 10이랑 같지 않죠

3307
03:36:31,880 --> 03:36:36,380
그래서 얘는 실행이 안 되고 코드가
끝났는데 다시 위로 올라갑니다

3308
03:36:36,500 --> 03:36:39,440
그래서 이렇게 실행을 해보면 다시 여기로 왔고요

3309
03:36:39,720 --> 03:36:44,000
그럼 트리는 트리히트 더하기
1 하면은 이 숫자가 2로 변하죠

3310
03:36:44,100 --> 03:36:50,380
2로 변했고 다음 이 구문을 출력해보면
트리히트 2니까 나무를 두 번 찍었습니다

3311
03:36:50,560 --> 03:36:51,340
이게 나오겠죠

3312
03:36:51,520 --> 03:36:59,100
그 다음 줄로 넘어가서 if문을 또 여기 안으로 들어가지 못하고
왜냐하면 이 조건이 first가 되기 때문에 그래서 다시 올라왔습니다

3313
03:36:59,300 --> 03:37:05,760
이런 식으로 쭉쭉쭉 어떻게 코드가 흘러가는지
디버깅을 통해서 한 줄 한 줄 실행을 해볼 수 있습니다

3314
03:37:05,960 --> 03:37:07,620
그러면 좀 직관적으로 와닿죠

3315
03:37:07,700 --> 03:37:12,336
코드가 어떻게 실행되는지 그래서 이 조건을 계속
이렇게 반복문을 돌다가 이렇게 실행을 해볼 수 있습니다

3316
03:37:12,360 --> 03:37:17,650
나무 찍기가 이제 아홉 번이 되고 이제
아홉 번째에 마찬가지로 이 조건이 만족되기

3317
03:37:17,674 --> 03:37:21,920
때문에 안에 들어갔고 트리히트를 1
올려주면 그때는 이제 10이 되어버렸죠

3318
03:37:21,980 --> 03:37:27,580
트리히트가 한 줄 더 가면 이 if
조건문 안쪽에 트리히트가 10이랑 같니?

3319
03:37:27,620 --> 03:37:31,820
라고 물어봤을 때 실제로 이 트리히트가 10이랑 같죠

3320
03:37:32,040 --> 03:37:34,220
그럼 이 조건이 이제 처음으로 true가 됩니다.

3321
03:37:34,400 --> 03:37:41,340
True가 되기 때문에 다음 줄 실행해보면 이 안쪽에
나무가 넘어갑니다가 실행이 처음으로 될 수가 있겠죠

3322
03:37:41,480 --> 03:37:44,580
왜냐하면 이 조건이 true이기
때문에 이 트리히트가 10이죠, 지금

3323
03:37:44,640 --> 03:37:52,640
실행을 해보면 이제 이것까지가 출력됐고 다시 올라갔을 때 맨
위에서 지금 트리히트가 10이기 때문에 이 조건은 false가 되죠

3324
03:37:53,300 --> 03:37:59,980
왜냐하면 부등호가 이렇게 등호가 없이 있으니까
그렇기 때문에 이 조건이 false라서 프로그램 종료가 됩니다

3325
03:38:00,160 --> 03:38:07,800
그래서 이 구문이 이해가 안 될 때는 그 run의 start
debugging을 통해서 한 줄씩 한 줄씩 찍어볼 수가 있겠습니다.

3326
03:38:07,980 --> 03:38:13,905
Debugging 이런 거 처음 들어보신 분도 있을
텐데 debugging이 이렇게 한 줄씩 한 줄씩 하면서

3327
03:38:13,929 --> 03:38:20,240
버그를 찾는 과정인데 이것도 좀 재밌는 게 약간 또
지적 허용심 한번 보여드리면 네, 이런 게 있습니다

3328
03:38:20,580 --> 03:38:28,580
이게 왜 debugging이냐 버그가 왜 버그냐를 보면
옛날 컴퓨터들은 이렇게 생겼기 때문에 실제로 이

3329
03:38:28,747 --> 03:38:35,080
컴퓨터실에 벌레가 들어와서 막 벌레가 여기 낑기게
되면 시스템이 망가져가지고 컴퓨터가 동작을 안 합니다

3330
03:38:35,220 --> 03:38:38,960
여기에서 버그를 즉, 진짜 벌레가 버그잖아요?

3331
03:38:39,120 --> 03:38:47,120
그래서 벌레를 샅샅이 뒤져가지고 아, 얘 때문이다 하고 버그를 떼어내가지고
이게 최초의 버그를 찾아서 debugging을 한 이 노트가 여기 있습니다

3332
03:38:48,280 --> 03:38:50,060
그래서 여기 테이프로 버그 붙여놨죠?

3333
03:38:50,140 --> 03:38:55,927
아이씨, 얘 때문에 지금 코드가 동작 안 했어
라고 하고 이 버그를 잡아놨는데 이런 버그를

3334
03:38:55,951 --> 03:39:00,800
잡는 과정에서 유래해가지고 이제 프로그램이
실행 안 될 때 아, 이게 어디서 오류가 있지?

3335
03:39:00,900 --> 03:39:04,140
하고 한 줄씩 탐색하는 이런
과정을 debugging이라고 부릅니다

3336
03:39:04,260 --> 03:39:06,980
그래서 이거는 지적 허용심을 위한 이야기였습니다

3337
03:39:07,240 --> 03:39:10,836
그래서 이제 어려운 와일문에 대해서
이제 한번 전체적으로 익혀봤습니다

3338
03:39:10,860 --> 03:39:15,280
그 다음에 이렇게 되는데 아, 여기서도
약간 꿀팁을 하나 드리자면 이런 것도 있어요

3339
03:39:15,400 --> 03:39:18,860
그 자주 나오는 표현 중에 이런
표현이 굉장히 자주 나옵니다

3340
03:39:19,140 --> 03:39:22,860
여기 보면 트리잇을, 트리잇 더하기 1 이런 거 있죠?

3341
03:39:23,000 --> 03:39:29,208
그래서 1을 더해서 다시 트리잇에 넣어주는
이런 과정이 굉장히 많이 반복되는데 이거를 너무

3342
03:39:29,232 --> 03:39:34,860
많이 쓰다 보니까 이걸 좀 줄일 방법이 없을까를
고민하다가 이제 파이썬에서는 이렇게 표현합니다

3343
03:39:35,120 --> 03:39:41,440
이걸 굳이 두 번 안 쓰고 플러스 는 1
이렇게 쓰면 아까 이 표현이랑 같은 겁니다

3344
03:39:41,620 --> 03:39:43,720
이거랑 1 이거랑 같은 표현입니다

3345
03:39:43,900 --> 03:39:46,236
그 값에 1을 더해서 다시 넣어준다

3346
03:39:46,260 --> 03:39:50,160
이 표현을 줄여서 플러스 는 1이라고
줄여서 표현할 수도 있겠습니다

3347
03:39:50,420 --> 03:39:52,720
그래서 이렇게 써도 결과가 똑같습니다

3348
03:39:52,840 --> 03:39:55,420
그래서 이렇게 축약해서 쓰는 거 그 반대로도 있어요

3349
03:39:55,580 --> 03:40:02,120
마이너스 1 그러니까 이렇게 쓰면은 마이너스 는을
쓰면 트리잇은 트리잇 마이너스 1 이거랑 같은 표현입니다

3350
03:40:02,240 --> 03:40:06,380
그래서 이렇게 써주는 거랑
이거랑 같다 라고 소개를 드립니다

3351
03:40:06,500 --> 03:40:09,740
아니면 다른 언어에선 사실 이렇게
플러스 플러스 이렇게도 쓰거든요

3352
03:40:09,880 --> 03:40:10,760
1 올려주는 거

3353
03:40:10,860 --> 03:40:12,600
네, 파이썬에서는 이게 없습니다

3354
03:40:12,800 --> 03:40:15,500
그래서 아쉽지만 플러스는 1 이렇게 써줘야 됩니다

3355
03:40:15,700 --> 03:40:20,280
그래서 이거는 저희 디버깅을 통해서 봤기
때문에 디버깅으로 보는 게 더 직관적이죠

3356
03:40:20,380 --> 03:40:21,860
그래서 넘어가도록 하겠습니다

3357
03:40:22,120 --> 03:40:26,060
그래서 와일몬 만들기, 이것도 한번
그냥 빠르게 실행을 해보겠습니다

3358
03:40:26,640 --> 03:40:30,900
네, 프롬프트라는 걸 써주고,
여러 줄 표현할 때 이거 기억나시죠?

3359
03:40:31,000 --> 03:40:37,597
큰 따옴표 3개로 감싸면 이런 띄어쓰기,
들여쓰기까지 다 포함돼서 스트링 문장이 만들어집니다

3360
03:40:37,621 --> 03:40:41,800
그러면 이제 프롬프트가 있고, 이
프롬프트를 여기에 출력을 해주는 용이죠

3361
03:40:41,880 --> 03:40:45,260
얘는 그냥 그 사실 메시지 그냥 보여주려고 쓰는 겁니다

3362
03:40:45,520 --> 03:40:53,520
넘버가 0이라고 처음에 초기 값을 정해주고, 이게 넘버가 4랑 같은지를 계속
검사를 해서 이 안에, 와일 안에 있는 구문이 true라면 반복적으로 이게

3363
03:40:55,061 --> 03:41:00,060
실행이 될 텐데, 처음에 0이니까 얘가
계속 반복 실행될 거예요, 이 안에 있는 구문이

3364
03:41:00,280 --> 03:41:04,500
Int라고 쓰고, 이건 숫자형 자료
변환이고, input이라는 걸 받습니다

3365
03:41:04,700 --> 03:41:07,596
그렇다는 건 이건 input이라는
함수는 뒤에 나올 내용입니다

3366
03:41:07,620 --> 03:41:11,560
내용이긴 한데, 유저의 입력을
받아서 그 값을 저장할 수가 있습니다

3367
03:41:11,740 --> 03:41:17,940
그래서 한번 실제로 실행을 해서 보면은, 프린트로 이
프롬프트가 나왔고, 그 다음에 유저의 input을 기다립니다

3368
03:41:18,140 --> 03:41:26,140
그래서 여기 깜빡깜빡하고 있는데, 여기 input을 1이라고
입력하면, 이 넘버가 1이기 때문에 다시 또 이게 반복이 됩니다, 와일문이

3369
03:41:26,400 --> 03:41:32,820
그래서 2라고 입력해도 반복이 되고, 3이라고 해도
반복되고, 4라고 입력하고 엔터를 누르면 그제서야 종료가 됩니다

3370
03:41:33,060 --> 03:41:38,540
왜냐하면 이 4라는 게 넘버에 들어가게
되면, 4랑 같지 않다가 이게 4우스가 돼 버리죠

3371
03:41:38,580 --> 03:41:39,720
이거를 빠져나가 버립니다

3372
03:41:40,480 --> 03:41:43,560
그래서 이 예제까지 한번 실습을 해 봤습니다

3373
03:41:43,680 --> 03:41:47,880
그래서 이런 표현으로 CLI 프로그래밍
할 때는 이런 게 굉장히 많이 쓰입니다

3374
03:41:48,380 --> 03:41:54,900
선택지에 따라서 1일 때는 어떻게 하고, 2일 때는 어떻게
하고, 3일 때는 어떻게 하고, 그리고 4일 때는 프로그램 종류

3375
03:41:54,940 --> 03:41:58,720
이런 거를 여러 조건식을 여러
개 써 가지고 만들 수가 있겠죠

3376
03:41:58,860 --> 03:42:01,200
그래서 이런 구문을 한 번 연습을 해 봤습니다

3377
03:42:01,400 --> 03:42:05,200
그 다음에 와일문 강제로 빠져나가기 라는 방법이 있습니다

3378
03:42:05,360 --> 03:42:05,697
와일문 bazr ramen 님요?

3379
03:42:05,721 --> 03:42:08,680
첫 질문은 조건문이 차민 동안 계속 반복적으로 수행합니다

3380
03:42:08,820 --> 03:42:12,520
계속 반복하는데 중간에
빠져나가고 싶을 때가 있을 수 있겠죠

3381
03:42:12,640 --> 03:42:18,080
그래서 커피 자판기, 자판기 안에 커피가
충분히 있을 때는 동전을 넣으면 커피가 나오죠

3382
03:42:18,120 --> 03:42:22,560
자판기가 제대로 동작하려면 커피가
얼마나 남았는지 검사를 해야겠죠

3383
03:42:22,700 --> 03:42:28,397
왜냐하면 커피가 다 떨어졌는데 동전을
먹고 커피가 없는데도 막 주려고 하면 안 되니까

3384
03:42:28,421 --> 03:42:36,421
만약 커피가 다 떨어졌다면 돈을 아무리 넣더라도 판매 중지라는 문구가
뜨도록 만드는 것이 중간에 브레이크를 걸어주는 과정이라고 볼 수 있겠습니다

3385
03:42:37,200 --> 03:42:38,920
실제 코드를 한번 보도록 하겠습니다

3386
03:42:39,220 --> 03:42:42,680
그러면 이것도 디버깅을 통해서 한 줄씩 보면 좋겠죠

3387
03:42:42,820 --> 03:42:49,340
그래서 디버깅을 보려면 첫 번째 줄에 브레이크 포인트를
걸면 첫 번째 줄부터 걸려서 한 줄 한 줄 실행할 수가 있습니다

3388
03:42:49,720 --> 03:42:53,700
스타트 디버깅을 하면 디버깅이 이렇게 실행이 됩니다

3389
03:42:53,960 --> 03:42:55,720
그래서 한 줄씩 한번 보도록 하겠습니다

3390
03:42:56,080 --> 03:42:57,897
처음에 커피는 10이에요

3391
03:42:57,921 --> 03:42:59,120
머니는 300입니다

3392
03:42:59,260 --> 03:43:01,420
그러면 이렇게 커피 10 머니 400 들어갔죠

3393
03:43:01,480 --> 03:43:08,140
그 다음에 while 머니일 때 이것도 그 자료형의 참과
거짓에서 머니는 숫자인데 어떻게 참과 거짓이 있지?

3394
03:43:08,260 --> 03:43:14,520
라고 생각할 수 있는데 머니는 숫자임에도
불구하고 이런 자료형은 참과 거짓인 속성이 있습니다

3395
03:43:14,780 --> 03:43:19,840
즉 머니가 숫자가 1보다 큰 어떤
숫자라면 이거는 참이라고 보고요

3396
03:43:19,920 --> 03:43:22,240
그리고 0일 때 거짓이라고 봅니다

3397
03:43:22,340 --> 03:43:25,120
즉 여기에 머니가 지금 300이 들어가 있죠

3398
03:43:25,240 --> 03:43:28,620
그렇다는 것은 300이기 때문에 얘는 참입니다

3399
03:43:28,860 --> 03:43:31,360
그래서 여기 while에 true가
들어가 있는 거랑 똑같아요

3400
03:43:31,460 --> 03:43:35,440
그래서 while true이기 때문에
true일 때 안에 있는 게 실행되죠

3401
03:43:35,820 --> 03:43:37,700
음수도 거짓으로 보나요?

3402
03:43:37,840 --> 03:43:39,060
한번 점검을 해보겠습니다

3403
03:43:39,680 --> 03:43:41,380
If minus 1

3404
03:43:41,440 --> 03:43:42,720
0만 거짓입니다

3405
03:43:42,900 --> 03:43:48,100
0만 거짓이고 minus 1도
true로 봐서 이 프린트 참이 됐죠

3406
03:43:48,200 --> 03:43:52,460
그러면 다시 이 while 머니
이 숫자가 0일 때만 거짓입니다

3407
03:43:52,660 --> 03:43:54,900
그럼 0이면 거짓인데 0이 아니죠

3408
03:43:54,940 --> 03:43:55,940
300이죠

3409
03:43:57,440 --> 03:43:58,180
안으로 들어갑니다

3410
03:43:58,260 --> 03:44:02,140
그래서 안으로 들어가면 프린트 돈을 받았으니 커피를 줍니다

3411
03:44:02,260 --> 03:44:03,760
이거를 출력을 해줬죠

3412
03:44:03,820 --> 03:44:06,500
그 다음에 커피는 커피 마이너스 1

3413
03:44:06,580 --> 03:44:09,280
커피가 처음에 10이었다가 하나 줄어듭니다

3414
03:44:09,340 --> 03:44:10,740
즉 커피 한 잔을 준 거죠

3415
03:44:11,260 --> 03:44:16,940
그 다음에 남은 커피의 양은 지금 9로 줄었으니까
남은 커피의 양은 9개입니다가 출력이 됐죠

3416
03:44:17,020 --> 03:44:25,020
그리고 if 커피는 0이랑 같은가를 검사했을 때 얘는 커피가 아직 있기
때문에 이걸 조건을 만족 안 해서 이 안에 있는 거는 안 실행하고 됩니다.

3417
03:44:27,680 --> 03:44:33,300
While 머니를 하고 돈을 받았으니
또 커피를 주는데 커피를 또 하나 깎죠

3418
03:44:33,360 --> 03:44:35,260
그러면 9에서 8이 됩니다

3419
03:44:35,480 --> 03:44:39,860
그리고 남은 커피의 양은 8개입니다가
뜨고 이렇게 쭉쭉 계속 흘러갑니다

3420
03:44:39,940 --> 03:44:43,200
그래서 커피가 또 닳고 얘는 계속 무한이죠

3421
03:44:43,280 --> 03:44:44,280
공짜로 뽑고 있어요

3422
03:44:44,320 --> 03:44:46,660
돈은 깎이지 않고 계속 반복됩니다

3423
03:44:46,780 --> 03:44:54,780
쭉 반복을 해주다가 커피가 한 잔이 남았고 이거를 돈을 마지막으로 받았으니
커피를 준 다음에 커피 마이너스 1을 하니까 커피가 드디어 0이 됐습니다

3424
03:44:56,341 --> 03:45:01,980
커피가 0이 됐으니 커피는 0인가
이게 처음으로 이제 true가 됩니다

3425
03:45:02,140 --> 03:45:06,600
이 조건이 처음에 true가 되니까 드디어
이제 이 안쪽 구문을 실행하는 겁니다

3426
03:45:07,060 --> 03:45:08,160
커피가 다 떨어졌습니다

3427
03:45:08,240 --> 03:45:09,760
판매를 중지합니다를 출력하고

3428
03:45:09,860 --> 03:45:12,220
그 다음에 break trick을 만나죠.

3429
03:45:12,280 --> 03:45:17,840
Break 그리고 이ores의 beni 는 와일문이 아무리
계속 반복되더라도 break 를 만나자마자 빠져나옵니다

3430
03:45:17,880 --> 03:45:20,517
그래서 만나고 다음 문장은 빠져나가 버립니다

3431
03:45:20,541 --> 03:45:22,700
이 브레이크 다음에는 종료가 됩니다

3432
03:45:22,880 --> 03:45:28,520
그래서 브레이크는 이 조건문 안쪽을
빠져나가서 이 바깥쪽으로 나가게 되는 코드입니다

3433
03:45:28,740 --> 03:45:34,253
그래서 브레이크를 만났기 때문에 이 조건은
아직 머니는 300이어서 계속 무한 반복을

3434
03:45:34,277 --> 03:45:39,480
해야 되지만 브레이크를 만났기 때문에
빠져나오는 이런 코드가 브레이크 구문입니다

3435
03:45:39,840 --> 03:45:41,500
그래서 이렇게 써볼 수가 있겠습니다

3436
03:45:41,980 --> 03:45:42,820
이거 이해 되시나요?

3437
03:45:43,000 --> 03:45:48,817
디버깅을 돌리면서 한 줄 한 줄씩 실행하는 거
이걸 해보면서 생각을 해보시면 좋을 것 같습니다

3438
03:45:48,841 --> 03:45:55,960
와일문은 안쪽에 있는 게 계속 반복되는 거고
그리고 if문을 만나서 브레이크, 즉 깨부시는 거잖아요

3439
03:45:56,260 --> 03:46:02,200
와일문 조건문 안쪽에 브레이크가 있으면 이걸
깨부시고 나와서 이 다음 아래쪽이 실행이 됩니다

3440
03:46:02,480 --> 03:46:04,980
그래서 이렇게 된다고 소개를 드렸습니다

3441
03:46:05,160 --> 03:46:07,660
그 다음에 이제 또 다른 예제를 보도록 하겠습니다

3442
03:46:08,240 --> 03:46:14,020
한번 디버깅을 걸기 전에 머릿속으로 한번 생각해
본 다음에 걸면은 생각하는 힘을 키울 수가 있겠죠

3443
03:46:14,140 --> 03:46:19,880
그래서 커피는 10이고 이 와일문이 true니까
이 안쪽이 무한 반복되는 지금 상황이죠

3444
03:46:19,960 --> 03:46:27,960
그래서 무한 반복될 때 이거를 어떻게 빠져나갈까
생각하면 이 브레이크가 여기 있기 때문에 이 조건이 만족되면은

3445
03:46:28,183 --> 03:46:34,280
빠져나가겠구나 를 좀 생각한 다음에 한번 디버깅을
돌리면 어떤 식으로 이 코드가 흘러가는지 알 수 있습니다

3446
03:46:34,420 --> 03:46:35,420
한번 실행을 해보겠습니다

3447
03:46:35,680 --> 03:46:38,900
그러면 한 줄씩 실행하면서 어떻게 흘러가는지 코드를 볼게요

3448
03:46:39,040 --> 03:46:42,360
한 줄 실행하면 일단 커피가 10이라고 생깁니다

3449
03:46:42,420 --> 03:46:45,277
또 한 줄 실행하면 while
true니까 이 안에 갇힌 겁니다

3450
03:46:45,301 --> 03:46:50,480
즉 이 while true 안쪽에 들여쓰기
된 이 구문을 무한 반복을 하게 됩니다

3451
03:46:50,660 --> 03:46:57,800
그래서 브레이크가 만약 없었다면 이 코드가 평생 컴퓨터
망가질 동안 계속 실행이 될 텐데 요거를 보도록 하겠습니다

3452
03:46:58,200 --> 03:46:59,560
자 그럼 한 줄 또 실행을 해볼게요

3453
03:46:59,760 --> 03:47:07,760
Money는 돈을 넣어주세요 라고 인풋을 받으니까 여기
깜빡깜빡하면서 인풋이라는 게 이제 유저의 입력을 받는 거죠

3454
03:47:07,920 --> 03:47:09,820
그럼 유저의 입력을 한번 받아보겠습니다

3455
03:47:10,100 --> 03:47:12,300
Money를 600원 이렇게 넣어볼게요

3456
03:47:12,420 --> 03:47:15,257
돈을 넣어주세요 600을 입력했기 때문에 600원을 넣어주세요
600원을 입력했기 때문에 600원을 넣어주세요 600원을 넣어주세요

3457
03:47:15,281 --> 03:47:16,780
600이 머니로 들어갑니다

3458
03:47:17,160 --> 03:47:18,880
그러면 이제 머니가 600이 됐죠

3459
03:47:18,980 --> 03:47:20,900
그러면은 이제 다음 코드를 보겠습니다

3460
03:47:21,340 --> 03:47:22,580
머니가 300인가?

3461
03:47:22,680 --> 03:47:24,620
라고 했을 때 얘가 300이 아니죠

3462
03:47:24,660 --> 03:47:27,960
600이니까 거짓이 돼서 이 조건으로 갑니다

3463
03:47:28,120 --> 03:47:32,160
Elif를 검사해서 그럼 이번에는
머니가 300원보다 큰가?

3464
03:47:32,200 --> 03:47:33,320
라고 했을 때 크죠

3465
03:47:33,380 --> 03:47:34,380
지금 600이라

3466
03:47:34,640 --> 03:47:36,460
거스름돈을 주고 커피를 줍니다

3467
03:47:36,780 --> 03:47:44,780
라고 하면서 머니에서 300원을 깎고 왜냐하면 머니가 지금
600원이니까 300원을 깎은 다음에 거스름돈을 지금 300원을 줘야겠죠

3468
03:47:46,760 --> 03:47:51,660
왜냐하면 커피 가격이 300원이니까 이
거스름돈 주고 커피를 한 잔을 줬습니다

3469
03:47:51,780 --> 03:47:55,060
그 다음에 이제 커피가 아직
있기 때문에 이게 반복이 됩니다

3470
03:47:55,320 --> 03:48:01,480
600원을 넣었기 때문에 커피 한 잔을 뽑고 이제
돌아왔는데 맨 첫 번째 줄이 다시 돈을 넣어주세요잖아요

3471
03:48:01,980 --> 03:48:05,560
그래서 다시 돈을 그러면
이번에는 막 300원을 넣어보겠습니다

3472
03:48:05,780 --> 03:48:08,360
그러면 이제 if 머니가 300인가?

3473
03:48:08,420 --> 03:48:09,680
라고 했을 때 이게 true가 되죠

3474
03:48:10,060 --> 03:48:17,120
그래서 얘는 거스름돈을 없이 그냥 커피를
주고 커피가 하나 감소돼서 이제 8이 됩니다

3475
03:48:18,140 --> 03:48:19,960
그래서 이 커피는 계속 줄어들고 있죠

3476
03:48:20,080 --> 03:48:24,340
왜냐하면 반복문 안쪽에 계속
돌고 있으니까 다시 이제 들어왔고요

3477
03:48:24,460 --> 03:48:27,160
이제 돈을 넣어주세요 해서 또 넣어주겠습니다

3478
03:48:28,100 --> 03:48:32,120
이번에는 막 301원이라고 하면 거스름돈 1원을 주겠죠

3479
03:48:32,260 --> 03:48:35,380
왜냐하면 커피 가격이 300원이니까
그래서 이리로 들어옵니다

3480
03:48:35,500 --> 03:48:36,577
300원보다 크니?

3481
03:48:36,601 --> 03:48:42,220
라고 했을 때 머니의 300을 빼서 거스름돈을
주고 거스름돈 1을 주고 커피를 줍니다

3482
03:48:42,260 --> 03:48:43,400
그래서 커피가 또 깎였죠

3483
03:48:43,600 --> 03:48:49,220
그래서 이거를 무한 계속 반복 하면
커피가 다 떨어질 때까지 반복을 할 수 있겠죠

3484
03:48:49,420 --> 03:48:52,980
아무리 큰 돈을 줘도 다 거슬러주고 커피를 줍니다

3485
03:48:53,380 --> 03:48:55,760
만약에 300원보다 적은 돈이면 어떻게 될까요?

3486
03:48:56,040 --> 03:49:00,300
200원을 넣으면 이거 조건 if 물
instrument은 처음 조건에 만족을 안 하죠?

3487
03:49:00,360 --> 03:49:01,620
그래서 elif로 갑니다

3488
03:49:01,680 --> 03:49:03,700
그러면 elif 조건도 만족을 안 합니다

3489
03:49:03,800 --> 03:49:05,360
왜냐하면 200원이니까 얘보다 적죠?

3490
03:49:05,420 --> 03:49:08,997
그러면 else로 가서 돈을 다시
돌려주고 커피를 주지 않습니다

3491
03:49:09,021 --> 03:49:17,021
즉, 커피가 안 깎이고, 커피 그대로 유지된 상태로 돈을 돌려주고
얘도 만족 안 하니까 다시 돈 넣는 그 첫 코드로 돌아오게 됩니다

3492
03:49:17,880 --> 03:49:21,620
그래서 이렇게 계속 반복되는
흐름이고 커피를 계속 깎아 보겠습니다

3493
03:49:21,900 --> 03:49:23,640
드디어 이제 커피가 하나 남았습니다

3494
03:49:23,820 --> 03:49:30,480
자판기에 커피가 하나 남았기 때문에 커피 아까
줬으니까 다시 이 500원일 때 커피가 하나 깎였죠?

3495
03:49:30,560 --> 03:49:34,137
여기 들어와서 커피가 하나 깎여서 처음으로 0이 됐습니다

3496
03:49:34,161 --> 03:49:42,161
커피가 처음으로 0이 됐기 때문에 if 이 구문을 지나갈 때
이때 이게 참이 돼 버려서 이제 안쪽 구문이 실행됐습니다

3497
03:49:43,020 --> 03:49:47,100
그래서 커피가 다 떨어졌습니다라는
거를 이때 처음 출력이 됐고요

3498
03:49:47,200 --> 03:49:50,360
그리고 나서 또 한 줄 실행해 보면 break를 만났죠?

3499
03:49:50,640 --> 03:49:54,880
Break를 만났기 때문에 이
while 반복문 이거를 빠져나갑니다

3500
03:49:54,960 --> 03:49:57,320
그래서 프로그램 종료가 됩니다

3501
03:49:57,660 --> 03:50:01,360
그래서 이런 커피 자판기 프로그램을 한번 실행을 해봤습니다

3502
03:50:01,940 --> 03:50:06,542
그래서 이거 처음 보시면 굉장히
복잡할 텐데 이거를 한 줄씩 한 줄씩 실행해

3503
03:50:06,566 --> 03:50:11,500
보시면서 좀 흐름을 익혀 보시면 조금
이해하시는데 좀 도움이 되지 않을까 싶습니다

3504
03:50:11,920 --> 03:50:19,780
그래서 기본 원리는 while문 안에 있는 건 계속 무한
반복이다 이 true가 됐다면 그리고 if문 elif문 이거 있죠?

3505
03:50:19,900 --> 03:50:27,900
그래서 이 조건식을 검사해서 if가 0일 때는 break문을
만나니까 break 때는 또 빠져나간다 라고 알 수가 있겠습니다.

3506
03:50:28,480 --> 03:50:31,497
While문의 맨 처음으로 돌아가기 단원을 나가보겠습니다.

3507
03:50:31,521 --> 03:50:34,700
While문의 맨 처음으로 돌아가는
방법 예제를 보도록 하겠습니다

3508
03:50:34,880 --> 03:50:37,020
여기 패션코딩 해놓으셨죠?

3509
03:50:37,080 --> 03:50:40,560
이거 이제 보면 아 패션코딩이구나 라고 이해하시면 됩니다

3510
03:50:40,760 --> 03:50:42,600
이렇게 쓰는 게 좀 더 직관적이긴 합니다

3511
03:50:42,820 --> 03:50:46,620
이렇게 써도 되는데 굳이 한 줄로
표현하자면 이렇게 쓸 수가 있겠습니다

3512
03:50:46,940 --> 03:50:50,320
그래서 이거 같은 표현이니까
이렇게 좀 두 줄로 해 놓고 보겠습니다

3513
03:50:50,540 --> 03:50:55,280
이 흐름이 어떻게 되는지 디버깅으로 볼 수도
있는데 이걸 그냥 한번 머릿속으로 생각을 해볼까요?

3514
03:50:55,380 --> 03:50:57,500
그러면 처음에 a가 0부터 시작합니다

3515
03:50:57,660 --> 03:51:01,477
그러면 이 조건이 true기 때문에 false가
나오기 전까지 계속 얘를 반복할 때가 됩니다

3516
03:51:01,501 --> 03:51:03,620
그러면 a는 a 더하기 1을 해요

3517
03:51:03,740 --> 03:51:05,900
그러면 이게 a가 처음에 1이 되겠죠

3518
03:51:06,020 --> 03:51:07,680
그리고 이 표현 기억나시나요?

3519
03:51:07,780 --> 03:51:09,300
이게 나머지이거든요

3520
03:51:10,060 --> 03:51:13,860
그러니까 2로 나눈 나머지는 0이다 라는 표현입니다

3521
03:51:14,200 --> 03:51:18,300
두 번째 시간에 배웠었는데 기억 다시
끄집어대서 이게 나머지라는 표현입니다

3522
03:51:18,480 --> 03:51:21,660
2로 나눈 나머지가 0이니라는 건 짝수인 거랑 같은 거죠

3523
03:51:22,200 --> 03:51:25,360
짝수라면은 continue를 만나서 다시 위로 올라갑니다

3524
03:51:25,460 --> 03:51:29,297
그리고 짝수가 아니라면 그냥 밑에
쭉 실행돼서 프린트로 출력이 되겠죠

3525
03:51:29,321 --> 03:51:37,321
그렇다는 거는 이걸 생각해보면 y문이 계속 반복되면서 a가 하나씩 증가할
텐데 짝수면 continue를 만나서 다시 올라가고 홀수만 프린트가 되니까

3526
03:51:38,921 --> 03:51:45,664
실행을 해보면 처음에는 1로 시작해서 1,
짝수면 다시 올라가고 다음에 이제 홀수가 돼서 3이

3527
03:51:45,688 --> 03:51:51,100
찍히고 또 짝수니까 올라가고 5가 찍히고
이런 식으로 찍히는 거를 생각을 해볼 수 있겠죠

3528
03:51:51,220 --> 03:51:54,640
그래서 실제로 실행을 해보면
이렇게 1, 3, 5, 7, 9가 출력이 됩니다

3529
03:51:54,840 --> 03:52:02,580
왜냐하면 짝수일 때는 continue를 만나니까 이 continue를
만날 때는 이렇게 y문 처음으로 돌려주는 코드입니다

3530
03:52:02,720 --> 03:52:09,300
즉 이 아래 조건은 실행이 안 되고 continue
때문에 위로 올라가 버리는 이런 상황이 벌어집니다

3531
03:52:09,340 --> 03:52:14,000
그래서 이거 이해 안 되시면 다시
브레이크 포인트를 찍고 그 다음에 run에 start

3532
03:52:14,024 --> 03:52:17,680
debugging을 통해서 한 줄씩 한 줄씩
보시면 좀 이해가 될 수 있을 것 같습니다

3533
03:52:17,800 --> 03:52:18,460
한번 빠르게 볼까요?

3534
03:52:18,580 --> 03:52:26,460
A가 처음에 0이면 a가 처음에 0이고 1을 더해줬을 때
a가 1이 됐을 때 if 이 조건 2로 나눴을 때 나머지가 0인가?

3535
03:52:26,580 --> 03:52:27,036
아니죠

3536
03:52:27,060 --> 03:52:27,340
1이죠

3537
03:52:27,600 --> 03:52:28,236
나머지가 0입니다

3538
03:52:28,260 --> 03:52:31,180
그래서 얘를 false이기 때문에
건너뛰고 프린트를 해줍니다

3539
03:52:31,300 --> 03:52:32,320
그래서 1이 찍혔고요

3540
03:52:32,420 --> 03:52:35,520
그다음에 다시 a가 1 증가해서 2가 됐어요

3541
03:52:35,640 --> 03:52:39,440
그러면 if는 이 조건을 만족하면
2로 나눈 나머지가 0인가?

3542
03:52:39,520 --> 03:52:41,100
라고 하면 2니까 0이죠 나머지가

3543
03:52:41,240 --> 03:52:43,280
그래서 continue가 실행이 됩니다.

3544
03:52:43,780 --> 03:52:47,160
Continue를 만났을 때는 다시 처음부터 올라갑니다

3545
03:52:47,300 --> 03:52:52,540
그래서 continue를 만났기 때문에 이렇게
올라가 버려서 프린트가 실행이 안 됩니다

3546
03:52:53,020 --> 03:52:54,720
그래서 이렇게 진행이 된다

3547
03:52:54,780 --> 03:52:58,236
쭉쭉 실행을 해보면 이제는 홀수이기 때문에 이걸 돌려줍니다

3548
03:52:58,260 --> 03:52:59,960
조건을 만족 안 하고 프린트가 찍히죠

3549
03:53:00,020 --> 03:53:08,020
그래서 이렇게 1, 3이 찍히고 또 짝수 넘어가고 5가
찍히고 또 짝수 넘어가고 7이 찍히고 짝수는 넘어가고

3550
03:53:09,554 --> 03:53:16,720
9가 찍히고 이렇게 계속 반복이 됐다가 이제 이
조건을 false가 될 때는 이 반복문 자체가 종료가 되겠죠

3551
03:53:16,800 --> 03:53:19,800
반복문 자체가 종료되기 때문에 빠져나가집니다

3552
03:53:19,960 --> 03:53:21,240
그래서 이렇게 해볼 수 있겠습니다

3553
03:53:21,500 --> 03:53:22,700
추가로 이런 것도 가능해요

3554
03:53:22,780 --> 03:53:28,037
VSCode 좋은 점이 하나의 조건문 안쪽에 있는
거를 이렇게 묶어서 열었다 닫았다 할 수 있습니다

3555
03:53:28,061 --> 03:53:29,960
그래서 이거 열었다 닫았다도 할 수 있습니다

3556
03:53:30,040 --> 03:53:35,220
그래서 여기 뒤에 막 이렇게 되면 이 구분에서
이렇게 와일문만 따로 접을 수도 있습니다

3557
03:53:35,460 --> 03:53:38,380
그래서 좀 코드 길어지면 이런 것도 활용해보면 좋겠습니다

3558
03:53:38,800 --> 03:53:40,880
아무튼 이거 예제를 한번 살펴봤습니다

3559
03:53:41,020 --> 03:53:43,220
그래서 continue를 쓰면 맨 처음으로 돌아간다

3560
03:53:43,260 --> 03:53:48,140
그래서 continue랑 pass가 들어갔으면 다시
처음으로 돌아가는 게 아니라 그냥 지나가는 겁니다

3561
03:53:48,340 --> 03:53:50,000
그래서 pass를 하면 지나갑니다

3562
03:53:50,060 --> 03:53:52,120
다시 여기로 안 가고 원래대로 실행해요

3563
03:53:52,200 --> 03:53:55,140
그렇다는 거는 pass를 쓴다면 그냥 다 실행되겠죠

3564
03:53:55,260 --> 03:53:57,300
1, 2, 3, 4, 5, 6, 7,
8, 9, 10이 다 찍힙니다

3565
03:53:57,380 --> 03:54:01,616
이 위로 올라가는 과정이 없이 그냥
쭉 실행이 되기 때문에 for나 while문을

3566
03:54:01,640 --> 03:54:05,360
2, 3중으로 사용시 continue 아
그거는 가장 가까운 데까지 올라갑니다

3567
03:54:05,420 --> 03:54:13,420
그래서 while문이 계속 반복되는데 그러면 한 while문은
그럼 이 while문 바깥에 계속 while문이 있다고 생각해볼게요

3568
03:54:13,640 --> 03:54:17,860
그러면 while문 이 하나의 while문 안쪽에서 이거죠

3569
03:54:17,900 --> 03:54:20,120
그럼 이거 안에서 돕니다

3570
03:54:20,220 --> 03:54:26,780
Continue는 이 한 while문 안에서 돌지 바깥에 또
큰 while문이 있다고 해서 이 바깥까지 가지는 않고요

3571
03:54:26,820 --> 03:54:27,977
가장 가까운 데로 갑니다

3572
03:54:28,001 --> 03:54:29,260
Break도 마찬가지예요

3573
03:54:29,320 --> 03:54:31,700
가장 가까운 반복문을 break합니다

3574
03:54:32,120 --> 03:54:33,940
그 다음에 무한 루프 실행을 해보겠습니다

3575
03:54:34,440 --> 03:54:42,340
그 정말 아까 잠깐 보여드렸는데 while true고 아래 있는
조건 중에 break니 이런 게 없고 이걸 바꿀 수 있는 방법이 없어요

3576
03:54:42,540 --> 03:54:45,780
그렇다는 거는 이걸 실행했을 때 계속 출력이 됩니다

3577
03:54:45,980 --> 03:54:51,840
지금 막 출력이 되고 있는데 이 스크롤을 막
올려도 무한 반복으로 계속 지금 출력되고 있는 거예요

3578
03:54:51,960 --> 03:54:53,660
그래서 얘를 종료하려면 어떻게 해야 되냐?

3579
03:54:53,780 --> 03:54:59,257
Ctrl-c를 하면 이게 강제로 interrupt을
막 걸어서 강제로 종료를 시킵니다

3580
03:54:59,281 --> 03:55:04,233
그래서 키보드 interrupt을 걸어서 오류를
발생시켜서 종료를 했는데 계속 돌아가는

3581
03:55:04,257 --> 03:55:10,320
게 이제 while true 이런 무한 반복
코드가 되면 계속 컴퓨터가 돌아가겠죠

3582
03:55:10,460 --> 03:55:13,580
그래서 이 ctrl-c를 눌러서
이제 빠져나올 수가 있습니다

3583
03:55:13,820 --> 03:55:21,320
그래서 이건 당연히 실전 코드에서 이렇게 쓰면 정말 무한 반복이 되는
거고 이걸 빠져나갈 수 있는 어떠한 조건을 추가해주는 게 좋긴 하겠죠

3584
03:55:21,880 --> 03:55:25,700
그냥 근데 무한 실행할 프로그램이면
뭐 이렇게 돌려도 되긴 하겠습니다

3585
03:55:26,100 --> 03:55:29,240
네, 그래서 이런 무한루프를 한번 만들어 봤습니다

3586
03:55:29,320 --> 03:55:31,620
그래서 당연히 프로그램은 무한루프를 돌긴 하겠죠

3587
03:55:31,700 --> 03:55:37,140
왜냐하면 계속 켜져 있으려면 이 프로그램이 종료가 안
되고 계속 돌아가긴 해야 되니까 근데 종료 조건은 주겠죠

3588
03:55:37,260 --> 03:55:39,900
예를 들어 x 표시를 누르면 프로그램 종료가 된다

3589
03:55:39,940 --> 03:55:41,460
뭐 이런 거를 추가해 줄 수는 있겠습니다

3590
03:55:41,680 --> 03:55:43,480
네, 그래서 while문을 다 배워봤습니다

3591
03:55:43,680 --> 03:55:51,160
송경호 님 의도적으로 무한루프를 돌리다가 메모리 이슈로
터질 때 있던데 메모리 누수가 안 되게 하려면 어떻게 되나요?

3592
03:55:51,260 --> 03:55:53,140
메모리 누수가 안 되게 하려면?

3593
03:55:53,180 --> 03:55:54,400
이런 방법이 있을까요?

3594
03:55:54,540 --> 03:55:58,580
이거는 처음 시간에 설명드린
것처럼 굉장히 잘하는 친구가 있습니다

3595
03:55:58,720 --> 03:56:00,560
굉장히 잘하는 조교한테 한번 물어보겠습니다

3596
03:56:00,720 --> 03:56:04,900
파이썬에서 무한루프를 실행한 동안 메모리
누수가 발생한 것은 두 가지 요인이 있다고 합니다

3597
03:56:05,140 --> 03:56:06,980
아 이게 객체를 계속 생성한다

3598
03:56:07,120 --> 03:56:13,340
그러니까 아까는 프린트문이어서 괜찮았는데 무한루프
안에 변수를 계속 만들어내는 걸 막 추가하면 안 되겠죠

3599
03:56:13,420 --> 03:56:15,760
데이터 계속 커지는 구조 append 이런 거 있잖아요.

3600
03:56:15,940 --> 03:56:18,360
Append로 계속 추가할 때 그러면 안 되겠죠

3601
03:56:18,460 --> 03:56:21,260
그래서 방지하려면 객체를 적절하게 삭제를 해줍니다

3602
03:56:21,380 --> 03:56:23,216
오브젝트 새로 생기면 지워줘요

3603
03:56:23,240 --> 03:56:26,680
무한루프 안에서 생기면 지워주고
생기면 지워주고 하면 문제는 없겠죠

3604
03:56:26,820 --> 03:56:27,957
구조도 최적화하면 좋죠

3605
03:56:27,981 --> 03:56:28,340
구조도 최적화하면 좋죠

3606
03:56:28,400 --> 03:56:32,640
파이썬이 이게 가비지 컬렉터라고
내부적으로 변수 이렇게 관리해주는 게 있죠

3607
03:56:32,760 --> 03:56:36,100
안 쓰는 건 지워주고 그렇기 때문에
심각한 문제가 아니라고 합니다

3608
03:56:36,260 --> 03:56:36,880
이런 거겠죠

3609
03:56:37,000 --> 03:56:45,000
이게 표현을 조금 달리하자면 이런 표현 그러니까 a가 안녕이 있는데 이거를
a.append 이거를 계속 append해주면 리스트가 무한정 늘어나겠잖아요

3610
03:56:47,660 --> 03:56:49,400
안녕이 계속 추가되고 있잖아요

3611
03:56:49,580 --> 03:56:51,540
그러면 이거는 이제 오류가 날 수가 있겠습니다

3612
03:56:51,860 --> 03:56:54,000
지금 오류 날까 봐 껐는데 이러면 안 되겠죠

3613
03:56:54,140 --> 03:56:57,937
그래서 적절히 뭐 안녕을 한 다음에 얘를 클리어를 해줍니다

3614
03:56:57,961 --> 03:56:59,497
이런 단어를 해주거나 뭐 이런 과정이 있어야 된다

3615
03:56:59,521 --> 03:57:00,720
네 이런 말이었겠습니다

3616
03:57:00,860 --> 03:57:02,900
이러면 메모리 지금 엄청 커졌죠

3617
03:57:03,000 --> 03:57:07,060
지금 그래서 이것까지 해서 메모리
누수 문제까지도 다뤄봤습니다

3618
03:57:07,180 --> 03:57:09,200
다음으로 for문을 나가보겠습니다

3619
03:57:09,420 --> 03:57:12,740
파이썬의 직관적인 특징을 보여주는
것이 바로 for문이라고 합니다.

3620
03:57:13,040 --> 03:57:18,180
While문과 비슷한 반복문이지만 for문은
문장 구조가 한 눈에 들어온다는 장점이 있습니다

3621
03:57:18,360 --> 03:57:20,900
그래서 for문이 좀 더 파악하기가 편리합니다

3622
03:57:21,060 --> 03:57:22,060
좀 더 쉽게 되어 있어요

3623
03:57:22,160 --> 03:57:25,200
For문을 잘 사용하면 프로그래밍이 즐거워질 것이다.

3624
03:57:25,400 --> 03:57:26,757
For문의 기본 구조

3625
03:57:26,781 --> 03:57:27,960
그리고 in이라는 걸 쓰고요.

3626
03:57:28,020 --> 03:57:36,020
For 키워드 뒤에 변수를 쓰고 in 뒤에 리스트, 튜플,
문자열과 같은 값이 여러 개 있는 것을 뒤쪽에 넣어줍니다

3627
03:57:36,280 --> 03:57:40,780
그리고 안에 수행할 반복할 문장을
적어주는데 예제로 한번 보도록 하겠습니다

3628
03:57:41,000 --> 03:57:42,760
전형적인 for문을 한번 볼게요

3629
03:57:42,900 --> 03:57:46,420
테스트 리스트라는 거에 1, 2,
3라는 3개의 값이 들어있어요

3630
03:57:46,520 --> 03:57:49,140
3개의 값이 들어있고 이제 for문을 만났습니다

3631
03:57:49,400 --> 03:57:53,597
그렇다는 거는 i라는 변수를
만들어줬고 변수가 상자의 개념이죠

3632
03:57:53,621 --> 03:57:56,720
그리고 in이라는 키워드 뒤에 리스트가 왔습니다

3633
03:57:56,840 --> 03:57:58,260
그렇다는 건 어떻게 되는 거냐

3634
03:57:58,300 --> 03:58:01,920
리스트에 있는 거를 하나씩 빼서 i에 담습니다.

3635
03:58:01,980 --> 03:58:03,420
For문이 반복하는 거잖아요

3636
03:58:03,580 --> 03:58:06,600
얘를 하나씩 빼서 i에 담는 행위를 반복합니다

3637
03:58:06,820 --> 03:58:09,080
그럼 처음에는 1을 빼서 i에 담았죠

3638
03:58:09,140 --> 03:58:13,220
그런 다음에 이 print i로
출력하면 처음에 1이 출력이 됩니다

3639
03:58:13,480 --> 03:58:21,000
그 다음에 1을 하고 끝냈으니까 다시 돌아와서는 2를
가져와서 i에 담고 프린트를 하기 때문에 2가 출력이 되고요

3640
03:58:21,100 --> 03:58:23,596
그 다음에 3를 가져와서 담고 또 출력이 됩니다

3641
03:58:23,620 --> 03:58:25,256
그리고 1을 하고 끝냈으니까 2가
출력을 하기 때문에 3가 출력이 됩니다

3642
03:58:25,280 --> 03:58:30,780
한번 실행을 해보면 1, 2, 3가
순차적으로 하나씩 i에 담겨서 출력이 됩니다

3643
03:58:30,940 --> 03:58:35,340
그래서 이거를 좀 직관적으로 보려면
마찬가지로 디버깅을 해보면 볼 수가 있겠죠

3644
03:58:35,480 --> 03:58:36,940
네, 1, 2, 3라는 리스트가 있어요

3645
03:58:37,080 --> 03:58:41,240
그리고 이 form은 한 번 실행하면
여기서 첫 번째 것부터 빼옵니다

3646
03:58:41,320 --> 03:58:42,860
그럼 i가 1이 됩니다, 여기서

3647
03:58:43,000 --> 03:58:45,940
여기서 이거 처음부터 빼웠기 때문에 i가 1이에요

3648
03:58:46,080 --> 03:58:48,440
그러면 프린트를 하면 이렇게 1이 출력이 되겠죠

3649
03:58:48,560 --> 03:58:52,180
그다음에는 두 번째는 테스트
리스트의 두 번째 2를 빼옵니다

3650
03:58:53,620 --> 03:58:54,300
처음에는 이걸 빼오겠죠

3651
03:58:54,440 --> 03:58:55,760
이걸 출력해서 3가 됩니다

3652
03:58:55,920 --> 03:59:03,920
즉, 좀 간단하게 요약하면 in 뒤에 있는 이 어떤 리스트나 뭐 튜플이나
뭐 문자열이 있을 때 그거를 다 쪼개서 하나씩 가져오는 의미입니다

3653
03:59:05,440 --> 03:59:13,440
그래서 리스트 같은 거는 이렇게 쭉 있으면 하나씩 빼와서 넣고 출력하고
또 넣고 출력하고를 계속 반복하다가 이게 끝날 때까지 반복을 하는 거죠

3654
03:59:15,600 --> 03:59:17,520
그래서 form는 이렇게 사용이 됩니다

3655
03:59:17,800 --> 03:59:19,780
그러면 좀 더 직관적이긴 하겠죠

3656
03:59:19,880 --> 03:59:27,220
왜냐하면 이 리스트를 하나씩 빼오면서 반복한다라는
의미니까 코드를 보면 와일몬보다 좀 더 단순하게 쓸 수가 있습니다

3657
03:59:27,440 --> 03:59:30,000
그래서 실제로 예제들을 한번 보도록 하겠습니다

3658
03:59:30,180 --> 03:59:32,360
다양한 포문의 활용을 보도록 하겠습니다

3659
03:59:32,700 --> 03:59:35,180
네, 그러면 이게 어떻게 흘러갈지 한번 보도록 하겠습니다

3660
03:59:35,460 --> 03:59:36,780
네, a란 리스트가 있어요

3661
03:59:36,980 --> 03:59:41,500
리스트에는 각각 이 0번째, 1번째,
2번째에 튜플이 들어가 있습니다

3662
03:59:41,720 --> 03:59:43,660
튜플, 튜플, 튜플이 들어가 있죠

3663
03:59:43,760 --> 03:59:48,840
그리고 in하고 그 a가 지금 여기 들어가
있으니까 포문 안쪽에 변수가 있고요.

3664
03:59:49,040 --> 03:59:50,040
A가 이렇게 돼 있죠

3665
03:59:50,120 --> 03:59:57,872
그렇다는 거는 하나씩 뽑아서 넣는다니까 a가
있고 in이 있으니까 처음에는 1, 2를 가져와서 얘를

3666
03:59:57,896 --> 04:00:05,420
이렇게 하나씩 넣고 2는 이렇게 넣고 이렇게 등호가
계속 얘가 바꿔가면서 하나씩 있다고 보시면 되겠습니다

3667
04:00:05,580 --> 04:00:09,200
그래서 이거는 좀 이해를 하기 위해서
또 디버깅을 돌려보도록 하겠습니다

3668
04:00:09,380 --> 04:00:11,660
네, 그러면 처음에 a라는 걸 정의를 해줬고요

3669
04:00:11,760 --> 04:00:12,960
그다음에 포문을 만납니다

3670
04:00:13,100 --> 04:00:17,380
그러면 a라는 값이 이제 이 리스트니까
여기서 하나씩 빼오는 게 되겠죠

3671
04:00:17,500 --> 04:00:19,460
그럼 첫 번째 걸 빼오면 뭘 빼오는가요?

3672
04:00:19,580 --> 04:00:22,777
이 1, 2, 여기 있는 0번째에 있는 이 튜플을 빼옵니다

3673
04:00:22,801 --> 04:00:24,560
그 이전 시간에 배운 거 기억나시나요?

3674
04:00:24,620 --> 04:00:28,436
이렇게 a, b가 있으면 이렇게
각각 할당된다고 말씀드렸었죠.

3675
04:00:28,460 --> 04:00:30,960
A는 1이고 b는 2가 된다

3676
04:00:31,000 --> 04:00:33,900
이렇게 말씀드렸었는데 여기서도 적용이 됩니다

3677
04:00:34,200 --> 04:00:38,880
그래서 1, 2를 지금 빼왔으니까
처음에는 1, 2랑 1, 2를 여기에 넣어줍니다

3678
04:00:39,200 --> 04:00:41,740
그러면 first가 1이 되고 last가 2가 됩니다

3679
04:00:41,940 --> 04:00:44,360
그래서 이게 두 개를 더해주면 3이 출력이 되죠

3680
04:00:44,440 --> 04:00:45,940
그다음에 다음은 뭐가 될까요?

3681
04:00:46,040 --> 04:00:47,880
3, 4가 여기 들어가서 들어가겠죠

3682
04:00:48,020 --> 04:00:50,900
그래서 first는 3이 되고 last는 4가 됩니다

3683
04:00:51,100 --> 04:00:53,420
그래서 두 개를 더하면 7이... 출력이 되겠죠

3684
04:00:53,540 --> 04:00:57,200
그다음에 또 for문을 만났으니
이제 마지막 거 5, 6을 뽑아오겠죠

3685
04:00:57,360 --> 04:01:02,300
뽑아와서 first, last에 넣어주면 5,
6을 더해준 결과가 11이 출력이 됩니다

3686
04:01:02,520 --> 04:01:07,700
그리고는 이제 a를 다 돌았기 때문에
종료가 돼서 for문을 빠져나옵니다

3687
04:01:07,860 --> 04:01:11,760
샤르 님께서 질문 주셨는데 for문하고
while문하고 무슨 차이가 있는 건가요?

3688
04:01:12,040 --> 04:01:13,180
용도가 좀 다릅니다

3689
04:01:13,340 --> 04:01:21,340
For문은 어떤 리스트나 문자열이나 튜플이나 이런 여러 개
자료가 담긴 것을 하나씩 뽑아와서 쓸 때 그때 for문을 쓰고요.

3690
04:01:22,800 --> 04:01:30,045
While문은 아까 뭐 커피 예제나 뭐나 이런 거 봤듯이
어떤 상황을 그냥 주어지고 계속 반복하는 걸 기본으로

3691
04:01:30,069 --> 04:01:36,400
해서 그걸 뭐 빠져나오거나 아니면 어떤 조건이
틀어질 때 끝나거나 이런 걸 만들어주는 게 while문입니다

3692
04:01:36,540 --> 04:01:40,840
즉 for문은 어떤 리스트를 돌 때
라고 생각하시면 좀 편할 것 같아요

3693
04:01:40,940 --> 04:01:44,340
여러 개의 리스트를 하나씩
하나씩 쓸 때 그렇게 쓰시면 됩니다

3694
04:01:44,740 --> 04:01:49,960
휴고 님 for 변수를 정해줄 때 a 변수 값
형식 맞게 변수를 지정해 줘야 되는 거죠?

3695
04:01:50,080 --> 04:01:50,540
그렇죠

3696
04:01:50,660 --> 04:01:52,840
만약에 이게 그냥... 어... 뭐가 있을까요?

3697
04:01:52,940 --> 04:01:54,700
근데 안 맞으면 어떻게 되냐?

3698
04:01:54,760 --> 04:01:55,500
이렇게 됩니다

3699
04:01:55,680 --> 04:01:57,440
그냥 first라고만 써줄게요

3700
04:01:57,520 --> 04:01:58,440
그럼 rest가 없죠

3701
04:01:58,520 --> 04:02:02,920
그렇다는 것은 이 first라는 변수
하나에 tuple이 그냥 그대로 담기겠죠

3702
04:02:03,080 --> 04:02:08,720
그래서 tuple이 이렇게 이렇게 이렇게
네, tuple이 하나씩 뽑아져서 출력이 되겠죠

3703
04:02:08,880 --> 04:02:14,131
그래서 변수를 맞춘다는 건 이 모양대로 굳이
나눠주고 싶을 때 그때 이렇게 두 개를 써주면

3704
04:02:14,155 --> 04:02:18,820
그러면 이제 first, second를 둘 다
담아서 이렇게 하나씩 뽑아줄 수가 있겠죠

3705
04:02:19,100 --> 04:02:20,980
뽑아낼 때 while 이렇게 이해 되나요?

3706
04:02:21,740 --> 04:02:23,040
뽑아낼 때는 for문이죠

3707
04:02:23,140 --> 04:02:31,140
그러니까 for문 이렇게 여러 개의 리스트가 있을 때 하나씩 하나씩
뽑으려면 for문을 쓰고 무한 반복하면 while을 쓴다라고 생각하시면 됩니다

3708
04:02:31,880 --> 04:02:32,300
기본적으로

3709
04:02:32,400 --> 04:02:34,140
파이썬은 변수 정의를 안 해줍니다

3710
04:02:34,280 --> 04:02:38,340
Start는 뭔가 기본 변수를
정의를 시작하고 안 해도 됩니다

3711
04:02:38,640 --> 04:02:42,740
그냥 바로 변수를 만들자마자 여기서
이렇게 할당을 해 줄 수가 있습니다

3712
04:02:42,940 --> 04:02:48,080
네, 그래서 for문을 어떤 식으로 활용하는지 실질적인
예시를 한번 보면은 좀 더 이해가 되실 것 같습니다

3713
04:02:48,320 --> 04:02:50,157
실질적인 for문을 어떻게 쓰나?

3714
04:02:50,181 --> 04:02:51,440
예제를 보도록 하겠습니다

3715
04:02:51,620 --> 04:02:56,140
자, 여기 max라는 변수에
학생들의 시험 점수를 담아놨습니다

3716
04:02:56,260 --> 04:02:57,680
90, 25 뭐 이렇게 쭉 있잖아요

3717
04:02:58,060 --> 04:03:00,740
점수에 따라서 몇 번 학생이 합격입니다

3718
04:03:00,800 --> 04:03:02,000
이거를 표시해 주고 싶어요

3719
04:03:02,080 --> 04:03:07,400
즉, 얘는 0번 학생인데 0번 학생이라고
나오면 이상하니까 플러스 1을 해줬습니다

3720
04:03:07,520 --> 04:03:14,140
그래서 1번 학생부터 시작하도록 얘는 만들어준 거고
즉, 학생이 지금 둘, 셋, 넷, 다섯 명 있다고 생각해 볼게요

3721
04:03:14,200 --> 04:03:22,200
학생이 다섯 명 있으면 이 학생 중에 하나씩 하나씩 뽑아서 학생들을
이 점수가 예를 들어 60점 이상이면 합격이라는 기준이 있다고 해볼게요

3722
04:03:22,380 --> 04:03:23,980
얘는 합격, 60점 이상이니까

3723
04:03:24,080 --> 04:03:27,160
얘는 불합격, 얘는 합격, 얘는 불합격, 얘는 합격

3724
04:03:27,220 --> 04:03:28,500
이렇게 표시를 해줄 수가 있겠죠

3725
04:03:28,660 --> 04:03:33,460
근데 이거는 그냥 사람이 지금 보면서 하나씩 하나씩
했는데 이 과정을 이제 프로그래밍으로 할 수가 있습니다

3726
04:03:33,660 --> 04:03:41,520
그래서 실제로 이렇게 실행을 먼저 해보면 1번 학생은 합격,
지금 1번 학생 합격, 2번 불합격, 3번 합격, 4번 불합격, 5번 합격

3727
04:03:41,580 --> 04:03:42,140
이렇게 나오죠

3728
04:03:42,200 --> 04:03:45,780
이게 어떻게 되는지 하나씩 디버깅
걸어보면서 보도록 하겠습니다

3729
04:03:46,020 --> 04:03:47,020
하나씩 돌려볼게요

3730
04:03:47,160 --> 04:03:50,156
자, 그러면 먼저 max라는 거에 점수들을 정의하고

3731
04:03:50,180 --> 04:03:50,660
정의를 해줬습니다

3732
04:03:50,740 --> 04:03:52,800
그리고 학생에게 붙여줄 번호죠

3733
04:03:52,920 --> 04:03:56,660
일단 0번인데 이걸 1 더해서
1번 학생으로 먼저 만들었어요

3734
04:03:56,800 --> 04:03:59,640
그래서 넘버가 지금 0이었다가 처음에 1이 됐습니다

3735
04:03:59,820 --> 04:04:05,380
들어가서 Max 처음에 1번이 90점 하나씩
뽑아온다고 했으니까 지금 max는 90입니다

3736
04:04:05,520 --> 04:04:05,900
왜냐?

3737
04:04:05,960 --> 04:04:08,500
이 form는 여기서 하나씩 뽑아오는 거죠

3738
04:04:08,640 --> 04:04:11,000
하나씩 뽑아서 지금은 90이 들어갔습니다

3739
04:04:11,140 --> 04:04:18,060
그래서 지금 이 상황에서 지금 1번 학생은 90점이기 때문에
안으로 들어가서 1번 학생은 합격입니다가 출력이 됐습니다

3740
04:04:18,200 --> 04:04:20,380
넘어가서 Max 이제 두 번째를 거쳐서 맞췄죠

3741
04:04:20,420 --> 04:04:25,640
그렇다는 거는 이제 두 번째 거, 이 첫 번째
거 끝났고 두 번째 거 뽑아서 max에 넣은 거죠

3742
04:04:25,760 --> 04:04:30,520
여기 Max 두 번째 거 뽑아서 넣은 다음에
다음 구문이 실행돼서 이번엔 25점이에요

3743
04:04:30,660 --> 04:04:33,500
그러면 이 구문을 만족 안 하니까 else가 되겠죠.

3744
04:04:33,620 --> 04:04:38,280
Else로 이동을 해서 출력을 해보면
2번 학생은 불합격입니다가 출력이 되겠죠

3745
04:04:38,400 --> 04:04:41,320
이런 식으로 계속 하나씩 뽑아오는 걸 볼 수가 있습니다

3746
04:04:41,500 --> 04:04:42,380
다음엔 67이죠

3747
04:04:42,480 --> 04:04:47,620
뽑아왔고 67은 또 넘으니까
이상이니까 합격입니다가 출력이 됩니다

3748
04:04:47,820 --> 04:04:50,000
이런 식으로 쭉쭉 뽑아올 수가 있겠습니다

3749
04:04:50,160 --> 04:04:56,366
그래서 디버깅을 돌려서 실행을 해보시면
언제 합격, 언제 불합격이 왜 표시가 되는지 그리고

3750
04:04:56,390 --> 04:05:00,900
for문을 언제 쓰는지 이렇게 하나씩 뽑아올
때 쓴다라고 이해를 할 수가 있겠습니다

3751
04:05:01,460 --> 04:05:05,760
그래서 이거는 이제 디버깅을 통해서
실습을 하셨으면 좀 이해가 되실 것 같습니다

3752
04:05:06,100 --> 04:05:08,480
그 다음에 for문과 continue문에
대해서 배워보겠습니다.

3753
04:05:08,760 --> 04:05:12,260
For문도 반복문이다 보니까
continue가 있고 break가 있어요

3754
04:05:12,400 --> 04:05:14,520
그래서 그걸 하나씩 실습을 해보겠습니다

3755
04:05:14,980 --> 04:05:20,136
그럼 마찬가지로 이 max의 점수들이 쭉 담겨
있고 그 학생들 한 명씩 한 명씩 보도록 하겠습니다

3756
04:05:20,160 --> 04:05:24,360
그러면 또 break포인트를
처음에 걸고 실행을 해보겠습니다

3757
04:05:25,840 --> 04:05:28,240
네, 그러면 일단 max를 정의해놨고요

3758
04:05:28,340 --> 04:05:29,360
이 form은 이게 핵심이죠

3759
04:05:29,480 --> 04:05:30,480
하나씩 뽑아온다

3760
04:05:30,520 --> 04:05:32,480
즉, 처음에는 90을 뽑아오겠죠

3761
04:05:32,660 --> 04:05:34,420
Mark가 90으로 시작합니다

3762
04:05:34,580 --> 04:05:42,480
리스트를 다 쓸 때까지 반복이 되는데 그러면 number는 1번부터
시작하려고 이렇게 해놨고 그러면 mark가 60점 이하인가를 봤을 때 이상이죠

3763
04:05:42,600 --> 04:05:46,640
그렇기 때문에 바로 1번 학생
축하합니다, 합격입니다가 출력이 됩니다

3764
04:05:46,840 --> 04:05:48,880
그 다음에 두 번째를 뽑아오는 게 되겠죠

3765
04:05:49,000 --> 04:05:50,136
그러면 두 번째는 20점입니다

3766
04:05:50,160 --> 04:05:52,580
25니까 25를 뽑아서 여기에 넣었습니다

3767
04:05:52,740 --> 04:05:55,800
그러면 mark가 25니까 60점보다 작죠

3768
04:05:55,880 --> 04:05:58,140
그렇기 때문에 이 continue를 만나게 됩니다

3769
04:05:58,360 --> 04:06:01,540
그러면 continue를 만나면 이전과 똑같습니다.

3770
04:06:01,600 --> 04:06:03,980
While문처럼 다시 처음으로 돌아갑니다

3771
04:06:04,060 --> 04:06:08,280
즉, 이 아래쪽에 있는 print문을 실행
안 하고 다시 처음으로 돌아갑니다

3772
04:06:08,940 --> 04:06:14,760
실제로 보면 실행을 해보면 continue를 만나서
아래쪽을 실행 안 하고 올라가는 걸 볼 수 있죠

3773
04:06:14,860 --> 04:06:15,980
이렇게 올라갑니다

3774
04:06:16,060 --> 04:06:18,197
다 소진을 했으면 이제 종료가 됩니다

3775
04:06:18,221 --> 04:06:20,820
그래서 for문은 그냥 다 소진하는 개념입니다

3776
04:06:20,940 --> 04:06:24,920
이 리스트가 있으면 하나씩
하나씩 돌면서 다 쓰면 종료가 됩니다

3777
04:06:25,140 --> 04:06:28,600
그 다음에 for문과 함께 자주 사용되는
range 함수를 보도록 하겠습니다.

3778
04:06:28,800 --> 04:06:32,860
Range는 뭔지 한번 출력을 해보면
이렇게 범위를 나타낼 때 씁니다

3779
04:06:32,940 --> 04:06:38,340
그냥 실행을 하면 이렇게 range가
나오는데 이거가 어떤 거냐면 이런 거 있잖아요

3780
04:06:38,520 --> 04:06:45,920
1, 2, 3, 4 해서 쭉쭉쭉 해서 막 100까지 만들고
싶은데 이렇게 되면 이걸 쓰기가 너무 귀찮잖아요

3781
04:06:46,120 --> 04:06:47,297
범위를 지정을 해줍니다

3782
04:06:47,321 --> 04:06:54,160
그래서 range라고 쓰고 1부터 100까지 쓰고
싶으면 이렇게 쓰면 range로 한 번에 쓰게 됩니다

3783
04:06:54,360 --> 04:06:58,360
그래서 이거를 이렇게 쓴다라고
이해하신 다음에 예제를 보도록 하겠습니다

3784
04:06:58,880 --> 04:06:59,960
이 예제를 보겠습니다

3785
04:07:00,240 --> 04:07:01,540
Add가 처음에 0이에요

3786
04:07:01,800 --> 04:07:09,800
근데 range라는 건 아까 설명드렸다시피 이게 어떤 거랑 같냐면
이것도 그 이상 미만, 그 슬라이싱 할 때처럼 1 이상 10일 미만입니다

3787
04:07:11,880 --> 04:07:15,057
즉, 그 부등식으로 표현하자면 사실상 이거랑 같습니다

3788
04:07:15,081 --> 04:07:17,240
이렇게 뽑아 쓸 수 있는 range를 만들어줍니다

3789
04:07:17,300 --> 04:07:19,580
한 번 디버깅으로 또 하나씩 실행을 해보겠습니다

3790
04:07:19,800 --> 04:07:22,240
이제 range에서 뽑아오니까 1부터 뽑아옵니다

3791
04:07:22,640 --> 04:07:24,040
그러면 i가 지금 1이죠

3792
04:07:24,180 --> 04:07:26,900
그래서 0 더하기 1 해서 add가 1이 됐고요

3793
04:07:27,000 --> 04:07:28,720
또 그다음에는 2를 뽑아옵니다

3794
04:07:28,800 --> 04:07:34,620
즉, range 범위는 몇부터 몇까지 쭉 있는 상태에서
하나씩 하나씩 뽑아오는 거라 1씩 증가가 되겠죠

3795
04:07:34,740 --> 04:07:40,443
그래서 i가 지금 계속 1씩 증가하고
add는 i 값이 계속 더해져서 1 더하기 2

3796
04:07:40,467 --> 04:07:44,857
더하기 3 더하기 4 더하기 5 더하기
해서 쭉쭉 더해지는 걸 볼 수가 있습니다

3797
04:07:44,881 --> 04:07:46,860
그래서 i는 지금 1씩 올라가고 있죠

3798
04:07:46,980 --> 04:07:54,980
그래서 이렇게 하나씩 range를 쓰는 이유는 리스트를 쭉 길게
쓰기가 귀찮으니까 range로 쓴다라고 이해하시면 좋을 것 같습니다

3799
04:07:56,980 --> 04:07:58,960
그래서 for문이랑 같이 많이 쓰입니다

3800
04:07:59,360 --> 04:08:06,000
그래서 여기 이걸 쓰면 최종 55가 되는 이유가
1부터 순서대로 10까지 뽑아오기 때문에 그렇습니다

3801
04:08:06,200 --> 04:08:08,940
그러면 이제 구구단 코드를 보도록 하겠습니다

3802
04:08:09,300 --> 04:08:12,540
구구단에서 이제 처음으로 이중 for문이 나옵니다

3803
04:08:12,700 --> 04:08:14,520
반복문 안에 반복문

3804
04:08:14,880 --> 04:08:18,100
이 들어가는 그런 코드가 나오는데 한번 보도록 하겠습니다

3805
04:08:18,300 --> 04:08:21,100
그러면 이때는 반복문이 두 개가 쓰였어요

3806
04:08:21,200 --> 04:08:24,940
그래서 어떤 건지 하나씩 실행을 해보면서 보도록 하겠습니다

3807
04:08:25,180 --> 04:08:28,660
그러면 이 반복문 안에 이 안에 이 코드가 들어있는 거예요

3808
04:08:28,780 --> 04:08:35,560
그런데 이 코드가 뭐든지 간에 일단 2부터
10까지니까 콤마 쩜쩜쩜쩜해서 9까지가 반복되는 거겠죠

3809
04:08:35,660 --> 04:08:40,100
Range로 보면 2부터 9까지
하나씩 뽑아와서 i에 넣는 겁니다

3810
04:08:40,300 --> 04:08:42,597
그래서 안쪽에 계속 반복이 되는 거고요

3811
04:08:42,621 --> 04:08:45,240
그러면 안쪽에 있는 for문은 이렇게 생겼죠

3812
04:08:45,280 --> 04:08:51,310
그러면 이 안에 print 이 문장을 j도
하나씩 뽑아와서 1부터 땡땡땡해서 9까지

3813
04:08:51,334 --> 04:08:57,360
중에 하나씩 뽑아와서 j에 넣은 다음에 이걸
출력하고 반복하는 이 코드가 반복이 되겠죠

3814
04:08:57,500 --> 04:09:01,480
그러면 이거를 또 디버깅을 통해서
어떻게 출력되는지 보도록 하겠습니다

3815
04:09:01,720 --> 04:09:03,600
처음에 i에 2가 담깁니다

3816
04:09:03,680 --> 04:09:04,900
이거는 어떻게 담겼을까요?

3817
04:09:05,000 --> 04:09:07,520
Range니까 2부터 9까지잖아요

3818
04:09:07,700 --> 04:09:08,600
10 미만이니까

3819
04:09:08,720 --> 04:09:11,457
그럼 처음 거인 2가 지금 i에 담긴 겁니다

3820
04:09:11,481 --> 04:09:13,660
그 다음에 이 안쪽 반복문으로 들어갔죠

3821
04:09:13,700 --> 04:09:15,620
J에는 처음에 1이 담깁니다

3822
04:09:15,680 --> 04:09:17,620
왜냐하면 이렇게 뽑아온 거니까

3823
04:09:17,760 --> 04:09:21,480
여기서 range에서 1부터 뽑아왔으니까 j는 1이죠

3824
04:09:21,680 --> 04:09:26,200
그래서 처음에는 print 2 곱하기
1을 하니까 2가 출력이 됩니다

3825
04:09:26,440 --> 04:09:30,440
그리고 end 이거는 뒤에 설명드릴
텐데 그냥 띄어쓰기를 해주겠다는 겁니다

3826
04:09:30,580 --> 04:09:33,140
원래는 한 줄씩 아래로 프린트할 때마다 내려가잖아요

3827
04:09:33,340 --> 04:09:39,520
근데 end는 어떤 기능이냐면 그냥 한 줄씩 내려가는
걸 방지하고 그냥 띄어쓰기로 대체를 하겠다는 뜻입니다

3828
04:09:39,680 --> 04:09:40,717
그래서 이거를 출력해보면

3829
04:09:40,741 --> 04:09:47,297
2가 나왔고 그 다음에 range의 다음 값인 2를
가져와서 이제 j가 원래 1이었는데 이렇게 2로 바뀌었죠

3830
04:09:47,321 --> 04:09:51,540
그래서 2로 가져와서 이번엔 2
곱하기 1이 돼서 또 4를 출력합니다

3831
04:09:51,700 --> 04:09:54,000
근데 왜 여기를 못 빠져나가냐?

3832
04:09:54,040 --> 04:09:59,840
왜냐하면 얘도 반복문이기 때문에 이거를 다 소진한
다음에 이 아래쪽으로 내려가서 이걸 실행할 수 있겠죠

3833
04:09:59,920 --> 04:10:00,300
처음으로

3834
04:10:00,340 --> 04:10:02,520
그렇기 때문에 얘가 무한 반복됩니다

3835
04:10:02,600 --> 04:10:04,020
이 range를 다 소진할 때까지

3836
04:10:04,100 --> 04:10:06,556
실행해보면 계속 이 안에가 반복돼요

3837
04:10:06,580 --> 04:10:09,277
계속 반복돼서 그래서 18까지 가고

3838
04:10:09,301 --> 04:10:10,960
이제 9가 마지막이죠

3839
04:10:11,040 --> 04:10:12,680
J는 9가 마지막입니다

3840
04:10:12,820 --> 04:10:13,880
여기 안쪽 부분은

3841
04:10:13,920 --> 04:10:16,140
9까지 땡겨온 다음에는 이제 끝났어요

3842
04:10:16,240 --> 04:10:17,420
더 이상 땡겨올 게 없습니다

3843
04:10:17,760 --> 04:10:22,280
그러면 이 안쪽에 반복문이 종료되면서
처음으로 이 print가 출력이 됩니다

3844
04:10:22,520 --> 04:10:26,200
그럼 print는 기본적으로 한 줄을 띄워주는 역할을 해요

3845
04:10:26,360 --> 04:10:29,716
지금 빈 문자열을 출력했고 한 줄을 띄워준다

3846
04:10:29,740 --> 04:10:32,460
즉 쭉 써주고 한 줄을 내려줍니다

3847
04:10:32,660 --> 04:10:34,140
그래서 다음 줄로 넘어갔죠

3848
04:10:34,220 --> 04:10:37,997
다시 처음 이걸 만나서 2를 아까 뽑아왔기 때문에

3849
04:10:38,021 --> 04:10:40,560
다음 값인 2 다음 값인 3이죠

3850
04:10:40,640 --> 04:10:42,480
3을 뽑아와서 이제 i에 넣어줬어요

3851
04:10:42,540 --> 04:10:44,260
그 다음에 이제 또 실행을 해보면

3852
04:10:44,360 --> 04:10:46,360
J는 또 다시 이제 1부터 시작하죠

3853
04:10:46,460 --> 04:10:50,100
다시 이게 다 종료된 다음에 또 다시 들어온 거니까

3854
04:10:50,180 --> 04:10:51,560
J가 다시 만난 겁니다

3855
04:10:51,780 --> 04:10:53,640
이제 1부터 하나씩 뽑아오겠죠

3856
04:10:53,760 --> 04:10:56,216
1 뽑고 그러면 1 곱하기 3 돼서

3857
04:10:56,240 --> 04:10:58,600
그러니까 3 곱하기 1 돼서 3이 나왔고

3858
04:10:58,680 --> 04:11:02,360
다음에 2를 뽑아왔으니까 3 곱하기 2 돼서 6이 나왔고

3859
04:11:02,420 --> 04:11:04,940
3 뽑아왔으니까 3 곱하기 3이 돼서 9가 나왔고

3860
04:11:05,020 --> 04:11:07,637
이런 식으로 쭉 안쪽에 있는 게 반복이 됩니다

3861
04:11:07,661 --> 04:11:13,477
쭉 반복돼서 마찬가지로 9가 나온
다음에는 이 for문을 이제는 빠져나옵니다

3862
04:11:13,501 --> 04:11:16,460
그 프린트를 만나서 다시 한 줄을 띄워주고

3863
04:11:16,560 --> 04:11:21,400
그 다음에 이제 레인지에서 뽑아오는 게
3까지 뽑아왔으니 4를 뽑아와서 i에 넣겠죠

3864
04:11:21,600 --> 04:11:27,860
4가 되고 마찬가지로 다시 안쪽 for문을
만나서 이 안에 레인지를 소진할 때까지 돕니다

3865
04:11:28,000 --> 04:11:36,000
그래서 쭉 돌고 마찬가지로 9까지 돈 다음에 더 이상 이제 for문에
뽑아올 값이 없으니까 그 아래로 내려가서 프린트가 출력되고 한 줄 띄워주고

3866
04:11:37,161 --> 04:11:40,000
그 다음에 다음 i 값인 5를 가져옵니다

3867
04:11:40,040 --> 04:11:43,340
그래서 이게 쭉 반복이 되면 99단이 계속 찍히겠죠

3868
04:11:43,500 --> 04:11:49,540
그럼 바깥쪽 for문인 i가 다 소진될 때까지
그러면 이 10 미만이니까 9가 마지막 범위죠

3869
04:11:49,600 --> 04:11:56,860
그래서 9단까지 이렇게 쭉 출력이 된 다음에 만나고 이제
다시 첫 번째 줄로 돌아왔을 때 이 레인지 값이 다 소진이 됐어요

3870
04:11:56,940 --> 04:12:00,500
이미 9까지 다 썼고 10
미만이니까 10은 포함이 안 되죠

3871
04:12:00,580 --> 04:12:05,160
그래서 이 코드가 드디어 모든
반복문을 마치고 종료가 됩니다

3872
04:12:05,680 --> 04:12:05,700
네

3873
04:12:05,760 --> 04:12:06,960
이거 이해가 되시나요?

3874
04:12:07,000 --> 04:12:07,117
네

3875
04:12:07,141 --> 04:12:07,136
이거 이해가 되시나요?

3876
04:12:07,160 --> 04:12:14,620
약간 어려울 수 있는데 for문이 두 개여서 이거를 디버깅을
걸면서 한 줄 한 줄씩 보다 보시면은 조금 이해가 되실 것 같습니다

3877
04:12:14,800 --> 04:12:22,800
그래서 기본적으로 이 for문은 이 레인지에 있는 이 범위를 다 하나씩
하나씩 뽑아가면서 다 소진을 하면 이제 for문을 빠져나가서 종료가 됩니다

3878
04:12:23,980 --> 04:12:24,180
네

3879
04:12:24,260 --> 04:12:25,440
이렇게 쓰실 수가 있겠습니다

3880
04:12:25,900 --> 04:12:33,500
그래서 이 레인지를 이용해서 이렇게 뽑아보는 거를 이렇게 표로
그리셔도 좋은데 이거는 디버깅을 찍어보시면 좀 더 이해가 편하실 것 같아요

3881
04:12:33,800 --> 04:12:35,877
그래서 이렇게 출력을 할 수가 있겠습니다

3882
04:12:35,901 --> 04:12:43,901
그리고 그냥 추가로 설명을 드리면 이 프린트 뒤에 end
이거는 뭐냐면 이렇게 그냥 프린트라고 쓰면은 1, 2, 3, 4, 5,

3883
04:12:44,241 --> 04:12:49,880
6, 7, 8, 9, 10이 그냥 순사적으로 뽑아내서
이렇게 쭉 엔터를 친 상태로 쭉 뽑아주게 돼요

3884
04:12:50,060 --> 04:12:54,240
즉 프린트가 기본적으로 그 엔터 키를 포함하고 있습니다

3885
04:12:54,640 --> 04:12:56,280
그 줄바꿈 문자 혹시 기억나시나요?

3886
04:12:56,380 --> 04:13:00,940
그 두 번째 시간에 배웠는데 이 줄바꿈 문자를
기본적으로 프린트 함수가 포함하고 있습니다

3887
04:13:01,120 --> 04:13:02,780
그래서 이거를 막아주려면 어떻게 해야 되냐

3888
04:13:02,840 --> 04:13:05,640
그 뒤에 변수 중에 end라는 걸 추가해서

3889
04:13:05,900 --> 04:13:09,960
여기에 end 즉 원래는 기본적으로
이게 기본적으로 들어갑니다

3890
04:13:10,040 --> 04:13:16,325
그래서 이거랑 그냥 아무것도 안 넣은 거랑 똑같은데
이 자리에 이 한 줄 띄워주는 거 대신에 뭐 띄어쓰기를

3891
04:13:16,349 --> 04:13:22,400
추가하겠다 라고 하면 출력을 해보면 이제는 이렇게
띄어쓰기가 추가돼서 한 줄로 쭉 출력이 된 걸 볼 수가 있죠

3892
04:13:22,520 --> 04:13:30,520
그래서 이거는 줄바꿈 문자가 원래 기본으로 돼 있는데 이거를 띄어쓰기로
넣어주면 이렇게 출력이 되고 뭐 좀 더 복잡하게는 to 더 이런 거 붙이면은

3893
04:13:31,761 --> 04:13:35,400
1 to the, 2 to the, 3 to the,
4 to the, 5 to the에 쭉 나가죠

3894
04:13:35,460 --> 04:13:35,777
네

3895
04:13:35,801 --> 04:13:35,876
그래서 이렇게

3896
04:13:35,900 --> 04:13:36,900
그래서 이게 그냥 end

3897
04:13:37,240 --> 04:13:39,980
프린트하고 나서 뒤에 쓸 거를 하나 추가해 주는 겁니다

3898
04:13:40,160 --> 04:13:46,060
그래서 마지막 줄 프린트를 하면은 왜 한 줄 내려가죠
라고 하면은 이게 한 줄 내리는 명령어기 때문입니다

3899
04:13:46,360 --> 04:13:50,309
기본적으로 아무것도 안 쓰지만 한
줄 내리기 때문에 1 to the, 2 to the,

3900
04:13:50,333 --> 04:13:53,940
한 줄 내리고 3 to the가 하는 게
이게 한 줄 내리는 역할을 하기 때문이죠

3901
04:13:54,100 --> 04:13:54,277
네

3902
04:13:54,301 --> 04:13:57,160
그래서 end는 그냥 뒤에 붙이는
거다라고 이해하시면 좋을 것 같습니다

3903
04:13:57,420 --> 04:14:01,980
아무튼 이렇게 해서 구구단까지 했고
그다음에 그 패션 코딩 하나 배워보겠습니다

3904
04:14:02,240 --> 04:14:05,857
또 패션 코딩 한번 배워줘야 이제 어디 가서 아 좀 코딩이

3905
04:14:05,881 --> 04:14:07,800
코딩 좀 멋있게 쓴다 이런 말 들을 수 있으니까

3906
04:14:08,000 --> 04:14:08,540
네

3907
04:14:08,620 --> 04:14:09,620
리스트 컴프리엔션

3908
04:14:10,200 --> 04:14:14,460
실전에서 아예 안 써도 되지만 그냥
패션을 위해서 하나 배워보겠습니다

3909
04:14:14,620 --> 04:14:17,420
리스트 컴프리엔션은 또 줄여 쓰는 방법을 배우는 거죠

3910
04:14:17,700 --> 04:14:19,940
멋있게 줄일 수 있냐 배워보도록 하겠습니다

3911
04:14:20,440 --> 04:14:22,960
아 이거 딱 봐도 좀 길어요

3912
04:14:23,100 --> 04:14:24,320
이게 어떤 거냐

3913
04:14:24,480 --> 04:14:28,420
A라는 리스트가 있고 그러면 a가 사실상 이렇게 된 거죠

3914
04:14:28,540 --> 04:14:30,720
그래서 여기서 하나씩 뽑아서 num에 넣는 겁니다

3915
04:14:30,840 --> 04:14:33,500
하나씩 뽑아서 num에 넣고 그거를 출력하는 건데

3916
04:14:33,700 --> 04:14:34,277
네

3917
04:14:34,301 --> 04:14:39,180
결국에 여기 있는 걸 뽑아서 곱하기
3을 한 다음에 그 리절트에 담아주는 거죠

3918
04:14:39,300 --> 04:14:41,600
이 리절트라는 리스트가 비어 있어요

3919
04:14:41,900 --> 04:14:46,560
Num을 3을 곱해서 그거를
append 여기에 추가를 해주는 거니까

3920
04:14:46,640 --> 04:14:52,420
이 빈 리스트에 하나씩 3을
곱해서 36912가 추가가 되겠죠

3921
04:14:52,620 --> 04:14:55,080
이렇게 하나씩 하나씩 돌면서 추가가 되니까

3922
04:14:55,380 --> 04:14:59,020
그래서 이거를 지금 만들어 줄
건데 이렇게 쓰면 너무 길어요

3923
04:14:59,120 --> 04:15:01,540
좀 간략하게 써보고 싶다라고 하면 어떻게 쓰냐

3924
04:15:01,580 --> 04:15:03,137
이렇게 멋있게 쓸 수가 있습니다

3925
04:15:03,161 --> 04:15:04,920
일단 이거는 비슷해요

3926
04:15:05,000 --> 04:15:09,520
그러니까 조건부 표현식에서도 그랬지만
일단은 여기는 처음에 결과를 먼저 씁니다

3927
04:15:09,580 --> 04:15:11,116
Num 곱하기 3을 넣을 거잖아요

3928
04:15:11,140 --> 04:15:16,080
결국 그래서 num 곱하기 3을 먼저 써주고
그다음에 이 순서대로 이렇게 써줍니다

3929
04:15:16,160 --> 04:15:19,560
즉 for num 그다음에 in a가 여기 뒤에 들어갔죠

3930
04:15:19,600 --> 04:15:23,680
그렇다는 거는 num 곱하기 3을 일단
넣을 건데 이 num이 어떻게 나왔냐.

3931
04:15:23,740 --> 04:15:29,280
A를 순회하면서 하나씩 뽑아서 num을 만들 거야
라고 이런 식으로 한 줄 표현을 할 수가 있습니다

3932
04:15:29,460 --> 04:15:32,257
그다음에 지금 여기 대괄호 리스트 안에 넣어줬죠

3933
04:15:32,281 --> 04:15:37,620
그렇다는 거는 결국에 num 곱하기 3을 이 뒤에
있는 조건을 통해서 만들어서 넣을 거야라는 의미입니다

3934
04:15:37,720 --> 04:15:41,580
그래서 이렇게 긴 거를 이렇게 한
줄로 멋있게 표현을 할 수가 있습니다

3935
04:15:41,800 --> 04:15:43,960
그래서 패션 코딩 하나 배워봤습니다

3936
04:15:44,280 --> 04:15:45,680
그래서 좀 직관적이긴 하죠

3937
04:15:45,740 --> 04:15:50,744
이렇게 num 곱하기 3을 써주고 이걸
결국 리스트에 담을 건데 이 num이 어디서

3938
04:15:50,768 --> 04:15:54,780
나왔어 라고 하면 이 뒤에서 이런 조건을
통해 나왔다 라고 쓸 수가 있겠습니다

3939
04:15:55,200 --> 04:15:58,880
그래서 좀 어떻게 보면 직관적일 수
있는데 굳이 이렇게 안 써도 되긴 합니다

3940
04:15:59,200 --> 04:16:00,857
좀 더 긴 것도 표현할 수 있어요

3941
04:16:00,881 --> 04:16:01,920
이것도 하나 볼게요

3942
04:16:02,000 --> 04:16:03,800
얘는 좀 더 긴 건데

3943
04:16:03,960 --> 04:16:06,940
그러면 역으로 한번 멋있게 써진 걸 해석을 해보겠습니다

3944
04:16:07,340 --> 04:16:08,960
A가 1, 2, 3, 4가 있어요

3945
04:16:09,320 --> 04:16:12,560
근데 이 result에는 num 곱하기 3을 넣을 거예요

3946
04:16:12,720 --> 04:16:13,460
대충 이해는 가죠

3947
04:16:13,520 --> 04:16:17,200
3 곱한 걸 넣을 거다라는 건
이해가 됐는데 그거는 어디서 나오냐

3948
04:16:17,260 --> 04:16:18,300
이 뒤에서 나옵니다

3949
04:16:18,400 --> 04:16:19,480
하나 더 추가됐죠

3950
04:16:19,520 --> 04:16:19,820
조건이

3951
04:16:20,320 --> 04:16:23,760
이것까지는 아까랑 똑같은데
if 조건을 또 추가를 해줬습니다

3952
04:16:24,080 --> 04:16:25,340
최종 넣을 건 이겁니다

3953
04:16:25,520 --> 04:16:27,320
근데 이 num이 어디서 왔냐.

3954
04:16:27,660 --> 04:16:30,037
A라는 리스트에서 하나씩 뽑아온 게 num인데

3955
04:16:30,061 --> 04:16:37,560
추가로 조건문을 걸어서 num이 2를 나눠서
나머지가 0일 때를 검사한다는 건 짝수인가를 보는 거죠

3956
04:16:37,680 --> 04:16:40,820
짝수 2면은 추가해서 3을 곱하겠다라는 뜻이니까

3957
04:16:40,920 --> 04:16:43,620
이거를 실행해보면 이렇게 6, 12가 나옵니다

3958
04:16:43,700 --> 04:16:47,340
왜냐하면 이 중에 짝수는 2, 4밖에 없기 때문이죠

3959
04:16:47,460 --> 04:16:51,820
그래서 2 곱하기 3은 6이고 4 곱하기
3은 12니까 이렇게 나오는 겁니다

3960
04:16:52,100 --> 04:16:55,780
그래서 패션 코딩을 봤는데 이거를
그러면 좀 풀었으면 어떻게 될까요

3961
04:16:56,000 --> 04:16:56,500
이렇게 됩니다

3962
04:16:56,640 --> 04:16:57,440
그 result 아까

3963
04:16:57,640 --> 04:16:59,700
이 num이 3의 결과를 먼저 써주고.

3964
04:17:00,400 --> 04:17:02,800
For문을 써주고 if문을 써주잖아요

3965
04:17:02,900 --> 04:17:05,680
이걸 풀면 이렇게 순서대로 써집니다

3966
04:17:05,720 --> 04:17:06,860
이렇게 순서대로

3967
04:17:06,900 --> 04:17:11,260
그니까 for문이 먼저 나오고 그 다음에
if문이 나오고 이렇게 append가 있는 거

3968
04:17:11,300 --> 04:17:17,680
이거를 결과부터 먼저 끄집어내고 그 다음에 이
순서대로 이렇게 나열을 해준다라고 생각하시면 됩니다

3969
04:17:18,140 --> 04:17:19,820
패션 코딩 하나만 더 볼까요

3970
04:17:19,960 --> 04:17:21,560
그러면 이 result는 어떻게 될까요

3971
04:17:21,680 --> 04:17:24,720
출력을 해보면 이렇게 나오는데 이게 어떻게 나온 거냐

3972
04:17:24,780 --> 04:17:28,360
일단은 x, y를 리스트 안에 x 곱하기 y를 넣고 싶어요

3973
04:17:28,480 --> 04:17:29,497
이것까지는 이해되시죠

3974
04:17:29,521 --> 04:17:31,180
이 다음에 이걸 어떻게 만드냐

3975
04:17:31,240 --> 04:17:32,336
뒤에 있는 걸로 만듭니다

3976
04:17:32,360 --> 04:17:34,160
뒤에 이거랑 이거가 있죠

3977
04:17:34,280 --> 04:17:38,000
그렇다는 건 이 순서니까 반대로
표현하면 이렇게 표현이 되는 거예요

3978
04:17:38,140 --> 04:17:41,740
즉 for문이 이게 먼저 쓰고 이걸 뒤에 쓰고 이런 거니까

3979
04:17:42,240 --> 04:17:50,240
얘를 풀어서 쓰면 이걸 먼저 쓰고 이거를 쓰고 그
다음에 result .append x 곱하기 y 이렇게 됩니다

3980
04:17:51,800 --> 04:17:53,980
이거를 풀어 쓰면 이렇게 됩니다

3981
04:17:54,180 --> 04:17:56,500
그래서 이거를 출력해보면 똑같이 나오죠

3982
04:17:56,720 --> 04:17:58,717
이 표현이 이 표현이랑 같은 겁니다

3983
04:17:58,741 --> 04:18:00,960
그래서 이런 패션 코딩도 있다

3984
04:18:01,400 --> 04:18:04,280
조코딩님 진짜 개발자들은 저렇게 하나하나 짜나요

3985
04:18:04,600 --> 04:18:09,280
하나하나 짜는 경우도 있고 보통 그냥 잘
되어 있는 코드 있으면 가져오는 경우가 많죠

3986
04:18:09,360 --> 04:18:12,600
그래서 이렇게 패션 코딩까지
해서 for문까지 다 배워봤습니다

3987
04:18:12,780 --> 04:18:17,030
실제로 for문을 써도 되고 while문을
써도 되고 왔다 갔다 하면서 쓸 수가

3988
04:18:17,054 --> 04:18:21,860
있으니까 if while for문을 다 잘
알아두시고 원하는 데 맞게 잘 쓰시면 좋겠죠

3989
04:18:22,020 --> 04:18:26,597
그래서 이렇게 해서 3장 프로그램의
구조를 쌓는다 제어문을 다 배워봤습니다

3990
04:18:26,621 --> 04:18:32,200
점프 투 파이썬 4장 프로그래밍의 입력과
출력은 어떻게 해야 할까에 대해서 배워보겠습니다

3991
04:18:32,420 --> 04:18:34,440
오늘은 함수에 대해서 배워보겠습니다

3992
04:18:34,700 --> 04:18:36,380
되게 중요한 파트 중에 하나예요

3993
04:18:36,440 --> 04:18:39,120
프로그래밍에 있어서 굉장히 빠질 수 없는 파트입니다

3994
04:18:39,300 --> 04:18:41,700
그래서 함수에 대해서 오늘 배워보도록 하겠습니다

3995
04:18:42,080 --> 04:18:47,220
함수를 설명할 때 다양한 비유가 있겠지만
이렇게 설명을 해볼 수가 있겠습니다

3996
04:18:47,560 --> 04:18:51,360
과일 주스를 만든다고 했을 때
과일 설탕 같은 재료들이 있겠죠

3997
04:18:51,500 --> 04:18:59,200
재료들을 기반으로 믹서기에 갈아서 그
재료들을 섞으면 결과로 과일 주스가 나오게 됩니다

3998
04:18:59,420 --> 04:19:06,550
그래서 이거를 이제 비유적으로 이거는
표현한 건데 프로그래밍에서는 입력이 들어가면

3999
04:19:06,574 --> 04:19:12,560
함수에서 어떠한 처리를 해주고 그리고
결과를 내뱉는 것 이게 함수의 개념입니다

4000
04:19:12,840 --> 04:19:20,840
그래서 좀 수학에서의 함수가 더 익숙하신 분도 있을
것 같아서 이렇게 그 수학에서의 함수 개념을 좀 보면

4001
04:19:21,726 --> 04:19:29,660
인풋 값이 x 값이 들어가서 어떤 펑션을 수행하고
그다음에 아웃풋이 나오는 거 이게 함수의 개념이죠

4002
04:19:29,760 --> 04:19:37,760
예를 들어서 이런 거 함수 학교에서 만약 배우셨다면
fx는 2x 플러스 3이라는 함수가 있다면 이런 개념이죠

4003
04:19:38,740 --> 04:19:42,360
여기에 만약에 입력 값 x 값에 뭔가를 넣어요

4004
04:19:42,400 --> 04:19:49,780
1이라는 값을 넣으면 여기 x에 1이 들어가면
2 곱하기 1이 되고 더하기 3이 되면 5가 되겠죠

4005
04:19:49,940 --> 04:19:52,380
그래서 그 5를 출력한다

4006
04:19:52,540 --> 04:19:55,320
이게 이제 수학에서의 함수의 개념입니다

4007
04:19:56,040 --> 04:20:02,259
약간 기억 안 나시는 분들은 좀 어려울
수 있는데 이렇게 어떤 입력이 특정 자리에

4008
04:20:02,283 --> 04:20:08,480
이렇게 들어가서 처리를 하고 결과를
내뱉는 거 이런 개념이었던 거 기억나시나요?

4009
04:20:08,560 --> 04:20:13,660
아무튼 이게 함수의 개념인데
프로그래밍에서도 이거랑 큰 개념은 같습니다

4010
04:20:13,820 --> 04:20:20,200
큰 개념은 같지만 약간 차이점이 있다면
입력이나 출력이 없을 수가 있습니다

4011
04:20:20,600 --> 04:20:26,782
그래서 이게 무슨 말인가는 지금은 잘
이해 안 되실 텐데 이번 시간을 쭉 진행하면서

4012
04:20:26,806 --> 04:20:32,320
입력과 출력이 없는 경우 그리고 이런
일반적인 경우랑 같이 한번 살펴보도록 하겠습니다

4013
04:20:32,500 --> 04:20:36,140
이번에도 위키독스를 함께 보면서 함수 단원을 나가보겠습니다

4014
04:20:36,380 --> 04:20:38,880
파이썬에서 함수를 이해하는 거는 매우 중요합니다

4015
04:20:39,020 --> 04:20:41,680
함수는 진짜 프로그램에서 빠질 수 없는 개념이죠

4016
04:20:41,820 --> 04:20:44,280
그러면 함수를 사용하는 이유는 무엇일까요?

4017
04:20:44,460 --> 04:20:47,920
이 프로그래밍을 하다 보면 항상
반복적으로 하는 작업들이 있습니다

4018
04:20:48,100 --> 04:20:53,317
그래서 똑같은 내용을 만약 함수가 없다면
계속 같은 코드를 쓸 텐데 그게 좀 귀찮으니까

4019
04:20:53,341 --> 04:21:01,341
이걸 한 덩어리로 묶어서 함수를 만들어 놓으면 그 함수를 쓸 때 딱 x
값만 넣어주면 결과가 딱 나오니까 그 함수를 묶어서 이렇게 만들게 됩니다

4020
04:21:02,880 --> 04:21:10,880
반복적으로 사용되는 가치 있는 부분을 묶어서 입력 값을 줬을 때 결과 값을
리턴해 준다라는 식으로 함수를 작성하는데 그래서 함수를 작성하는 또 다른

4021
04:21:12,601 --> 04:21:18,000
이유는 자신이 작성한 프로그램을 기능
단위로 분리를 하기 위해서 작성하기도 합니다

4022
04:21:18,160 --> 04:21:19,260
보기가 좋겠죠

4023
04:21:19,380 --> 04:21:21,837
이런 좀 이쁘게 만들기 위해서도 사용하게 됩니다

4024
04:21:21,861 --> 04:21:24,160
그러면 이제 알아보도록 하겠습니다

4025
04:21:24,460 --> 04:21:28,540
파이썬에서 함수의 구조가 어떻게
되는지 기본 구조를 보도록 하겠습니다

4026
04:21:28,740 --> 04:21:34,620
함수의 구조는 먼저 def라는 예약어라고
하는데 지정된 단어가 정해져 있습니다

4027
04:21:34,880 --> 04:21:40,160
그 def를 쓰고 그 다음에 함수 이름을
쓰고 맥의 변수를 바로 안에 넣어줍니다

4028
04:21:40,280 --> 04:21:46,840
그 다음에 콜론을 써준 다음에 여기에 수행할
문장들을 묶어주면 이게 바로 기본 함수의 구조입니다

4029
04:21:47,140 --> 04:21:50,877
마치 if for while 이런 것처럼
여기 비슷한 구조가 돼 있죠

4030
04:21:50,901 --> 04:21:57,820
대신에 뭐 for while 이런 거 대신에 def 이게 definition의
영어 단어의 약자인데 함수를 이렇게 정의하는 거죠

4031
04:21:57,940 --> 04:22:05,200
그래서 여기에 함수 이름을 적어주고 맥의 변수를
넣어주고 안에 함수 안에서 수행할 문장을 입력하게 됩니다

4032
04:22:05,580 --> 04:22:07,400
수학에서의 함수랑 비교해서 보겠습니다

4033
04:22:07,820 --> 04:22:12,600
그럼 파이썬 함수의 구조는
함수명은 그냥 이름이고 input x 있죠

4034
04:22:12,740 --> 04:22:14,520
이게 이제 맥의 변수입니다

4035
04:22:14,640 --> 04:22:19,417
그리고 여기 수행할 문장이 있는데
이게 이 function 안에랑 같은 내용입니다

4036
04:22:19,441 --> 04:22:25,300
그리고 이 return 값은 이제 뒤에 나올
텐데 return 값이 이제 output의 개념입니다

4037
04:22:25,440 --> 04:22:30,960
이렇게 세 개가 이런 구조로 되어 있다라고
이해하시면 좀 도움이 되실 것 같습니다

4038
04:22:31,400 --> 04:22:31,460
네

4039
04:22:31,540 --> 04:22:33,620
함수의 기본 구조를 보도록 하겠습니다

4040
04:22:33,920 --> 04:22:38,920
먼저 def라는 키워드를 써주고
add라는 함수 이름을 정해줬습니다

4041
04:22:39,380 --> 04:22:47,137
이거는 그냥 아무렇게나 정해셔도 되는데 보통 이제
함수의 기능을 가장 짧고 잘 설명하는 그 이름을 지어주게 되죠

4042
04:22:47,161 --> 04:22:53,100
그래서 얘는 더하기를 수행한 함수니까 add
정도 어떨까 하고 add로 지어준 함수입니다.

4043
04:22:53,400 --> 04:22:59,160
Ab라는 그 입력되는 값이 있고
return이 output으로 출력해주는 값입니다

4044
04:22:59,340 --> 04:23:04,590
그래서 a plus b를 돌려준다라고 되어
있는데 그러면 이거를 실행하면 바로 함수가

4045
04:23:04,614 --> 04:23:08,660
뭔가 사용되는 건가라고 생각할 수 있는데
놀랍게도 아무 일도 일어나지 않습니다

4046
04:23:08,800 --> 04:23:10,660
그냥 함수만 정의한 겁니다

4047
04:23:10,800 --> 04:23:11,140
말 그대로

4048
04:23:11,260 --> 04:23:16,960
함수가 이렇게 생긴 거를 구조를 만들 거야라는
거지 이거를 실행하는 건 따로 써줘야 됩니다

4049
04:23:17,160 --> 04:23:20,920
즉 이렇게 정의를 해놓은 다음에
이 정의한 함수를 사용해야 됩니다

4050
04:23:21,040 --> 04:23:25,780
함수 이름을 쓰고 그 괄호 안에
ab에 해당하는 값을 넣어줍니다

4051
04:23:25,900 --> 04:23:32,060
여기서는 1,2를 넣어주면 그 add란 함수를
사용해서 그 함수를 실제로 실행하는 겁니다

4052
04:23:32,360 --> 04:23:34,760
그러면 여기에 결과를 이걸 프린트를 해볼게요

4053
04:23:34,940 --> 04:23:42,940
그러면 이 함수를 정의하는 부분이고 이제 함수 사용하는 부분이 여기 있으니까
사용한 다음에 프린트를 하면 이제는 1 더하기 2가 각각 이런 구조입니다

4054
04:23:44,820 --> 04:23:47,136
Add 1 더하기 2니까 1이 a로 되어 있습니다

4055
04:23:47,160 --> 04:23:49,560
2가 b로 들어가고 2가 지금 b로 들어갔어요

4056
04:23:49,660 --> 04:23:51,680
그리고 함수 안에서 수행이 됩니다

4057
04:23:51,940 --> 04:23:56,100
1 더하기 2가 return이 돼서 여기 3이 빠져나옵니다

4058
04:23:56,160 --> 04:23:58,780
즉 프린트 3이 돼서 3이 출력이 된 겁니다

4059
04:23:59,080 --> 04:23:59,960
이거 이해되시나요?

4060
04:24:00,060 --> 04:24:02,020
이런 구조로 함수가 흘러갑니다

4061
04:24:02,140 --> 04:24:05,720
그러면 정의하는 부분이 있고
사용하는 부분이 따로따로 있습니다

4062
04:24:06,220 --> 04:24:08,120
이렇게 기본 구조를 살펴봤습니다

4063
04:24:08,280 --> 04:24:13,020
그래서 위의 함수는 이름은
add이고 입력 값 2개 ab를 받는 거죠

4064
04:24:13,140 --> 04:24:20,420
그리고 출력 값 return 값은 2개의 값을 더해서 이
더한 값을 출력으로 내뱉는다고 이해하시면 됩니다

4065
04:24:20,620 --> 04:24:22,900
그래서 이렇게 사용을 해봤고요

4066
04:24:23,000 --> 04:24:31,000
그 다음에 그 용어들을 이제 계속 매개변수니 인수니 이런 말들을
쓸 텐데 사실 비슷한 개념인데 좀 혼용돼서 사용이 되고 있습니다

4067
04:24:32,320 --> 04:24:39,600
그래서 일단 배우는 단계니까 조금 명확하게 잡고 가되 사실
어느 정도는 그냥 통하는 말이어서 좀 혼용돼서 사용되긴 합니다

4068
04:24:39,800 --> 04:24:47,800
그래서 매개변수와 인수에 대해서 좀 용어 정리를 해보자면 매개변수라는
용어를 쓸 때가 있는데 매개변수는 파라미터라고 영어로 부르기도 하고요

4069
04:24:48,940 --> 04:24:51,440
함수에서 정의되어 사용되는 변수입니다

4070
04:24:51,600 --> 04:24:59,600
즉 아까 add 함수 같은 경우에 이렇게 a, b 이렇게
들어간 값이 ab가 매개변수라는 이름으로 부릅니다

4071
04:24:59,800 --> 04:25:07,540
근데 다른 말로 인자라고 부르기도 하고 또 파라미터 영어로
파라미터니까 그냥 한글로도 파라미터라고 부르기도 합니다

4072
04:25:07,760 --> 04:25:09,120
인수라는 개념도 있습니다

4073
04:25:09,360 --> 04:25:17,360
인자랑 또 단어가 비슷해가지고 약간 헷갈리는데 arguments라는
이름으로 불리는데 함수를 호출할 때 건네주는 변수를 의미합니다

4074
04:25:18,620 --> 04:25:23,220
우리가 add를 사용할 때 여기에
3, 4 이런 값을 넘겨줬잖아요

4075
04:25:23,300 --> 04:25:25,660
이런 값들을 인수라고 부릅니다

4076
04:25:25,760 --> 04:25:26,840
상당히 헷갈립니다

4077
04:25:27,020 --> 04:25:33,004
왜냐하면 그 함수에 있는 이 값도 뭐
매개변수니 인자니 그리고 여기 안에 실제로

4078
04:25:33,028 --> 04:25:38,780
들어가는 이 건네주는 변수는 또 그
인수라고 부르니까 아 이게 참 좀 어렵죠

4079
04:25:38,840 --> 04:25:44,497
그냥 전반적으로 매개변수,
인수, 인자, 파라미터, arguments

4080
04:25:44,521 --> 04:25:48,120
이런 것들을 다 아 비슷한 개념이구나

4081
04:25:48,200 --> 04:25:55,880
이런 함수에서 어떤 값을 넘겨줄 때 사용되는 이런
개념이구나 정도로 이해하시면 크게 막 헷갈리진 않습니다

4082
04:25:56,080 --> 04:26:04,080
이렇게 용어를 구분하자면 이렇게 쓸 수 있는데 그냥 결국에 어떤 함수에
들어가는 값이다라고 생각하면 네 좀 편하게 생각할 수 있을 것 같습니다

4083
04:26:04,800 --> 04:26:12,500
정말 면밀하게 구분할 필요는 딱히 없고 그냥 이런 안에
들어가는 요런 개념이다 정도로만 이해하시면 사실 큰 상관은 없습니다

4084
04:26:12,780 --> 04:26:14,477
네 그래서 여러 가지 용어가 있습니다

4085
04:26:14,501 --> 04:26:16,780
용어가 겹치는 경우가 프로그래밍에서는 되게 많습니다

4086
04:26:16,900 --> 04:26:22,300
혼용해서 저도 막 매개변수로 했다가 인수로
했다가 그럴 텐데 사실 그냥 비슷한 개념입니다

4087
04:26:22,660 --> 04:26:29,557
그 함수 사용할 때도 뭐 결과 값, 출력
값, 반환 값, 돌려주는 값 이게 다 이 리턴

4088
04:26:29,581 --> 04:26:37,581
여기 안에 이 함수 들어갔다 나오는 값을 리턴 값이라고 하는데
이거랑 뭐 결과 값, 출력 값, 반환 값, 뭐 돌려주는 값 다 같은 말입니다

4089
04:26:38,220 --> 04:26:44,237
좀 겹치는 용어들이 있어서 처음에는 약간 헷갈릴 수
있는데 듣다 보면은 사실 요걸 아 많이 혼용하는구나

4090
04:26:44,261 --> 04:26:45,580
라고 생각하시면 됩니다

4091
04:26:45,800 --> 04:26:53,800
일단은 함수라고 하면은 뭐 기본적인 구조는 아까 설명드렸다시피
어떤 입력이 있고 뭔가 막 처리하는 함수 부분이 있고 리턴 값이 있습니다

4092
04:26:55,240 --> 04:27:02,480
여기서는 아까 처음에 설명드렸다시피 입력 값이 없을 수도
있고 리턴 값이 없을 수도 있고 종류가 좀 나뉠 수가 있습니다

4093
04:27:02,680 --> 04:27:05,000
그래서 그거를 하나씩 살펴보도록 하겠습니다

4094
04:27:05,260 --> 04:27:07,120
먼저 일반적인 함수를 보겠습니다

4095
04:27:07,340 --> 04:27:11,500
아까 add 같은 경우에 일반적인
함수는 이렇게 입력 값도 있어요

4096
04:27:11,640 --> 04:27:13,057
입력 a, b를 받죠

4097
04:27:13,081 --> 04:27:16,200
그리고 안에 처리할 함수 부분 처리하는 것도 있습니다

4098
04:27:16,380 --> 04:27:18,820
그리고 리턴해 주는 아웃풋 부분도 있어요

4099
04:27:18,960 --> 04:27:23,780
그러면 여기에 1, 2를 입력 받으면 여기
1 더하기 2가 result에 담겨서 3이 되겠죠

4100
04:27:23,920 --> 04:27:27,580
그래서 3을 결과적으로 내뱉는
그 결과 값을 돌려주게 됩니다

4101
04:27:27,800 --> 04:27:32,720
그래서 요런 구조로 함수가 돼 있는 게
그냥 일반적인 다 모든 요소가 있는 함수입니다

4102
04:27:32,940 --> 04:27:39,460
요렇게 생긴 함수는 아까 실행해 봤기 때문에 일단
넘어가면 더하면은 add 3, 4 하면은 더하기가 잘 출력이 되겠죠

4103
04:27:39,600 --> 04:27:41,757
그런데 입력 값이 없을 수도 있습니다

4104
04:27:41,781 --> 04:27:43,740
입력 값이 없으면 어떻게 되냐

4105
04:27:43,800 --> 04:27:44,940
요렇게 생겼습니다

4106
04:27:45,080 --> 04:27:49,380
이 함수를 보면은 괄호 안에 여기에
그 파라미터가 정해진 게 없어요

4107
04:27:49,580 --> 04:27:52,160
그렇다는 거는 여기에 뭔가 입력을 못하는 겁니다

4108
04:27:52,360 --> 04:27:56,780
그래서 say란 함수는 그냥 괄호 안에
아무것도 안 받는데 리턴 값만 있습니다

4109
04:27:57,140 --> 04:28:04,580
즉, 함수 그림을 보자면 요렇게 입력이 있고 출력이 되는데
여해가 없고 그냥 함수를 실행하면 출력만 나오는 거예요

4110
04:28:04,900 --> 04:28:12,900
그래서 이걸 실제로 실행해 보면 say라고 하고 여기서 나오는
결과를 뭐 a라는 변수에 저장한 다음에 print a를 해 보겠습니다

4111
04:28:13,320 --> 04:28:16,400
그러면 네, high라는 그 결과가 잘 출력이 돼요

4112
04:28:16,500 --> 04:28:24,500
왜 그러냐면 이제 이 함수를 통해서 high라는 값이 리턴이 됐으니까 이 리턴
값이 a에 담기고 이 아웃풋이 나왔으니까 그리고 그 a가 출력이 된 겁니다

4113
04:28:25,480 --> 04:28:26,840
그래서 이렇게 high가 잘 나왔죠

4114
04:28:26,920 --> 04:28:28,260
근데 여기에 입력 값이 없어요

4115
04:28:28,480 --> 04:28:30,180
프로그래밍에서 함수는 그럴 수 있습니다

4116
04:28:30,420 --> 04:28:32,600
여기에 근데 뭔가를 넣으면은 오류가 납니다

4117
04:28:32,680 --> 04:28:32,880
오히려

4118
04:28:32,940 --> 04:28:39,460
이 arguments가 0개가 필요한데 즉, 아무것도 없어야
되는데 어, 이거 왜 넣었어 하고 오류를 오히려 내뱉습니다

4119
04:28:39,640 --> 04:28:41,480
이렇게 입력 값이 없는 경우도 있고

4120
04:28:41,780 --> 04:28:43,780
그리고 리턴 값이 없는 경우가 있어요

4121
04:28:43,880 --> 04:28:45,720
리턴 값이 출력되는 값이죠

4122
04:28:45,820 --> 04:28:47,780
출력 값이 없는 경우도 존재합니다

4123
04:28:48,200 --> 04:28:50,500
예제를 보면 여기는 입력값이 있습니다

4124
04:28:50,800 --> 04:28:52,580
A, b를 입력을 받죠

4125
04:28:53,300 --> 04:28:55,200
출력값이 리턴이라는 게 없죠

4126
04:28:55,280 --> 04:28:56,700
그러면 출력값이 없습니다

4127
04:28:57,140 --> 04:29:01,780
그래서 이거를 실제로 실행해 보면 네, 입력
값은 있으니까 이렇게 입력을 해줄 수 있겠죠

4128
04:29:01,940 --> 04:29:03,600
그리고 print를 해 보겠습니다.

4129
04:29:03,840 --> 04:29:06,680
A라는 변수에 담아서 print a를 해주겠습니다

4130
04:29:06,860 --> 04:29:08,780
네, 그럼 이렇게 출력을 해 보면 어떻게 되냐

4131
04:29:08,820 --> 04:29:10,637
반전으로 출력이 나와버립니다

4132
04:29:10,661 --> 04:29:14,340
1, 2의 합은 3입니다라는 게 프린트로 출력이 되어버렸죠

4133
04:29:14,380 --> 04:29:16,200
그래서 여기서 약간 헷갈릴 수 있어요

4134
04:29:16,380 --> 04:29:19,220
여기 잘 생각해보시면 아웃풋이 없는 함수가 맞습니다

4135
04:29:19,380 --> 04:29:20,520
여기 리턴이 없죠

4136
04:29:20,580 --> 04:29:26,820
그렇기 때문에 뒤에 있는 none이 왜 나왔을까를
생각해보면 이 add란 함수를 통해서 어떠한 처리를 막 해요

4137
04:29:26,960 --> 04:29:31,860
입력이 있는데 이 함수에서 어떤
처리를 하는데 출력이 없는 거죠

4138
04:29:32,020 --> 04:29:38,077
즉 이 add를 다 수행하고 나서 출력값이
없기 때문에 여기에 none이 담깁니다

4139
04:29:38,101 --> 04:29:44,134
그래서 이 add에 출력 돌려주는 값이
없기 때문에 none이라는 값이 a에 담겨서

4140
04:29:44,158 --> 04:29:49,781
여기는 none이 출력되고 이 프린트 함수는
그냥 프린트라는 함수가 안에 쓰인 거예요

4141
04:29:49,940 --> 04:29:55,651
그렇다는 거는 여기 프린트 함수에서
나오는 출력 1, 2의 합은 3입니다라는 거는

4142
04:29:55,675 --> 04:30:01,140
그냥 프린트로 출력을 여기에 찍은 것뿐이고
이렇게 리턴해주는 돌려주는 값은 아닙니다

4143
04:30:01,300 --> 04:30:07,457
그래서 이렇게 이해해보시면 그 함수에 출력이
없다라는 게 무슨 뜻인지 이해하실 수 있을 것 같습니다

4144
04:30:07,481 --> 04:30:11,820
그러니까 출력이 리턴이랑 좀 혼용돼서
헷갈릴 수 있는데 리턴이 지금 없는 거죠

4145
04:30:11,920 --> 04:30:14,800
여기 만약 리턴을 만든다 그러면 이런 형태가 되겠죠

4146
04:30:14,920 --> 04:30:22,100
리턴 값이 있기 때문에 리턴 값이 a에 담기고 여기
a에 출력이 돼서 a가 3이 출력이 돼서 여긴 3이 나오죠

4147
04:30:22,200 --> 04:30:25,700
아까는 none이 나온 걸 보면
그 차이를 좀 알 수가 있겠습니다

4148
04:30:26,120 --> 04:30:26,580
네 좋습니다

4149
04:30:26,660 --> 04:30:29,220
그래서 리턴 값이 없는 경우도 살펴봤습니다

4150
04:30:29,340 --> 04:30:30,640
심지어 이런 경우도 있습니다

4151
04:30:30,880 --> 04:30:33,760
입력 값도 리턴 값도 없는 함수가 있습니다

4152
04:30:34,080 --> 04:30:35,357
네 요거를 보도록 하겠습니다

4153
04:30:35,381 --> 04:30:40,700
지금 괄호 안에 a, b 같은 그
인자 파라미터를 받는 그 값이 없죠

4154
04:30:40,740 --> 04:30:41,740
리턴도 없어요

4155
04:30:41,780 --> 04:30:43,360
그냥 print high만 있습니다

4156
04:30:43,620 --> 04:30:51,380
그래서 실제로 이거 함수를 수행해보면 a라는 변수에
say라는 함수를 실행해서 담고 그리고 print a를 해보겠습니다

4157
04:30:51,700 --> 04:30:58,036
그러면 high가 잘 출력이 되는데 얘는
어떠한 입력을 받아서 뭔가 수행한다기보다는

4158
04:30:58,060 --> 04:31:03,300
그냥 실행하면 입력 값이 없어도 함수가
실행됐을 때 기본적으로 실행되는 코드인 거죠

4159
04:31:03,460 --> 04:31:04,880
입력 값이 없지만...

4160
04:31:05,380 --> 04:31:12,260
이렇게 high라는 함수 기능적인 수행을 했고 그 다음에
say에서 리턴되는 값이 없기 때문에 a에 아무것도 안 담깁니다

4161
04:31:12,360 --> 04:31:15,960
그리고 나서 a를 출력했기 때문에
이렇게 none이 나오게 됩니다

4162
04:31:16,300 --> 04:31:19,580
그래서 함수의 구조를 좀 이해해보시면
많은 것들을 이해할 수가 있어요

4163
04:31:19,740 --> 04:31:24,760
그래서 이렇게 입력도 없고 출력도 없지만
이런 식으로 활용하는 함수 들도 있습니다

4164
04:31:24,980 --> 04:31:29,120
그래서 수학에서의 함수랑은 이런 차이가
있다 정도로 이해하시면 좋을 것 같습니다

4165
04:31:29,300 --> 04:31:32,617
그러면 이제 좀 다양한 함수를 좀
활용하는 사례를 보도록 하겠습니다

4166
04:31:32,641 --> 04:31:36,500
매개별수를 지정하여 호출하는 이런 기능도 있습니다

4167
04:31:36,740 --> 04:31:37,880
그래서 그게 어떤 거냐?

4168
04:31:37,940 --> 04:31:39,220
이 함수를 보겠습니다

4169
04:31:39,580 --> 04:31:42,760
구조를 보면 ab는 입력을 받아서 입력이 있죠?

4170
04:31:42,880 --> 04:31:44,960
그리고 리턴도 있습니다 출력도 있습니다

4171
04:31:45,120 --> 04:31:47,680
A-b를 수행하는 함수입니다

4172
04:31:47,840 --> 04:31:49,520
기본적으로 그냥 먼저 실행해 볼게요

4173
04:31:50,080 --> 04:31:54,760
A는issance부에 3,1 이렇게
하고 printit2를 하면 2가 나옵니다

4174
04:31:54,840 --> 04:32:02,556
왜냐하면 여기에 3x1이 들어가면 이게 함수 안에서
31로 써져서 2라는 값이 리턴이 되어서 2로 들어가죠

4175
04:32:02,580 --> 04:32:02,616
여기에 3x2가 있으면 이게 함수 안에서 31로
써져서 2라는 값이 리턴이 돼서 이걸로 채 hilft you

4176
04:32:02,640 --> 04:32:04,360
그래서 2가 출력이 되는 겁니다

4177
04:32:04,500 --> 04:32:06,720
이거 이름은 Subtract에서 따왔겠죠

4178
04:32:06,880 --> 04:32:08,320
근데 이름은 아무렇게나 지어도 됩니다

4179
04:32:08,540 --> 04:32:12,560
최대한 함수를 잘 설명하게끔
지어주면 가장 네이밍이 좋습니다

4180
04:32:12,860 --> 04:32:14,220
이렇게 쓸 수도 있겠습니다

4181
04:32:14,680 --> 04:32:17,660
그 Sub라는 함수에 그냥 값만 넣어줄 수도 있거든요

4182
04:32:17,920 --> 04:32:22,240
그래서 이렇게 넣어줄 수도
있는데 그러면 7-3이 수행이 되겠죠

4183
04:32:22,380 --> 04:32:24,220
근데 굳이 지정을 해줄 수도 있습니다

4184
04:32:24,540 --> 04:32:32,540
여기 a라는 곳에 7을 넣고 b라는 곳에 3을 넣어야지 하고 이렇게 지정을
해주면 이 7이 이렇게 a로 직접 들어가고 이렇게 3이 여기로 들어갑니다

4185
04:32:34,720 --> 04:32:41,320
즉, 순서로 맞출 수도 있는데 이렇게 지정해서
그 특정 파라미터의 값을 넘길 수도 있어요

4186
04:32:41,460 --> 04:32:44,340
그래서 이거를 어떻게 활용하냐 이런 식으로도 활용이 됩니다

4187
04:32:44,560 --> 04:32:51,200
B는 3, a는 7 이렇게 수행하게 되면 그러면
사실 원래 3, 7을 적었으면 3-7이 되잖아요

4188
04:32:51,360 --> 04:32:58,140
근데 이거를 각각 어디에 넣을 건지 이렇게 지정을
해줘서 전달하게 되면 순서가 바뀌어도 상관이 없습니다

4189
04:32:58,400 --> 04:33:04,060
A자리에 7이 들어가고 b자리에 3이
들어가면서 a-b가 4가 잘 나오게 됩니다

4190
04:33:04,340 --> 04:33:08,900
그래서 이렇게 직접 어떤 변수에
전달하는 것까지도 수행할 수가 있겠습니다

4191
04:33:09,100 --> 04:33:11,500
그래서 매개변수 지정하에 호출하기를 알아봤고요

4192
04:33:11,640 --> 04:33:15,000
그 다음에 입력 값이 몇 개가 될지 모를 때도 있습니다

4193
04:33:15,620 --> 04:33:18,480
이거는 어떻게 하냐 예시를 통해서 보도록 하겠습니다

4194
04:33:19,280 --> 04:33:26,180
AddMany라는 함수가 있으면 이거는 여러 개의
argument를 받아서 이거를 다 더해주는 함수예요

4195
04:33:26,300 --> 04:33:29,960
그래서 이 용어로 보통 args라고 많이 써줍니다

4196
04:33:30,040 --> 04:33:33,360
이것 또한 아무거나 써도 되는데 약간 관습적인 거죠

4197
04:33:33,500 --> 04:33:35,400
그래서 arguments의 약자입니다

4198
04:33:35,540 --> 04:33:43,540
즉 여기에 addMany를 하면은 예를 들어서 12345 이렇게 여러 개의
값들을 더해주고 싶은데 이걸 다 만약 각각 지정해주려면 별을 쓰고 원래

4199
04:33:46,401 --> 04:33:49,980
arguments를 쓰면은 이 다양한
값들을 다 한 번에 받아줄 수가 있습니다

4200
04:33:50,240 --> 04:33:58,240
원래 이게 없다면 사실 a, b, c, d, e 이렇게 해야 되는데
이게 5개가 들어올지 아니면 10개가 들어올지 모르잖아요

4201
04:33:59,360 --> 04:34:06,445
그런 경우에 별표하고 그걸 한 번에 받아줄 수
있는 변수를 만들어줘서 별표로 받아주게 되면 여기

4202
04:34:06,469 --> 04:34:12,520
괄호 안에 몇 개의 값이 들어가더라도 다
받아서 이거를 args라는 곳에 저장을 하게 됩니다

4203
04:34:13,040 --> 04:34:20,760
그러면 함수 안쪽에서 이 args에서 하나씩 뽑아서 뽑은 같은
거 이용하면 하나씩 값을 뽑아서 뭔가를 활용할 수가 있겠죠

4204
04:34:20,960 --> 04:34:27,140
그래서 이렇게 활용이 되는 방식이 별표시를 하게
되면 여러 개의 매개변수를 한 번에 받을 수가 있습니다

4205
04:34:27,320 --> 04:34:29,240
그래서 실제로 한 번 수행을 해볼까요?

4206
04:34:29,360 --> 04:34:31,760
지금 return 값을 받았는데 출력을 안 해줬죠.

4207
04:34:31,820 --> 04:34:34,720
Print를 해서 출력을 해보면 이렇게 15가 나옵니다

4208
04:34:34,920 --> 04:34:36,960
12345를 다 더하면 15가 되죠

4209
04:34:37,020 --> 04:34:42,211
여러 개의 파라미터, 매개변수, 인수 다
비슷한 개념인데 그걸 한 번에 받으려면

4210
04:34:42,235 --> 04:34:46,580
12345 이런 값들을 받으려면 별표하고
써주면 된다라고 설명 드릴 수가 있겠습니다

4211
04:34:46,820 --> 04:34:47,900
섞어서 쓸 수도 있어요

4212
04:34:48,020 --> 04:34:52,460
Args를 여러 개 받는 것과 하나를
받는 것과 섞어서 쓸 수도 있습니다

4213
04:34:52,620 --> 04:35:00,620
이번에는 함수가 choice라는 값을 먼저 받고 그
다음에 arguments를 별로 받으니까 이런 개념이죠

4214
04:35:01,260 --> 04:35:07,300
여기는 하나의 값을 받고 여기는 몇 개가
되든지 12345 아무거나 받겠다라는 뜻이겠죠

4215
04:35:07,460 --> 04:35:08,900
그러면 이걸 어떻게 활용할 수 있냐

4216
04:35:08,960 --> 04:35:15,120
Choice는 현재 add나 mer인 경우에 둘 중에
하나를 받아서 그것에 맞게 수행을 하게 됩니다

4217
04:35:15,380 --> 04:35:21,807
예를 들어 addmer 이런 함수는 여기에
첫 번째 파라미터로 add를 주고 123을

4218
04:35:21,831 --> 04:35:27,600
주게 되면 이렇게 쓰게 되면 지금 덧셈을 할
거야라고 먼저 첫 번째 파라미터로 알려줍니다

4219
04:35:27,680 --> 04:35:28,356
왜냐?

4220
04:35:28,380 --> 04:35:30,320
얘가 이제 choice로 들어가죠

4221
04:35:30,360 --> 04:35:31,000
하나니까

4222
04:35:31,140 --> 04:35:36,340
나머지 뒤에 arguments들은 몇 개든
상관없이 그걸 다 받아서 여기로 넣어주게 됩니다

4223
04:35:36,860 --> 04:35:40,100
123만 썼지만 이게 10개든 100개든 다 받아줍니다

4224
04:35:40,320 --> 04:35:44,800
여기 for문을 이용해서 여기 있는
것들을 하나씩 뽑아서 이거를 더해주게 되죠

4225
04:35:44,860 --> 04:35:47,440
실제로 실행을 해보면 이렇게 6이라는 값이 나옵니다

4226
04:35:47,480 --> 04:35:47,760
왜냐?

4227
04:35:47,840 --> 04:35:48,817
123을 더한 거니까

4228
04:35:48,841 --> 04:35:56,380
근데 여기서 이 choice 변수만 mul, mer로 바꿔주면
이게 여기서 일치돼서 if문 이쪽으로 들어가게 되죠

4229
04:35:56,420 --> 04:36:03,620
지난 시간 약간 복습을 해보자면 if를 거쳐서
add가 아니니까 elif로 들어가서 여기로 수행이 되겠죠

4230
04:36:03,740 --> 04:36:08,220
그래서 이걸 실행해보면 이번에도 6이
나오는데 이거는 곱하기 해서 6이 나온 거죠

4231
04:36:08,320 --> 04:36:09,360
3개 곱하면 6이니까

4232
04:36:09,460 --> 04:36:15,860
차이를 둔다면 파라미터를 하나 늘려도 이렇게 곱하기가
수행되고 여기에 다시 add를 바꾸면 더하기가 수행됩니다

4233
04:36:16,040 --> 04:36:17,340
이게 123은 갔죠

4234
04:36:17,400 --> 04:36:18,260
곱하기나 더하기나

4235
04:36:18,300 --> 04:36:26,300
아무튼 이렇게 이런 식으로 하나는 그냥 하나로 받고 나머지
뒤에는 몇 개가 오든지 한 번에 받겠다 라는 걸 섞어 쓸 수도 있습니다

4236
04:36:26,640 --> 04:36:28,140
그 다음에 이런 것도 있어요

4237
04:36:28,320 --> 04:36:30,220
Key value를 받는 구조도 있습니다

4238
04:36:30,440 --> 04:36:33,800
우리가 자료형을 배울 때
dictionary 자료형을 배웠잖아요

4239
04:36:34,020 --> 04:36:39,902
어떻게 보면 앞서서 여러 개의 argument들을
받는 거는 list를 받는 개념이라면 keyword

4240
04:36:39,926 --> 04:36:45,120
매개변수 즉 그 dictionary 형태로
뭔가 key와 value로 받는 것도 있습니다

4241
04:36:45,560 --> 04:36:48,540
이런 함수를 보게 되면 여기는 별표가 두 개가 있습니다

4242
04:36:48,920 --> 04:36:50,740
별표 두 개는 무슨 뜻이냐?

4243
04:36:50,820 --> 04:36:54,220
Key value 형태로 이렇게 입력을 받겠다는 겁니다.

4244
04:36:54,420 --> 04:36:58,080
Print keyword argument 이거를
출력해 보니까 이렇게 나와요

4245
04:36:58,120 --> 04:37:04,071
즉 여기서 입력을 받을 때 a는 1, b는 2
이렇게 여러 개의 값이 몇 개든 상관없이

4246
04:37:04,095 --> 04:37:09,240
들어가면 이 keyword argument로
잡아서 key argument의 약자입니다.

4247
04:37:09,420 --> 04:37:10,580
Keyword argument의 약자

4248
04:37:10,640 --> 04:37:14,417
그래서 이것도 당연히 단어 아무거나
써도 되는데 보통 이렇게 씁니다

4249
04:37:14,441 --> 04:37:17,760
그래서 이걸 받아서
dictionary 형태로 출력을 합니다

4250
04:37:17,880 --> 04:37:20,820
별표 두 개로 받는 거는
dictionary 형태로 받게 됩니다

4251
04:37:21,060 --> 04:37:23,316
그래서 이걸 활용한다면 어떻게 되느냐?

4252
04:37:23,340 --> 04:37:26,420
이런 식으로 따로따로 값을 뽑을 수가 있어요

4253
04:37:26,580 --> 04:37:32,343
예를 들어 a만 출력하고 싶다 라고 하면
a라는 변수로 받은 값만 이렇게 따로 출력할 수도

4254
04:37:32,367 --> 04:37:37,420
있고 또 이거를 b만 따로 출력할 수도 있고
이렇게 하면 b만 따로 출력할 수도 있겠죠

4255
04:37:37,580 --> 04:37:45,580
이런 식으로 여러 개를 받아서 그걸 나눠서 활용할 때 key와
value를 이용해서 나눠서 활용할 때 별표 두 개를 사용할 수가 있겠습니다

4256
04:37:47,740 --> 04:37:52,740
그 다음에 함수의 리턴 값은 언제나
하나이다 를 나가보도록 하겠습니다

4257
04:37:53,020 --> 04:37:55,220
먼저 다음 함수를 만들어 보도록 하겠습니다

4258
04:37:55,460 --> 04:37:58,220
이번에는 addAndMurl이라는 함수를 만들었어요

4259
04:37:58,400 --> 04:38:06,400
그리고 ab라는 입력가를 봤는데 단원 이름이 아까 함수의 리턴 값은
하나이다인데 여기서 예제로는 두 개를 이렇게 콤마로 리턴을 하고 있습니다

4260
04:38:08,540 --> 04:38:12,972
그래서 이게 리턴이 그럼 두 개가
아닌가라고 생각이 들 수 있고 실제로 이거를

4261
04:38:12,996 --> 04:38:18,480
수행해 보면 이렇게 7이 있고 12가 있는데
이게 보시면 아시겠지만 괄호로 묶여있죠

4262
04:38:18,870 --> 04:38:20,380
그렇다는 것은 tuple입니다

4263
04:38:20,520 --> 04:38:25,280
얘는 그래서 tuple 하나가 이렇게
묶여서 하나가 리턴이 되는 겁니다.

4264
04:38:25,460 --> 04:38:29,720
Tuple이 하나가 나오는 거지 두 개
값이 막 따로따로 나오는 게 아닙니다

4265
04:38:29,820 --> 04:38:37,820
그래서 뒤에 개념이 좀 더 나오는데 심지어 tuple로 나오니까
이전 시간에 아시겠지만 a, b 이런 식으로 tuple을 받아줄 수가 있었죠

4266
04:38:39,581 --> 04:38:45,892
이렇게 하게 되면 print a랑 print b를
하게 되면 tuple이 나오니까 이렇게 하나씩

4267
04:38:45,916 --> 04:38:51,220
받아줄 수가 있고 이거를 또 각각 출력해
보면 이 tuple을 나눠져서 이렇게 출력이 되겠죠

4268
04:38:51,420 --> 04:38:55,860
네, 그래서 이렇게 받아줄 수 있는데
그러면은 리턴 값이 두 개면 어떻게 해야 되냐

4269
04:38:55,920 --> 04:38:59,260
두 개라는 건 실제로 이렇게 리턴 값이 두 개가 있는 거

4270
04:38:59,320 --> 04:39:00,480
이렇게는 안 됩니다

4271
04:39:00,700 --> 04:39:03,400
그래서 파이썬에서 리턴 값은 하나이다

4272
04:39:03,520 --> 04:39:09,760
함수에서 리턴 값은 하나이다라고 말하는 게
그래서 이걸 리턴했으면 함수 자체가 종료되어 버립니다

4273
04:39:09,860 --> 04:39:12,860
그래서 이 뒤에 있는 것은 지금 약간 흐릿하게 나오죠?

4274
04:39:12,920 --> 04:39:17,520
왜 그러냐면 이 return을 만나면
함수 자체가 그냥 끝나 버립니다

4275
04:39:17,660 --> 04:39:19,360
뒤에 있는 return은 있을 수가 없습니다

4276
04:39:19,720 --> 04:39:23,860
그래서 써준다고 해도 실제로
수행을 해보면 이렇게 7이 나오죠?

4277
04:39:23,920 --> 04:39:24,920
왜 7이 나오냐?

4278
04:39:24,980 --> 04:39:32,420
여기 더하기가 먼저 있기 때문에 3 더하기 4인 7이
먼저 나오고 3 곱하기 4인 12는 나올 수가 없습니다

4279
04:39:32,660 --> 04:39:33,200
왜냐?

4280
04:39:33,260 --> 04:39:39,100
함수 자체가 종료가 되어버리기 때문에 return
값은 오직 하나라는 거 이해해 두시면 좋을 것 같습니다

4281
04:39:39,280 --> 04:39:41,060
그래서 이렇게 알아봤고요

4282
04:39:41,160 --> 04:39:49,160
이제 여기서 파생되는 개념 중에 return 문을 만나는 순간 결과 값을
돌려준 다음 함수를 빠져나가게 돼서 함수 자체가 종료가 되어버립니다

4283
04:39:51,300 --> 04:39:57,080
그렇기 때문에 이제 함수 빠져나가는 return을
이용해서 오히려 다른 용도로 활용할 수도 있습니다

4284
04:39:57,440 --> 04:39:59,680
조세용 님, return 하기 싫으면 안 해도 됩니다

4285
04:39:59,920 --> 04:40:03,060
그래서 아까 return 값이
없는 함수 위에서 살펴봤었죠?

4286
04:40:03,120 --> 04:40:04,417
그래서 return을 안 해도 됩니다

4287
04:40:04,441 --> 04:40:09,440
그냥 뭐 pass 이것만 적으면 아무것도
안 하고 그냥 none이라는 값이 나오죠

4288
04:40:09,480 --> 04:40:12,980
왜냐면 이 return 값이 없기
때문에 none으로 나오는 겁니다.

4289
04:40:13,160 --> 04:40:14,560
Return 하기 싫으면 안 해도 됩니다

4290
04:40:14,740 --> 04:40:20,840
아무튼 그럼 return이 이렇게 함수를 끝내는 거다라고
말씀드렸는데 그래서 또 다른 쓰임새로 쓰일 수가 있습니다

4291
04:40:21,060 --> 04:40:25,220
특별한 상황일 때 함수를 빠져나가고
싶을 때 그때도 return을 씁니다.

4292
04:40:25,340 --> 04:40:27,280
Say nick이라는 함수를 만들었어요

4293
04:40:27,420 --> 04:40:32,620
그래서 nick이라는 입력을 받아서 그거를 이제
나의 별명은 하고 nick을 이거 formatting이죠

4294
04:40:32,680 --> 04:40:33,620
이렇게 넣어주는 거

4295
04:40:33,660 --> 04:40:34,397
그래서 출력을 하고

4296
04:40:34,421 --> 04:40:39,083
이렇게 출력해주는 건데 이런 경우에
예를 들어서 say nick에 master님 이렇게

4297
04:40:39,107 --> 04:40:44,100
하는 거랑 joecoding님 이런 거는 다
되는데 여기서 바보라고 해보겠습니다

4298
04:40:44,300 --> 04:40:48,240
그러면은 실행을 해보면 이렇게
master님은 잘 출력이 됐죠?

4299
04:40:48,320 --> 04:40:49,460
이 함수를 잘 통과해서

4300
04:40:49,560 --> 04:40:56,720
그리고 joecoding님도 들어갔을 때 이렇게 잘 출력이
된 것을 볼 수 있는데 이 바보라고 하면 출력이 안 됩니다

4301
04:40:56,920 --> 04:40:57,540
왜 그러냐?

4302
04:40:57,600 --> 04:41:00,600
여기서 nick이 바보기 때문에 if문을 만났죠?

4303
04:41:00,720 --> 04:41:01,820
Return을 만났습니다

4304
04:41:01,960 --> 04:41:08,500
그러면 return을 만나자마자 이 반복문의 break를
만난 것처럼 이 함수 자체를 종료를 해버립니다.

4305
04:41:08,600 --> 04:41:13,620
Return을 만나면 함수가 종료되기 때문에
그래서 함수를 빠져나가는 용도로도 사용이 됩니다

4306
04:41:13,860 --> 04:41:15,040
이렇게 할 수가 있겠습니다

4307
04:41:15,140 --> 04:41:18,636
그래서 return으로 함수 빠져나가는
건 실제로 자주 활용되니까요

4308
04:41:18,660 --> 04:41:20,500
이거는 기억해 두시면 좋을 것 같습니다

4309
04:41:20,960 --> 04:41:24,700
그다음에 매개변수의 초기값 미리
설정하기라는 것도 해보도록 하겠습니다

4310
04:41:25,160 --> 04:41:27,480
그 saymyself라는 함수를 만들었습니다

4311
04:41:27,780 --> 04:41:30,600
그럼 매개변수가 지금 하나, 둘, 세 개가 있어요

4312
04:41:30,820 --> 04:41:34,317
이 두 개는 그냥 놨는데 세 번째는 man은 true.

4313
04:41:34,341 --> 04:41:35,660
True라고 설정을 해놨습니다

4314
04:41:35,760 --> 04:41:40,520
그렇다는 거는 이 man의 기본값을
true로 설정하겠다라는 뜻입니다

4315
04:41:40,720 --> 04:41:41,620
이게 무슨 말이냐?

4316
04:41:41,680 --> 04:41:49,680
이렇게 원래 함수를 실제로 이 기본값을 모르고 썼다면 이렇게 세 개의
매개변수가 있으니까 그거에 맞춰서 값도 세 개를 이렇게 넣어주는 게 맞겠죠

4317
04:41:51,040 --> 04:41:58,840
이렇게 각각 들어가면 이걸 실행했을 때 나의 이름은 라고
나오는 게 각각 이 구문들이 하나씩 수행이 돼서 이렇게 나오는 거죠

4318
04:41:59,000 --> 04:42:07,000
근데 여기서 기본값을 정해줬다라는 거는 이 뒤에 거는 true라는
게 일단 기본값으로 설정했기 때문에 이걸 굳이 안 써줘도 됩니다

4319
04:42:07,980 --> 04:42:13,000
왜냐하면 얘는 기본값이 true이기 때문에
이렇게 실행을 해도 결과가 똑같이 나옵니다

4320
04:42:13,060 --> 04:42:21,060
즉, man이 true라는 게 기본값으로 바뀌어 있어서 name이랑 old는
각각 이렇게 함수 자리로 들어가서 여기서 사용이 되는데 그 man은 기본값이

4321
04:42:21,681 --> 04:42:27,180
true이기 때문에 안 써주더라도 여기에
true가 돼서 남자입니다가 출력이 됩니다

4322
04:42:27,360 --> 04:42:29,180
그래서 이렇게 쓸 수가 있겠습니다

4323
04:42:29,400 --> 04:42:33,580
기본값이 아닌 다른 값을 넣어주려면
이걸 반대로 써줘야겠죠, 오히려

4324
04:42:34,340 --> 04:42:41,860
이걸 써줘야지만 이거를 기본값을 덮어씌워서 새로운 값으로
바꿔줄 수가 있으니까 기본값이 아닌 경우에는 당연히 넣어줘야겠죠

4325
04:42:41,980 --> 04:42:47,280
그래서 이렇게 false를 넣으면 이 기본값이더라도
바꿔치기가 돼서 이제 여자입니다가 나오게 됩니다

4326
04:42:47,400 --> 04:42:48,140
이렇게 살펴봤고요

4327
04:42:48,260 --> 04:42:51,660
네, 이거는 한번 이렇게 예제를 통해서
살펴본 내용이 그대로 나와 있습니다

4328
04:42:51,900 --> 04:42:54,280
이런 경우는 어떻게 될지 한번 보도록 하겠습니다

4329
04:42:54,500 --> 04:42:59,580
그러면 이렇게 기본값을 정해줄 수 있다고
했으니까 man은 true를 앞에 놓고 싶어요

4330
04:42:59,660 --> 04:43:04,482
왜냐하면 이 매개변수의 순서가 막 중요한
건 아니니까 그냥 man을 먼저 쓰고 싶어서

4331
04:43:04,506 --> 04:43:09,176
썼는데 기본값을 그럼 true로 지정했더니
갑자기 이 old에 빨간 밑줄이 그어집니다

4332
04:43:09,200 --> 04:43:16,560
그래서 오류가 있다는 건데 이걸 실제로 실행을 해보면
old라는 값이 안 줬어 라고 오류가 나는데 이게 왜 그러는 거냐

4333
04:43:16,600 --> 04:43:19,440
항상 매개변수는 순서에 맞춰서 들어갑니다

4334
04:43:19,500 --> 04:43:27,500
즉, 이렇게 직접 지정해서 예를 들어 name은 이빠진 판요라고
이렇게 정해주지 않다면 이거는 무조건 순서에 맞춰서 들어갑니다

4335
04:43:29,000 --> 04:43:32,600
즉, 이 맨 앞에 게 무조건 이
name으로 들어가게 되고요

4336
04:43:32,700 --> 04:43:36,260
그 20이라는 숫자로 일단은
무조건 이 맨에 들어가 버리게 됩니다

4337
04:43:36,400 --> 04:43:43,080
그렇다는 거는 뒤에 false라는 값이 있는데
이게 그러면 이 old로 들어가게 되는데 어?

4338
04:43:43,180 --> 04:43:44,680
이게 실행이 안 되는 게 맞나요?

4339
04:43:44,740 --> 04:43:51,240
Old가 들어가면 여기에 false가 들어가서 이거는
함수 자체가 잘못되니까 실행 자체를 안 해버리네요

4340
04:43:51,340 --> 04:43:56,400
이게 그냥 무지성으로 실행했으면
사실 실행은 됐을 텐데 원칙이 있습니다

4341
04:43:56,580 --> 04:43:57,800
이게 헷갈릴 수 있잖아요

4342
04:43:58,060 --> 04:44:03,359
그 old를 맞춰서 이렇게 넣으려고
하니까 이 기본값이 되는 게 중간에 껴 있어

4343
04:44:03,383 --> 04:44:08,380
버리니까 그래서 파이썬에서는 항상 이런
기본값이 지정된 함수는 맨 뒤에 써야 됩니다

4344
04:44:08,540 --> 04:44:14,220
그래서 이런 기본값이 지정된 매개변수는
항상 맨 뒤로 와야 된다라는 법칙이 있습니다

4345
04:44:14,440 --> 04:44:21,676
그래서 애초에 함수가 안 됐기 때문에 오류가 난 거고 그래서
항상 지정된 값이, 기본값이 박혀 있다면 얘는 맨 뒤로 보내야 된다

4346
04:44:21,700 --> 04:44:23,280
그래야 함수가 구성이 됩니다

4347
04:44:23,540 --> 04:44:25,660
그래서 이렇게 되면 정상 실행이 되겠죠

4348
04:44:25,780 --> 04:44:30,140
여기 보면은 초기 값이 있는
매개변수 무조건 뒤에 놔야 됩니다

4349
04:44:30,320 --> 04:44:36,460
즉, 매개변수로 이렇게는 되지만 중간에 이렇게 기본값을
적어 놓고 정의해 주는 것은 함수 순서가 헷갈릴 수 있겠죠

4350
04:44:36,540 --> 04:44:36,920
그렇게 되면

4351
04:44:37,040 --> 04:44:39,100
그래서 이렇게는 정의를 할 수가 없습니다

4352
04:44:39,380 --> 04:44:46,460
그래서 매개변수 초기 값을 지정한 매개변수를 놓고 싶다면
항상 뒤쪽에 놓아야 된다는 것을 기억해 두시면 좋을 것 같습니다

4353
04:44:46,840 --> 04:44:50,840
그 다음에 함수 안에서 선언한 변수의
효력 범위를 알아보도록 하겠습니다

4354
04:44:51,200 --> 04:44:52,760
이거는 약간 헷갈릴 수 있어요

4355
04:44:52,900 --> 04:44:53,940
그런데 중요한 부분입니다

4356
04:44:54,080 --> 04:44:55,500
처음에 a가 1이에요

4357
04:44:55,680 --> 04:44:57,700
일단 실행하기 전에 한번 생각을 해볼게요

4358
04:44:57,860 --> 04:45:04,757
A가 1이고 var test a를 실행했으니까 1이
여기 들어가서 a가 2가 된 다음에 2를 다시

4359
04:45:04,781 --> 04:45:10,320
a에 담았으니까 그러면 프린트 a를 했을 때
2가 나오지 않을까 라는 생각을 할 수가 있습니다

4360
04:45:10,480 --> 04:45:13,200
그런데 실행을 해보면 놀랍게도 1이 나옵니다

4361
04:45:13,300 --> 04:45:14,600
그래서 굉장히 헷갈릴 수 있습니다

4362
04:45:14,780 --> 04:45:16,160
어떻게 1이 나오게 된다

4363
04:45:16,220 --> 04:45:17,400
이거를 배워보도록 하겠습니다

4364
04:45:17,820 --> 04:45:18,560
이게 왜 그러냐

4365
04:45:18,600 --> 04:45:22,560
일단 왜 그런지부터 설명을
드리면 함수 안에서 이 변수 있죠

4366
04:45:22,700 --> 04:45:28,260
이거는 a, a라서 헷갈리는데 이거랑
이거랑 같은 거고 얘는 또 다른 a입니다

4367
04:45:28,400 --> 04:45:36,400
값을 담는 상자로서의 a인데 이거를 이렇게 넣어준다고
해도 이 a는 함수 안에서 사용된 지역 변수입니다

4368
04:45:36,840 --> 04:45:40,720
우리가 여기서 프린트하는 거는 위에 있는 전역 변수입니다

4369
04:45:40,920 --> 04:45:48,920
이게 약간 헷갈릴 수 있는데 함수 안쪽에 들어 있는 이 변수는 지역
변수라고 해서 함수가 끝나면은 지역 변수는 더 이상 쓰이지가 않습니다

4370
04:45:51,060 --> 04:45:51,800
없어집니다

4371
04:45:51,900 --> 04:45:59,900
근데 이렇게 전역 변수로 지정된 즉 이 함수 바깥에
있는 변수는 계속 남아 있으니까 여기서 출력이 되겠죠

4372
04:46:00,220 --> 04:46:02,657
그래서 함수 안에 있는 변수는 전역 변수입니다

4373
04:46:02,681 --> 04:46:06,040
그래서 함수가 끝나면 없어진다
라고 이해하시면 좋을 것 같습니다

4374
04:46:06,200 --> 04:46:07,540
그래서 이게 헷갈릴 수 있잖아요

4375
04:46:07,760 --> 04:46:14,920
그래서 파이썬 비주얼라이저 여기 수업 자료 중에 파이썬
시각화 도구로 보면은 좀 더 이해를 도울 수가 있을 것 같습니다

4376
04:46:15,040 --> 04:46:16,520
먼저 a는 1이라고 정의를 했어요

4377
04:46:16,700 --> 04:46:19,860
그러면 a는 1이라는 게 이제 상자에 담기게 되죠

4378
04:46:19,920 --> 04:46:26,280
그리고 발 테스트라는 함수를 정의했고 프린트
발 테스트를 수행하게 되면은 발 테스트로 들어왔죠

4379
04:46:26,340 --> 04:46:32,656
그러면 a는 a 더하기 1 이거를 해서 이 등호 다시
생각해보면 a 더하기 1을 해서 a라는 상자에 넣는다

4380
04:46:32,680 --> 04:46:36,740
이제 a 더하기 1을 수행해서 a라는 상자에 넣었습니다

4381
04:46:36,940 --> 04:46:44,480
근데 a라는 상자는 이 함수 안에서 사용되는 이
발 테스트라는 함수 안에서 사용되는 지역 변수에요

4382
04:46:44,580 --> 04:46:48,740
그렇다는 건 이 글로벌 프레임에
있는 전역 변수랑 지금 상관이 없습니다

4383
04:46:48,960 --> 04:46:49,800
그래서 떨어져 있죠

4384
04:46:49,940 --> 04:46:51,080
그래서 아예 다른 a입니다

4385
04:46:51,200 --> 04:46:54,936
그러다 보니까 다음 단계 함수가 종료되어 버리면 없어져요

4386
04:46:54,960 --> 04:46:56,180
함수 자체가 없어집니다

4387
04:46:56,260 --> 04:47:02,637
그러면 이제 밖에 남아 있는 a는 이 바깥에 있는
a기 때문에 얘는 프린트 a라면 1이 나오게 됩니다

4388
04:47:02,661 --> 04:47:05,860
그래서 출력을 하면 지금 1이 출력이 됐죠

4389
04:47:05,920 --> 04:47:08,040
그래서 이렇게 헷갈릴 수 있는 개념

4390
04:47:08,080 --> 04:47:10,640
지역 변수와 전역 변수를 알아보았습니다

4391
04:47:10,720 --> 04:47:15,200
트위치에서 질문도 주셨는데 애플
그레이프님 지역 변수는 일회용인가요?

4392
04:47:15,960 --> 04:47:20,420
일회용이라고도 쓸 수 있는데 함수
안에서 이 범위 안에서 사용되는 변수입니다

4393
04:47:20,660 --> 04:47:22,220
그러니까 이거를 여러 번 쓸 수도 있겠죠

4394
04:47:22,360 --> 04:47:27,400
A는 1하고 안쪽에 있는 a를 출력해서 한 번
더 활용해서 여기서는 2를 출력할 수도 있겠죠

4395
04:47:27,560 --> 04:47:29,600
이렇게 이렇게 할 수도 있겠습니다

4396
04:47:29,820 --> 04:47:32,540
지역 변수를 리턴 안 하면 그냥
함수 안에서만 사용되는 겁니다

4397
04:47:32,660 --> 04:47:36,320
이제 마스터님이 질문 주신 내용을 함께 보도록 하겠습니다

4398
04:47:36,540 --> 04:47:38,020
책에도 그 내용이 나옵니다

4399
04:47:38,120 --> 04:47:40,900
그러면 이렇게 문제가 생긴 상황을 확인했어요

4400
04:47:41,240 --> 04:47:49,240
이게 헷갈린 이유가 뭐냐면 지금 예제가 일부러 헷갈리게 해놨는데
여기 hello가 있는데 이 hello가 있고 그러니까 얘는 상자로서의

4401
04:47:50,321 --> 04:47:55,576
hello고 얘는 그 매개변수 함수 안에서
사용되는 그 매개변수로서의 hello인데 얘는

4402
04:47:55,600 --> 04:48:00,620
지역 변수로서의 hello라서 이게 헷갈릴
수 있지만 얘는 그냥 지역 변수일 뿐입니다

4403
04:48:00,780 --> 04:48:02,636
그래서 함수 밖의 변수 이름으로서

4404
04:48:02,660 --> 04:48:07,960
전혀 상관없는 안에서 사용되는 지역
변수다라는 것을 이해하시면 좋을 것 같습니다

4405
04:48:08,120 --> 04:48:09,660
이것도 하나 보겠습니다

4406
04:48:09,880 --> 04:48:11,360
예제 중에 이렇게 나온 게 있어요

4407
04:48:11,580 --> 04:48:14,800
그러면 아예 지금은 이제 전역 변수를 안 만들었습니다

4408
04:48:14,960 --> 04:48:19,580
바깥에 있는 변수 없이 발 테스트
안에서 이 함수 안에서 a를 사용했습니다

4409
04:48:19,880 --> 04:48:27,740
그럼 함수 안에서 사용되는 a는 3을 넣는다고 해서 이렇게
3 더해서 3 더하기 4 해서 4가 되고 a는 4라는 게 완성이 되죠

4410
04:48:27,800 --> 04:48:30,477
근데 출력을 해보면 애초에 오류가 납니다

4411
04:48:30,501 --> 04:48:30,940
어?

4412
04:48:31,000 --> 04:48:34,240
A가 아예 정의가 되지 않았어 라고 오류를 뱉습니다

4413
04:48:34,360 --> 04:48:42,360
이게 왜 그러냐면 a라는 값이 이제 전역 변수로 아까는
있어서 이걸 출력한 건데 얘는 함수 안에서만 사용되는 a만 썼어요

4414
04:48:42,700 --> 04:48:46,237
그렇다는 거는 함수가 종료되는 순간 이제 없어집니다

4415
04:48:46,261 --> 04:48:46,760
A라는 거는

4416
04:48:46,860 --> 04:48:50,580
그 변수의 범위에 대해서 좀
이해를 해보시면 좋을 것 같습니다

4417
04:48:50,820 --> 04:48:53,560
그래서 이걸 보면은 좀 이해가 되실 것 같습니다

4418
04:48:53,820 --> 04:49:00,400
그러면은 실제로 함수 안에서 뭔가 활용한 거를
만든 거를 실제로 그 함수 바깥에서 활용하면 좋잖아요

4419
04:49:00,500 --> 04:49:03,380
그래서 그걸 어떻게 하는지 배워볼 수 있도록 하겠습니다

4420
04:49:03,600 --> 04:49:04,320
어떻게 하냐

4421
04:49:04,400 --> 04:49:05,880
리턴을 사용하면 됩니다

4422
04:49:06,100 --> 04:49:08,080
리턴은 이제 돌려주는 거잖아요

4423
04:49:08,160 --> 04:49:08,960
출력해주는 거

4424
04:49:09,020 --> 04:49:09,260
네

4425
04:49:09,320 --> 04:49:09,896
돌려준다

4426
04:49:09,920 --> 04:49:10,440
출력값

4427
04:49:10,500 --> 04:49:13,000
뭐 용어는 다양하지만 아무튼 이걸 해보도록 하겠습니다

4428
04:49:13,240 --> 04:49:19,060
리턴을 주고 리턴이라는 건 이 함수가
수행되고 그 결과가 a에 넣는다가 되겠죠

4429
04:49:19,180 --> 04:49:27,180
즉 a는 1이니까 var test a하면 1을 넣어서 여기 1이
들어가고 2가 된 다음에 그 a는 2라는 값을 리턴을 해줬어요

4430
04:49:28,220 --> 04:49:32,880
그렇다는 건 이거의 결과인
2를 a에 넣는 행위를 한 겁니다

4431
04:49:33,040 --> 04:49:36,520
그렇기 때문에 프린트 a를 하면 이제는 2가 나옵니다

4432
04:49:36,640 --> 04:49:36,960
네

4433
04:49:37,000 --> 04:49:40,420
이렇게 리턴을 통해서 리턴이 이제 내뱉는 거죠

4434
04:49:40,900 --> 04:49:46,500
내뱉었으니까 이 내뱉은 값을 a가
받아주게 되면 그 a 값이 바뀔 수가 있겠죠

4435
04:49:46,600 --> 04:49:47,000
밖에서도

4436
04:49:47,160 --> 04:49:51,800
그래서 이렇게 리턴을 활용하게 되면 실제로
이 바깥에 있는 값도 바꿔줄 수가 있습니다

4437
04:49:52,040 --> 04:49:52,317
네

4438
04:49:52,341 --> 04:49:56,720
그리고 리턴만 하면 되는 게 아니라 사실
리턴을 만약에 하고 아무 조치도 안 했어요

4439
04:49:56,860 --> 04:50:04,560
이 var test 2가 여기서 2가 됐는데 프린트할 받아줄
무언가가 없으니까 이렇게 실행하면 또 1이 나옵니다

4440
04:50:04,620 --> 04:50:05,220
왜냐?

4441
04:50:05,260 --> 04:50:08,000
리턴했지만 이걸 저장을 아무 데도 안 해줬죠

4442
04:50:08,100 --> 04:50:16,100
그래서 a를 이렇게 받아줘야지만 이제 이 a라는 상자가
이제 리턴 값이 2니까 이 2를 a가 받아줘서 2가 나오게 됩니다

4443
04:50:17,080 --> 04:50:19,940
그래서 이거를 출력해야지만 이제 2가 나옵니다

4444
04:50:20,180 --> 04:50:23,000
비주얼라이저를 같이 해서 보면은 좀 도움이 될 것 같습니다

4445
04:50:23,140 --> 04:50:23,157
네

4446
04:50:23,181 --> 04:50:28,220
Var test 만들어서 이제 a 값에
1을 넣었으니까 a 더하기 1 해서

4447
04:50:28,244 --> 04:50:33,360
a가 2가 되는데 a가 된 거를 리턴해
주니까 그 리턴한 2를 다시 a에 넣죠

4448
04:50:33,460 --> 04:50:40,060
여기 6번째 줄에서 리턴 밸류가 2고 그거를 받아서
이제 다시 넣어줬으니까 a에 2라는 값이 들어가게 됩니다.

4449
04:50:40,360 --> 04:50:41,020
Wp님

4450
04:50:41,080 --> 04:50:44,520
그럼 굳이 헷갈리지 않게 전역변수와
지역변수를 다르게 사용하면 되지 않나요?

4451
04:50:44,600 --> 04:50:45,160
정확합니다

4452
04:50:45,260 --> 04:50:52,160
사실 다르게 사용하면 되는데 책에서는 일부러 이런 헷갈리는
개념이 나올 수 있다라고 해서 아예 이름을 같게 써서 그렇습니다

4453
04:50:52,300 --> 04:50:52,437
네

4454
04:50:52,461 --> 04:50:55,320
그래서 이렇게 b라고 쓰면 사실 전혀 안 헷갈리죠

4455
04:50:55,360 --> 04:50:59,340
이렇게 쓰고 여기는 뭐 c 이렇게 쓰면 아예 안 헷갈리죠

4456
04:51:06,200 --> 04:51:11,080
이렇게 해서 리턴을 사용해서
그 값을 받는 방법을 알아봤고요

4457
04:51:11,160 --> 04:51:12,700
또 다른 방법도 있습니다

4458
04:51:13,120 --> 04:51:14,920
글로벌이라는 명령어가 있어요

4459
04:51:15,300 --> 04:51:16,700
이렇게 보도록 하겠습니다

4460
04:51:17,200 --> 04:51:23,580
그러면 a라는 1을 주고 근데 여기서
함수 아닌데 글로벌 a라는 걸 썼어요

4461
04:51:23,660 --> 04:51:25,420
심지어 여기는 인풋 값도 없습니다

4462
04:51:25,880 --> 04:51:29,180
그러니까 입력도 안 받고 그냥 글로벌 a라고 썼다?

4463
04:51:29,340 --> 04:51:32,700
라고 하면 이 전역변수의 예약어로 쓰입니다

4464
04:51:33,100 --> 04:51:41,100
전역변수의 예약어로 글로벌 a라고 붙이면 이 가장 코드의
글로벌 전역변수로 사용되는 바깥쪽에 있는 a를 가져온다라는 뜻입니다

4465
04:51:42,240 --> 04:51:44,580
글로벌 a는 이 바깥쪽 a를 가져오는 거고요

4466
04:51:44,660 --> 04:51:50,320
그러면 a 더하기 1을 하면은 글로벌
a를 가져왔으니까 이 a가 상자가 되는 거죠

4467
04:51:50,400 --> 04:51:51,120
글로벌 a가

4468
04:51:51,160 --> 04:51:54,680
그러면 a 더하기 1을 해서 2를
넣으면은 실제로 2가 반영이 됩니다

4469
04:51:54,880 --> 04:51:57,200
그래서 실제 실행을 해보면 a가 2가 나오죠

4470
04:51:57,260 --> 04:52:02,380
왜냐하면 글로벌 a를 불러와서 그래서 이
a를 여기서 이렇게 활용을 했기 때문이죠

4471
04:52:02,460 --> 04:52:10,460
이것 또한 비주얼라이저로 보면 이렇게 되면 하나씩 실행을 해보면
발테스트나 함수는 실행을 했을 때 a가 이제 글로벌 a, 얘를 가져온 거죠

4472
04:52:11,660 --> 04:52:14,920
얘는 안에서, 발테스트 안에는
지역변수 a는 생기지 않았습니다

4473
04:52:15,120 --> 04:52:19,374
그리고 실행을 해보면 리턴 밸류는
당연히 여기 없으니까, 리턴이 없으니까

4474
04:52:19,398 --> 04:52:23,600
none이고 a 자체가 지금 글로벌
프레임에서 2로 바뀐 거를 확인할 수 있습니다

4475
04:52:23,780 --> 04:52:27,737
그래서 이렇게 실행하면 a가 2가
돼서 프린트 a라면 2가 나오게 됩니다

4476
04:52:27,761 --> 04:52:32,640
네, 그래서 이렇게 해서 이제 함수의
그 효력 범위에 대해서 좀 알아봤는데요

4477
04:52:32,740 --> 04:52:35,420
여기서 또 헷갈리는 개념이 있을 수가 있습니다

4478
04:52:35,640 --> 04:52:41,380
헷갈리는 개념만 다루면은 더 머릿속은 복잡해질 수
있는데 그래도 이걸 알면은 좀 도움은 될 수가 있겠죠

4479
04:52:41,600 --> 04:52:42,600
요런 게 있습니다

4480
04:52:42,820 --> 04:52:49,840
그 지난 시간에 이제 immutable, mutable에 대해서 설명을
해드렸는데 좀 다른 경우가 있어서 하나 보도록 하겠습니다.

4481
04:52:50,280 --> 04:52:55,060
A는 1을 넣는다고 해서 이 함수 안에
있는 이 a랑은 다른 a다 라고 말씀드렸죠

4482
04:52:55,100 --> 04:52:57,717
그렇기 때문에 프린트를 하면은 얘는 1이 나옵니다

4483
04:52:57,741 --> 04:53:02,080
왜냐면 그 1 더하기 1을 해서 2가
여기 들어갔어도 얘는 지역 변수니까

4484
04:53:02,240 --> 04:53:07,820
근데 여기서는 mutable 자료형에서
비슷한 과정을 수행하면 이렇게 됩니다

4485
04:53:08,020 --> 04:53:10,320
일단은 그 한번 예상을 해보시겠어요?

4486
04:53:10,440 --> 04:53:12,200
요걸 하면은 결과가 어떻게 나올까요?

4487
04:53:12,360 --> 04:53:16,740
자, 발테스트 2라는 거에 b라는 걸
넣었으니까 얘를 넣은 거겠죠, b에

4488
04:53:16,820 --> 04:53:20,800
그리고 b.append4를 해서 b라는 변수에 넣었어요

4489
04:53:21,040 --> 04:53:22,560
그러면 프린트를 하면 뭐가 나올까요?

4490
04:53:22,800 --> 04:53:24,060
네, 요거를 실행을 해볼게요

4491
04:53:24,240 --> 04:53:27,716
네, 요거를 수행하면 놀랍게도 1, 2, 3, 4가 나와요

4492
04:53:27,740 --> 04:53:28,460
어?

4493
04:53:28,660 --> 04:53:31,676
아니, 이게 지금까지 배운 게 그러면 무슨 소리야?

4494
04:53:31,700 --> 04:53:36,460
라고 더 헷갈릴 수가 있는데 이것까지 이해하면
이제 좀 완벽하게 이해하실 수 있을 겁니다

4495
04:53:36,600 --> 04:53:39,220
그러니까 b가 1, 2, 3, 2 얘는 전역 변수죠

4496
04:53:39,280 --> 04:53:42,540
그리고 여기 안에 있는 얘는 지역 변수가 맞아요

4497
04:53:42,740 --> 04:53:45,900
그래서 이 b는 함수가 끝나면 사라지는 게 맞습니다

4498
04:53:46,520 --> 04:53:46,580
어?

4499
04:53:46,660 --> 04:53:49,276
근데 왜 프린트를 하면은 1, 2, 3, 4가 되냐?

4500
04:53:49,300 --> 04:53:51,840
라고 한다면 여기 이 넘겨준 b 있죠?

4501
04:53:51,980 --> 04:53:52,980
이 매개변수 b

4502
04:53:53,040 --> 04:53:56,400
이거 자체가 이 리스트 자체를 넘긴 겁니다

4503
04:53:56,600 --> 04:53:57,716
B.append4가 되죠?

4504
04:53:57,740 --> 04:54:02,660
B.append4 하는 이 과정, 이 뒤에 있는
이 과정에서 b 자체가 변형이 된 겁니다

4505
04:54:02,840 --> 04:54:07,360
그래서 이거를 더 직관적으로 이해하기
위해서 그러면 처음에 b를 정의를 했습니다

4506
04:54:07,540 --> 04:54:15,540
그러면 b는 이 1, 2, 3이라는 리스트를 담고 있는데 얘가 그
뮤터블 자료형이기 때문에 이 리스트는 변화할 수가 있습니다

4507
04:54:16,340 --> 04:54:24,340
그래서 b는 요거를 갖고 있고 얘가 변화할 수 있다는 점 일단
기억해두시고 그 다음에 함수를 정의했고 그 함수를 수행을 합니다

4508
04:54:24,940 --> 04:54:32,276
그러면 일단은 b에서 b라는 변수, 지역
변수를 만들고 얘를 append를 해서 하나

4509
04:54:32,300 --> 04:54:38,540
수행을 해보면 b.append를 해서
1, 2, 3, 4를 만들어서 여기 담았어요

4510
04:54:38,660 --> 04:54:42,120
근데 이제 함수가 끝나면 b에 담은 거는 none입니다.

4511
04:54:42,260 --> 04:54:43,260
None을 담은 겁니다

4512
04:54:43,320 --> 04:54:43,700
왜냐?

4513
04:54:44,080 --> 04:54:46,180
Append는 리턴 값이 없어요

4514
04:54:46,420 --> 04:54:48,760
즉, b라는 거는 비어있습니다, 지금

4515
04:54:48,900 --> 04:54:50,080
그리고 지역 변수예요

4516
04:54:50,180 --> 04:54:51,640
즉, 함수가 끝나면 사라집니다

4517
04:54:51,760 --> 04:54:57,220
근데 이 b.append라는 행위를
통해서 이 b 자체를 변화를 준 거죠

4518
04:54:57,740 --> 04:55:01,720
그래서 b 자체가 뮤터블 자료형이기
때문에 이렇게 변화가 된 겁니다

4519
04:55:01,920 --> 04:55:06,480
그래서 printb를 하면은 이거 자체가
출력이 돼서 1, 2, 3, 4가 나오게 됩니다

4520
04:55:06,760 --> 04:55:13,280
네, 약간 많은 개념들이 들어가서 좀 헷갈릴 수 있는데
이것만 이해하면 이제 함수를 완벽하게 이해할 수 있습니다

4521
04:55:13,500 --> 04:55:18,260
그러면은 아까 다시 돌아가서 a는 1
하고 네, 이렇게 바꾸면 뭐가 다를까요?

4522
04:55:18,360 --> 04:55:24,280
생각해보면 이 a 더하기 1을 수행했는데
a 더하기 1은 a 자체가 변한 게 아닙니다

4523
04:55:24,360 --> 04:55:28,080
이 a 더하기 1을 해서 새로운 값을 만든 겁니다

4524
04:55:28,240 --> 04:55:30,460
이라는 값을 새롭게 만든 거예요

4525
04:55:30,620 --> 04:55:33,220
약간 더 이해를 돕기 위해 스트링으로 바꿔보겠습니다

4526
04:55:33,820 --> 04:55:38,580
그 이뮤터블 자료형인 정수, 실수,
문자열, 튜플은 변형이 불가능해요

4527
04:55:38,700 --> 04:55:41,480
자, 변형이 불가능하고 뮤터블은 변형이 가능합니다

4528
04:55:41,660 --> 04:55:47,780
그러면 이뮤터블 자료형이 어떤 거냐 예를 들어
a는 hello 얘는 이뮤터블 변경이 불가능한 자료예요

4529
04:55:47,880 --> 04:55:51,100
그러면 이거를 수행했을 때
일단은 a의 hello를 정의했어요

4530
04:55:51,300 --> 04:55:52,620
얘는 변화가 불가능합니다

4531
04:55:52,800 --> 04:55:58,200
그렇기 때문에 a의 이제 high를 더한 거를
수행하고 a 더하기 high는 hello high가 되겠죠.

4532
04:55:58,300 --> 04:56:00,740
Hello high라는 값을 새롭게 만든 겁니다

4533
04:56:00,940 --> 04:56:08,940
즉, a 더하기 high는 a 자체 얘를 변형한 게 아니라 새롭게 hello
high라는 거를 덧셈으로 새롭게 생성을 해서 그걸 a에 담아준 겁니다

4534
04:56:10,280 --> 04:56:17,600
즉, 이뮤터블 자료형은 변화하지 않았는데 아까 뮤터블
자료형은 리스트를 추가하는 행위 자체가 이걸 변화를 시켜버린 거죠

4535
04:56:17,760 --> 04:56:25,760
그래서 여기 담는 a는 지역 변수라서 없어지는데
결과적으로 여기 a는 변하지 않아서 hello가 그대로 출력이 됩니다

4536
04:56:25,800 --> 04:56:28,140
네, 이거는 지역 변수 a고요

4537
04:56:28,300 --> 04:56:34,740
이게 굉장히 헷갈리는 요소를 총출동해서
지금 다 넣었기 때문에 굉장히 어려울 수 있습니다

4538
04:56:35,000 --> 04:56:41,780
근데 이것만 이해되시면 여러 번 반복해서 시청을
하셔서 이해가 되시면 함수를 완벽하게 이해하신 겁니다

4539
04:56:42,000 --> 04:56:43,596
함수와 지역 변수의 개념을

4540
04:56:43,620 --> 04:56:46,540
네, 이 부분은 여러 번 돌려보시길 권장드립니다

4541
04:56:46,800 --> 04:56:50,420
아, 그리고 약간 도움이 될 수 있는
개념을 좀 설명드리면 이런 게 있습니다

4542
04:56:50,700 --> 04:56:53,220
A가 a.pop 이거 기억나시나요?

4543
04:56:53,260 --> 04:56:55,776
Pop이랑 append랑 차이를 좀
설명해드리면 조금 더 이해가 되실 수 있습니다

4544
04:56:55,800 --> 04:56:57,200
조금 더 이해가 좋으실 수 있습니다

4545
04:56:57,300 --> 04:57:00,740
여기에 5를 추가하는 거랑
일단은 append부터 보겠습니다

4546
04:57:01,040 --> 04:57:03,420
그러면 append를 예전에 이런 거 있었죠?

4547
04:57:03,460 --> 04:57:06,280
Append를 출력을 해보면 이거를 실행해볼게요

4548
04:57:06,420 --> 04:57:11,120
잘못 생각하면 1, 2, 3, 4, 5가 나올 수
있다고 생각이 드는데 놀랍게도 none이 나옵니다

4549
04:57:11,200 --> 04:57:11,520
왜냐?

4550
04:57:11,580 --> 04:57:15,540
이 append는 변형하는
함수고 return 값이 없습니다

4551
04:57:15,920 --> 04:57:21,160
즉, append를 실제로 이렇게 함수 정의를
보면 여기 마우스 올리면 함수 정의가 나오거든요

4552
04:57:21,320 --> 04:57:25,776
근데 여기 df append 즉, append의
함수는 여기 실제로 나옵니다

4553
04:57:25,800 --> 04:57:32,620
그러니까 append를 다시 정의하자면 하나를
추가함 이라고 코드가 있는데 return 값은 없습니다.

4554
04:57:32,900 --> 04:57:33,460
None입니다

4555
04:57:33,620 --> 04:57:37,140
리스트에 추가하는 행위를 할 뿐이지
return으로 돌려주는 값이 없어요.

4556
04:57:37,320 --> 04:57:41,586
Return 값이 없기 때문에 이거를
수행했을 때 append는 return

4557
04:57:41,610 --> 04:57:45,740
해주는 게 없어서 이 a를 변형하긴
하지만 result에는 none이 담깁니다

4558
04:57:45,840 --> 04:57:49,120
그래서 이 result를 출력해보면
none이 이렇게 나오게 되는 거죠

4559
04:57:49,280 --> 04:57:50,280
네, 이렇게 됩니다

4560
04:57:50,400 --> 04:57:52,640
그러면 a를 출력하면 어떻게 될까요?

4561
04:57:52,740 --> 04:57:55,757
A를 출력하면 1, 2, 3, 4, 5가 나오게 됩니다

4562
04:57:55,781 --> 04:57:56,220
이게 맞습니다

4563
04:57:56,420 --> 04:57:59,900
Append는 5를 a에 변형을 해서 추가한 거고요

4564
04:57:59,940 --> 04:58:04,980
얘는 mutable, 변형 가능한 자료형이기
때문에 여기에 5를 추가해 줬는데 실제로

4565
04:58:05,004 --> 04:58:09,920
append 함수를 다 수행하면 이
append 함수는 return 값이 none입니다.

4566
04:58:10,100 --> 04:58:11,100
Return이 없어요

4567
04:58:11,180 --> 04:58:12,180
얘는 따로 없어요

4568
04:58:12,280 --> 04:58:16,420
그렇기 때문에 a는 변형됐지만
result에는 none이 들어갑니다

4569
04:58:16,880 --> 04:58:17,880
네, 이거 이해되시나요?

4570
04:58:17,940 --> 04:58:20,540
이거 이해되시면 굉장히 많은 부분을 이해하신 겁니다

4571
04:58:20,860 --> 04:58:22,920
그러면 이제 반대로 다른 걸 볼게요

4572
04:58:23,080 --> 04:58:24,080
Pop을 해볼게요.

4573
04:58:24,140 --> 04:58:24,320
Pop

4574
04:58:24,480 --> 04:58:27,380
네, pop을 하면은 이거 결과가 어떻게 나올까요?

4575
04:58:27,460 --> 04:58:28,880
이거 굉장히 재밌습니다

4576
04:58:29,220 --> 04:58:32,960
Pop은 그때도 말씀드렸다시피 return이 있어요

4577
04:58:33,120 --> 04:58:36,940
하고 마지막 값을 퍽 뽑아서 이렇게 뱉어준다고 그랬죠?

4578
04:58:37,060 --> 04:58:42,080
그래서 얘는 마지막 요소 a를 변형시켜서
마지막 요소를 return을 해줍니다.

4579
04:58:42,220 --> 04:58:43,740
Return 4가 되는 거예요

4580
04:58:43,840 --> 04:58:45,120
그래서 마지막 게 뽑아지니까

4581
04:58:45,260 --> 04:58:50,200
그래서 result에 4가 담겨서 4가
담기고 이거를 출력해보면 4가 나옵니다

4582
04:58:50,280 --> 04:58:56,600
그러면 print a까지 해보면 4를 출력해주고
list를 출력해주고 요런 구조가 되겠죠

4583
04:58:56,720 --> 04:59:02,320
근데 4는 날라갔으니까 팍 하고 들어가서
result에는 들어가지만 이제 여기는 나오지 않는다

4584
04:59:03,320 --> 04:59:06,860
네, return이 있냐 없냐에 대해서
요렇게 이해를 해볼 수가 있겠습니다

4585
04:59:07,160 --> 04:59:11,320
함수를 배우면 이제 이런 것까지
이제 좀 깊게 이해를 할 수가 있습니다

4586
04:59:11,580 --> 04:59:15,920
약간 어려울 수 있기 때문에 이거는
반복 시청을 한번 해보시기 바랍니다

4587
04:59:16,060 --> 04:59:18,120
그래서 요렇게 이해를 할 수가 있겠고요

4588
04:59:18,220 --> 04:59:24,517
그래서 이제 그 두 개 append랑 pop의 차이를
아셨으면 다음 거를 좀 이해할 수가 있을 것 같습니다

4589
04:59:24,541 --> 04:59:28,820
네, append는 출력 안 하고 그
리스트만 변형이 돼서 그런 겁니다

4590
04:59:28,980 --> 04:59:35,220
그래서 이거를 변형했기 때문에 네, 이거를
생각해 보시면 네, 여기서는 이제 append를 한죠.

4591
04:59:35,300 --> 04:59:38,880
Append는 근데 return 값이
없기 때문에 none이 들어갑니다

4592
04:59:38,960 --> 04:59:41,560
다시 보면은 지역 변수에 none이 들어가죠.

4593
04:59:41,620 --> 04:59:42,300
B가 none

4594
04:59:42,420 --> 04:59:43,420
왜 none이냐?

4595
04:59:43,640 --> 04:59:46,100
Append가 return 값이 없기 때문입니다

4596
04:59:46,240 --> 04:59:51,643
그래서 여기에 none이 들어가게 되고
지역 변수는 근데 지역 변수는 사라지고

4597
04:59:51,667 --> 04:59:56,280
b 자체가 이 append 함수 때문에
뮤터블 자료형이라 변화를 해버립니다

4598
04:59:56,380 --> 04:59:57,940
그래서 4가 추가가 되겠죠

4599
04:59:58,080 --> 04:59:58,880
이걸 이해했다?

4600
04:59:58,980 --> 05:00:06,440
하면은 프로그래밍의 그 함수와 지역 변수와 전역
변수와 이런 개념에 대해서 확 잡은 그런 종합 예제입니다

4601
05:00:06,640 --> 05:00:08,820
A 인서트 차이는요?

4602
05:00:09,220 --> 05:00:10,900
이거는 리턴이 있을까요?

4603
05:00:11,060 --> 05:00:13,020
0번 자리에 10을 넣는다

4604
05:00:13,060 --> 05:00:19,336
이렇게 하면은 네, 이것도 인서트도 a를
변형하는 거지 인서트도 0번 자리에 10을 넣는다

4605
05:00:19,360 --> 05:00:20,736
즉 0번 자리에 10을 넣는다

4606
05:00:20,760 --> 05:00:25,960
A를 추가를 하고 a를 변형하는 거지 여기
리턴되는 리절트로 리턴해주는 값은 none입니다

4607
05:00:26,380 --> 05:00:27,780
변형한 행위일 뿐이죠

4608
05:00:27,880 --> 05:00:28,420
말 그대로

4609
05:00:28,620 --> 05:00:29,680
오, 최하림님

4610
05:00:29,800 --> 05:00:31,180
와, 완벽하게 이해하셨습니다

4611
05:00:31,500 --> 05:00:35,600
아주 좋은 예제까지 써주셨는데 그럼 이게
append가 아니라 pop이면 어떻게 될까요?

4612
05:00:35,680 --> 05:00:35,820
Pop

4613
05:00:35,900 --> 05:00:39,540
진행을 해보면 pop을 통해서
튀어나오면 이거 자체가 변형이 되죠

4614
05:00:39,620 --> 05:00:40,340
이게 뽑힙니다

4615
05:00:40,440 --> 05:00:42,080
지금 3번이 뽑혀서 튀어나왔죠

4616
05:00:42,140 --> 05:00:43,260
그리고 리턴을 해줍니다

4617
05:00:43,400 --> 05:00:44,820
그러면 b에 담기죠, 이게.

4618
05:00:44,920 --> 05:00:45,500
Pop 돼서

4619
05:00:45,540 --> 05:00:51,200
그러면 return b를 하면은 이게 3이
돼서 3이 또 b에 담겨서 3이 출력이 됩니다

4620
05:00:51,400 --> 05:00:52,300
이걸 맞추셨다?

4621
05:00:52,380 --> 05:00:54,180
이제 여러분들은 마스터하신 겁니다

4622
05:00:54,360 --> 05:01:02,360
함수와 지역변수, 전역변수 그리고 immutable, mutable에
대해서 완벽하게 이 예제를 통해서 다 이해를 하실 수가 있습니다

4623
05:01:03,180 --> 05:01:08,140
이거 이해되셨으면 사실 이번 시간을
거의 알차게 들으신 거라고 생각하시면 돼요

4624
05:01:08,200 --> 05:01:10,520
뒤에 내용 더 있긴 한데 이게 가장 핵심입니다

4625
05:01:10,780 --> 05:01:15,080
이걸 다 이해했다면은 여러분들은
파이썬에 어느 정도 경제에 오르신 겁니다

4626
05:01:15,340 --> 05:01:16,860
아주 중요한 걸 배워봤습니다

4627
05:01:17,020 --> 05:01:18,420
또 빠질 수 없는 게 하나 있죠

4628
05:01:18,740 --> 05:01:20,096
패션 코딩을 또 배웠습니다

4629
05:01:20,120 --> 05:01:21,120
배워보도록 하겠습니다

4630
05:01:21,160 --> 05:01:24,160
역시 패션 코딩은 어느 단어에나 빠지지 않습니다

4631
05:01:24,300 --> 05:01:25,080
몰라도 됩니다

4632
05:01:25,260 --> 05:01:31,600
몰라도 되지만 그래도 멋있게 쓰기 위해서
아 이거 함수를 조금 간지나게 좀 쓰고 싶다

4633
05:01:31,640 --> 05:01:35,020
나는 좀 이렇게 남들과는 다르고 싶다

4634
05:01:35,100 --> 05:01:40,260
이런 좀 멋있게 짧게 쓰고
싶으면은 람다 예약어를 쓰면 됩니다

4635
05:01:40,820 --> 05:01:42,160
자, 이거를 보도록 하겠습니다

4636
05:01:42,800 --> 05:01:50,800
그 원래 함수를 정의한다면 add라는 함수를 정해주고 a, b라는
매개변수를 받아서 return a 더하기 b라고 쓸 수도 있는데 약간

4637
05:01:53,821 --> 05:02:00,160
개발 쪽에서 패션 코딩을 좀 좋아하시는 분들은
이거를 이렇게 두 줄로 쓰는 걸 눈뜨고 볼 수가 없어요

4638
05:02:00,300 --> 05:02:02,220
아, 이거는 너무 예쁘지가 않다

4639
05:02:02,280 --> 05:02:04,940
코드는 이렇게 쓰면 안 된다라고 생각할 수가 있습니다

4640
05:02:05,640 --> 05:02:11,760
네, 그런 경우에 이렇게 람다라는 키워드로 좀
한 줄로 딱 줄여서 깔끔하게 표현할 수가 있습니다

4641
05:02:12,020 --> 05:02:19,040
네, 람다라고 쓴 다음에는 람다 뒤에 a, b
이게 이제 요거 매개변수가 여기 들어가고요

4642
05:02:19,120 --> 05:02:20,096
그리고 콜론은요

4643
05:02:20,120 --> 05:02:23,540
콜론을 쓰고 뒤에 리턴 값은 이 콜론 뒤에 써줍니다

4644
05:02:23,640 --> 05:02:27,120
그러면 요걸로 깔끔하게 함수가 표현이 됩니다

4645
05:02:27,320 --> 05:02:28,960
그럼 요거랑 요거랑 같은 겁니다

4646
05:02:29,160 --> 05:02:35,140
근데 이 함수 자체를 add라는 변수에 담았으니까
요렇게 똑같이 활용을 할 수가 있겠습니다

4647
05:02:35,560 --> 05:02:36,560
네, 요거 이해되시나요?

4648
05:02:36,600 --> 05:02:38,040
요거는 패션 코딩입니다

4649
05:02:38,340 --> 05:02:41,680
요렇게 두 줄로 쓸 거 요렇게 한 줄로 써보겠다

4650
05:02:41,820 --> 05:02:43,400
네, 요렇게 쓸 수가 있겠습니다

4651
05:02:43,660 --> 05:02:48,447
그러면 요걸 실행하면 add라는 함수를 수행한
거니까 네, 여기에 3 더하기 4가 돼서 똑같이

4652
05:02:48,471 --> 05:02:51,440
7이 나오는 건 위에서 3 더하기 4가 돼서
7이 나오는 건 위에 거나 아래 거나 같습니다

4653
05:02:51,660 --> 05:02:53,280
그래서 깔끔하게 한 줄로 쓸 수 있다

4654
05:02:53,520 --> 05:02:59,160
이거를 쓰면 또 뭐 어떤 경우에 좀
유용하게 쓸 수 있냐 이런 경우도 있겠죠

4655
05:02:59,380 --> 05:03:02,400
예를 들어 함수 이름을 정하기 싫을 수도 있어요

4656
05:03:02,700 --> 05:03:04,560
람다 함수는 함수 이름을 안 정해도 됩니다

4657
05:03:04,980 --> 05:03:08,140
그 파이썬 그냥 함수는 여기 이름을 무조건 써야 되잖아요

4658
05:03:08,340 --> 05:03:09,920
근데 이름을 안 지울 수도 있습니다

4659
05:03:10,280 --> 05:03:13,760
그 리스트에 그냥 람다 함수 자체를 담을 수가 있어요

4660
05:03:14,100 --> 05:03:15,100
그럼 이게 무슨 말이냐

4661
05:03:15,140 --> 05:03:17,420
이 람다 함수를 막 여러 개를 담아볼게요

4662
05:03:17,580 --> 05:03:23,674
A란 리스트에 자, 람다 a b를 받아서 a
더하기 b를 해주는 거랑 람다 a b를 받아서

4663
05:03:23,698 --> 05:03:29,640
a 곱하기 b를 해주는 거랑 이렇게 두 개의
함수를 그냥 a란 리스트에 두 개를 담았어요

4664
05:03:29,700 --> 05:03:30,520
더 담아도 돼요

4665
05:03:30,640 --> 05:03:33,920
그냥 이름 없이 그냥 함수
기능만 이렇게 담을 수가 있습니다

4666
05:03:34,300 --> 05:03:39,500
이거를 프린트 a에 0번째를 불러오면 얘를 불러온 거죠

4667
05:03:39,910 --> 05:03:43,220
그러니까 함수 이름도 안 정했는데
그냥 얘를 이렇게 불러올 수가 있습니다

4668
05:03:43,520 --> 05:03:51,520
이거를 이렇게 불러와서 그러면 더하기니까 뭐 34
이렇게 입력을 해주면 실행을 하면 똑같이 7이 나옵니다

4669
05:03:51,820 --> 05:03:53,960
3 더하기 4가 이렇게 수행이 되는 거죠

4670
05:03:54,140 --> 05:03:56,560
그러면 a에 1번째로 불러오면 어떻게 될까요?

4671
05:03:56,680 --> 05:03:59,900
A에 1번째로 불러오면 얘가 0번째 얘가 1번째죠

4672
05:03:59,960 --> 05:04:07,960
A에 그러면 이 함수를 불러와서 이 함수를 또 3, 4를 여기
넣어서 수행을 했으니까 3 곱하기 4가 돼서 12가 나옵니다

4673
05:04:10,180 --> 05:04:15,760
굉장한 패션 코딩 이런 게 이제
또 그냥 개발하는데 재미기도 하죠

4674
05:04:15,940 --> 05:04:22,620
이제 아 평범한 나는 평범한 게 싫다 이러면
이렇게 좀 패션 있게 패션 스타가 될 수가 있습니다

4675
05:04:22,940 --> 05:04:25,040
트리님 실무에서 람다 많이 쓰나요?

4676
05:04:25,160 --> 05:04:25,876
많이 씁니다

4677
05:04:25,900 --> 05:04:27,000
근데 은근히 많이 씁니다

4678
05:04:27,080 --> 05:04:31,280
왜냐하면 그냥 이름을 이렇게 안
짓고 가면은 빠른 경우가 되게 많거든요

4679
05:04:31,500 --> 05:04:35,380
그러니까 빠른 경우라는 게 뭐 성능이
아니라 그 어떤 함수를 넘겨야 될 때가 있어요

4680
05:04:35,500 --> 05:04:40,660
함수를 넘길 때 그냥 간단한 거면 이렇게
표현하는 게 이것보다 훨씬 간결하잖아요

4681
05:04:40,840 --> 05:04:42,240
그래서 실제로 많이 씁니다

4682
05:04:42,380 --> 05:04:46,240
몰라도 그냥 되긴 하는데 그냥
알아두면 좋다 인 것 같습니다

4683
05:04:46,740 --> 05:04:49,776
WP님 그런데 리턴 반환되는 함수와 그렇지 않은 함수는요?

4684
05:04:49,800 --> 05:04:51,200
이 함수는 어떻게 구부를 해야 되나요?

4685
05:04:51,260 --> 05:04:52,480
전부 암기해야 되나요?

4686
05:04:52,580 --> 05:04:53,256
아닙니다

4687
05:04:53,280 --> 05:04:56,160
이것 또한 외우지 않아도 VS 코드만 있으면 됩니다

4688
05:04:56,340 --> 05:04:59,140
마우스를 올려놓으면 append는 여기 나오죠.

4689
05:04:59,180 --> 05:05:05,578
Df append 그 none이 그 리턴이 된다라고
나오는데 팝은 마우스를 이렇게 올려놓으면

4690
05:05:05,602 --> 05:05:10,940
여기 팝이 수행이 된 다음에 리턴 값이
인티저 숫자가 나온다라고 지금 이렇게 나와 있죠

4691
05:05:11,060 --> 05:05:17,560
그래서 여기 a123이 이제 숫자가 여기 들어가니까 이게
숫자가 나온다라는 건데 마우스를 올려보면 알 수가 있습니다

4692
05:05:17,820 --> 05:05:19,280
이렇게 파악을 할 수가 있겠습니다

4693
05:05:19,480 --> 05:05:27,000
그리고 여기에 여기 마지막에 문자열이 들어가면 팝이 이제 any 그러니까
문자열 포함해서 모든 자료형이 나올 수 있다라고 이렇게 나오는 겁니다

4694
05:05:27,540 --> 05:05:29,620
나중에 보수할 때 헷갈리진 않으려나요?

4695
05:05:29,700 --> 05:05:37,100
이게 오히려 헷갈리는 경우도 있는데 안 헷갈리는 때만
람다를 잘 사용하면 사실 이게 진짜 멋있게 사용하는 겁니다

4696
05:05:37,300 --> 05:05:41,940
패션 코딩을 그래도 알아놓으면 좀
효율적이게 작업할 때 좀 도움이 됩니다

4697
05:05:42,420 --> 05:05:45,000
이름 지어서 작업하는 게 더 나을 때가 많죠

4698
05:05:45,080 --> 05:05:52,760
그래서 그렇게 주로 쓰되 그냥 짧게 줄이고 뭐 이렇게
함수만 넘겨야 되는 간략한 경우에는 그렇게 람다를 쓰면 좋습니다

4699
05:05:52,880 --> 05:05:55,920
그래서 이 패션 람다 코딩을 배워봤습니다

4700
05:05:56,080 --> 05:05:58,780
이렇게 해서 이제 함수의 주요 단원들을 다 끝냈습니다

4701
05:05:59,040 --> 05:06:06,780
함수 오늘 가장 중요한 걸 배웠는데 이거는 조금 복습을
해보시면 이걸 이해했다 하면 사실 함수의 거의 모든 걸 이해한 겁니다

4702
05:06:07,220 --> 05:06:09,960
그래서 이거는 꼭 한번 복습을 해보시기 바랍니다

4703
05:06:10,520 --> 05:06:13,380
그 다음에 이제 다음 단원으로 넘어가도록 하겠습니다

4704
05:06:13,900 --> 05:06:16,360
사용자 입출력을 나가보도록 하겠습니다

4705
05:06:16,620 --> 05:06:19,756
사용자 입출력은 아예 함수랑은 조금 다른데요

4706
05:06:19,780 --> 05:06:26,640
단원인데 네, 이거를 우리가 사용하는 대부분의 완성된
프로그램은 사용자의 입력에 따라 그에 맞는 출력을 내보냅니다

4707
05:06:26,760 --> 05:06:33,620
그래서 보통 어떤 프로그램이라 하면은 어떤 입력을
받아서 그거를 출력하는 이런 구조로 되어 있는 경우가 많습니다

4708
05:06:33,780 --> 05:06:39,520
그래서 이거를 파이썬에서는 어떻게 활용할 수
있는지 간단한 기본 예제들을 좀 살펴보도록 하겠습니다

4709
05:06:39,740 --> 05:06:45,500
그래서 사용자 입력을 활용할 때 파이썬에서 쓸 수 있는
굉장히 좋은 함수 중에 하나가 인풋이라는 함수가 있습니다

4710
05:06:45,720 --> 05:06:48,320
우리가 프린트는 막 주기적으로 많이 사용했잖아요

4711
05:06:48,480 --> 05:06:51,220
근데 이런 그런데 이런 비슷하게 인풋이라는 함수도 있습니다

4712
05:06:51,420 --> 05:06:55,600
네, 인풋이 어떤 역할을 하냐 파이썬이
이 코드를 실행하게 되면 멈춰 있습니다

4713
05:06:55,820 --> 05:07:00,860
여기 지금 커서가 있는데 여기 부분이 그
유저의 입력을 기다리고 있는 상황입니다

4714
05:07:00,980 --> 05:07:07,720
그래서 여기서 hello world를 하면은 네, 이렇게 프린트
A 때문에 이렇게 입력한 글자를 그대로 출력을 해줍니다

4715
05:07:07,920 --> 05:07:15,920
조금 더 변형을 해준다면 플러스 A 네, 이렇게 하면은 파이썬이라고 입력하고
엔터를 누르면 유저가 입력한 것은 파이썬이라고 입력을 받을 수가 있습니다

4716
05:07:18,100 --> 05:07:26,100
즉, 우리가 키보드로 어떤 값을 입력해서 파이썬 프로그램에
전달하고 싶을 때 그때 이렇게 인풋 함수를 써서 전달을 받을 수가 있습니다

4717
05:07:26,580 --> 05:07:28,700
그래서 이렇게 쓸 수 있다는 걸 소개해드렸고요

4718
05:07:28,780 --> 05:07:30,240
그 다음에 이런 것도 가능합니다

4719
05:07:30,340 --> 05:07:33,040
인풋 함수 중에 안내 문구를 써줄 수도 있어요

4720
05:07:33,180 --> 05:07:34,660
그래서 이렇게 써보도록 하겠습니다

4721
05:07:34,880 --> 05:07:38,140
이번에는 인풋 안에 파라미터로 스트링을 넣어줍니다

4722
05:07:38,260 --> 05:07:45,960
그렇게 되면 이제 인풋을 받을 때 실행하게 되면 이번에는
이렇게 숫자를 입력하세요라고 쓰고 가만히 기다리고 있습니다

4723
05:07:46,140 --> 05:07:51,819
그래서 이때 숫자를 하나 입력을 해주면
숫자가 입력받아져서 유저가 입력한 자가

4724
05:07:51,843 --> 05:07:56,860
들어가서 이게 넘버로 들어가고 그
넘버가 이제 출력이 돼서 이렇게 나온 겁니다

4725
05:07:57,020 --> 05:07:59,176
숫자를 써도 스트링으로 입력받나요?

4726
05:07:59,200 --> 05:08:00,020
인트로 입력받나요?

4727
05:08:00,120 --> 05:08:01,560
이거는 확인을 해보겠습니다

4728
05:08:01,720 --> 05:08:02,760
타입을 찍어보면 되죠

4729
05:08:02,800 --> 05:08:05,680
넘버를 찍어보면 어떻게 되나 실행을 해보겠습니다

4730
05:08:05,880 --> 05:08:08,560
숫자를 입력하면 스트링으로 입력이 됩니다

4731
05:08:09,040 --> 05:08:12,160
그래서 숫자를 써도 스트링으로 입력을 받습니다

4732
05:08:12,360 --> 05:08:13,360
이거는 언제 쓰냐?

4733
05:08:13,420 --> 05:08:21,420
뭐 이런 CLI에서 뭐 입력하는 프로그래밍 혹은 그 알고리즘 테스트 볼 때
보통 이렇게 유저 인풋을 이런 식으로 봤고 문제 인풋을 이런 식으로 봤죠

4734
05:08:23,880 --> 05:08:27,720
그래서 이런 알고리즘 테스트할
때는 이런 거 많이 보실 것 같습니다

4735
05:08:28,040 --> 05:08:31,760
이렇게 쓸 수가 있고 모든 것을 문자열로 취급합니다

4736
05:08:31,880 --> 05:08:33,080
인풋에 입력되는 거는

4737
05:08:33,480 --> 05:08:40,100
그래서 뭔가 형 변환이 필요하거나 할 때는 따로
이렇게 인티저로 변환해서 이거를 감싸줘야 됩니다

4738
05:08:40,340 --> 05:08:44,700
그래서 이렇게 변환을 할 수가 있는데
기본적으로는 스트링 자료형이 나오게 됩니다

4739
05:08:45,180 --> 05:08:50,753
그 다음에 우리가 그냥 흔하게 사용했던
것 중에 하나가 프린트 함수는 그냥 맨

4740
05:08:50,777 --> 05:08:55,800
처음 시간부터 그냥 막 사용했는데 사실
이 프린트 함수도 좀 기능들이 좀 있습니다

4741
05:08:55,960 --> 05:08:57,820
그래서 그것들을 하나씩 보도록 하겠습니다

4742
05:08:58,440 --> 05:09:02,940
이런 예제를 보면은 이거는 뭐 기본적인
거니까 그냥 한번 눈으로 쓱 볼게요

4743
05:09:03,550 --> 05:09:06,320
A는 123이라고 하고 프린트를 하면 123이 나오죠

4744
05:09:06,620 --> 05:09:08,580
문자열도 똑같이 출력이 됩니다

4745
05:09:08,860 --> 05:09:10,340
리스트를 해도 출력이 되고요

4746
05:09:10,440 --> 05:09:11,920
이거는 너무 많이 해봤죠

4747
05:09:12,260 --> 05:09:15,540
그 다음에 좀 특별한 기능들을 좀 체험해 보도록 하겠습니다

4748
05:09:15,860 --> 05:09:19,760
자 1번과 2번의 결과가 어떻게
나올지 한번 보도록 하겠습니다

4749
05:09:19,940 --> 05:09:24,720
1번의 경우에는 이게 어떻게 보면
파라미터가 이상하게 들어가 있어요

4750
05:09:24,880 --> 05:09:30,100
이게 3개긴 한데 뭐 콤마도 없고
그냥 이런 식으로 이상하게 들어가 있죠

4751
05:09:30,640 --> 05:09:33,280
이렇게 들어가 있는 것도 프린트는 처리를 해줍니다

4752
05:09:33,800 --> 05:09:41,800
그리고 얘는 더하기를 넣었으니까 파라미터가 하나가 들어갔는데
이 통째로 이걸 다 더해서 들어가게 됐는데 이거를 보도록 하겠습니다

4753
05:09:42,700 --> 05:09:46,297
1번이나 2번이나 같은 결과가 나온 걸 볼 수 있어요

4754
05:09:46,321 --> 05:09:49,880
이렇게 돼 있는 거는 자동으로 그냥 더해져서 처리를 합니다

4755
05:09:50,060 --> 05:09:53,280
그래서 1번과 2번이 동일한 결과를 냅니다

4756
05:09:53,460 --> 05:09:55,680
그래서 이렇게 처리를 할 수가 있고요

4757
05:09:56,160 --> 05:10:00,360
문자를 띄어쓰기는 이제 쉼표로
할 수가 있는데 이게 무슨 말이냐

4758
05:10:00,920 --> 05:10:03,800
이번에는 파라미터를 하나, 둘, 세 개를 넣었어요

4759
05:10:03,920 --> 05:10:10,980
세 개를 넣었는데 이 프린트 안에 만나면 이 세
개를 자동으로 콤마는 띄어쓰기라고 인식을 합니다

4760
05:10:11,160 --> 05:10:14,560
그래서 띄어쓰기를 해서 이렇게 출력을 해줍니다

4761
05:10:15,100 --> 05:10:16,277
그래서 콤마는 띄어쓰기 라고 인식을 합니다

4762
05:10:16,301 --> 05:10:16,277
그래서 띄어쓰기를 해서 이렇게 출력을 해줍니다

4763
05:10:16,301 --> 05:10:21,620
영어로 연결된 이런 스트링이 들어온다면
프린트는 이렇게 띄어쓰기를 해서 출력을 해줍니다

4764
05:10:22,560 --> 05:10:25,020
그래서 이게 프린트의 기능 중에 하나입니다

4765
05:10:25,800 --> 05:10:27,380
한 줄의 결과값 출력하기

4766
05:10:27,480 --> 05:10:35,480
이거는 구구단 예제 때 잠깐 나왔는데 좀 더 설명을 해드리자면
원래 기본적으로 프린트는 한 칸씩 띄워서 한 줄을 차지합니다

4767
05:10:36,520 --> 05:10:38,480
즉, 여기 뒤에 and 이거 없애볼게요

4768
05:10:38,640 --> 05:10:46,640
없애보고 그냥 출력을 해보면 이런 식으로 출력값이 0, 한 칸 내리고
1, 한 칸 내리고 2, 한 칸 내리고 3, 이런 식으로 쭉쭉 나오게 됩니다

4769
05:10:48,180 --> 05:10:56,180
근데 여기에 프린트 함수에 첫 번째 파라미터 i를
넣고 두 번째로는 and는 하고 공백을 지정해줬죠

4770
05:10:56,400 --> 05:11:01,120
그 함수에서 그 파라미터에
지정해서 값 넣는 거 그때 배웠었죠

4771
05:11:01,160 --> 05:11:02,280
함수 단원에서

4772
05:11:02,660 --> 05:11:05,840
그래서 이거에 빈 공백을 and라는 거에 넣어줬습니다

4773
05:11:06,220 --> 05:11:13,620
그래서 이렇게 프린트 함수를 수행하게 되면 그러면 원래
기본 and값이 한 칸 내리는 게 기본으로 되어 있었습니다

4774
05:11:13,980 --> 05:11:21,980
그래서 이거를 수행해보면 완전히 동일하게 나오는데 이거 대신에 공백을
넣게 되면 한 칸 내리는 것 대신에 이렇게 공백을 통해서 연결을 하게 됩니다

4775
05:11:24,960 --> 05:11:32,960
그래서 프린트의 기능 중에 and라는 파라미터를
쓰면 그거는 이렇게 쭉 연결하는 이 뒤에, 그러니까 이

4776
05:11:33,481 --> 05:11:40,200
슬래시 n, 백 슬래시 n 대신 즉 한 칸 내리는 것
대신에 이렇게 이걸로 바꿔치기 하겠다가 됩니다

4777
05:11:40,500 --> 05:11:46,740
그래서 여기에 그때도 보여드렸는데 to the 이런
거 넣으면은 0 to the, 1 to the, 2 to the 이렇게 되죠

4778
05:11:46,780 --> 05:11:54,780
왜냐하면 하나가 출력되고 나서 그 끝에 뭘 추가하겠다니까
여기에 이 and라는 기능을 통해서 뭔가 다른 처리를 해줄 수가 있습니다

4779
05:11:55,460 --> 05:11:59,660
여기 나온 것처럼 and의 매개변수의 초기값은 줄바꿈입니다

4780
05:11:59,860 --> 05:12:02,240
이 초기값 지정하는 것도 아까 배웠었죠

4781
05:12:02,320 --> 05:12:03,740
그 매는 true 그거 있죠

4782
05:12:04,020 --> 05:12:09,120
그것처럼 and는 줄바꿈이라고
아예 초기값이 지정이 돼 있습니다

4783
05:12:09,440 --> 05:12:11,620
근데 그거를 강제로 바꿔주는 거죠

4784
05:12:11,760 --> 05:12:15,020
그러면 이렇게 해서 이까지 배워봤습니다

4785
05:12:15,350 --> 05:12:19,240
그 다음에 4-3 파일 읽고 쓰기를 나가보도록 하겠습니다

4786
05:12:19,500 --> 05:12:24,220
그럼 파일 생성하기 이 파일
생성하고 뭐 그런 경우가 되게 많아요

4787
05:12:24,300 --> 05:12:25,780
그래서 은근히 많이 쓰입니다

4788
05:12:25,840 --> 05:12:33,840
이것도 그래서 파이썬을 이용해서 어떤 파일을 만들고 거기에 어떤
값을 입력하고 이런 경우가 종종 있는데 그거를 해보도록 하겠습니다

4789
05:12:34,440 --> 05:12:35,980
네, 이 함수를 한번 실행해볼게요

4790
05:12:36,100 --> 05:12:40,020
실행을 해보면 갑자기 이렇게 새 파일이라는 게 생겼습니다

4791
05:12:40,140 --> 05:12:48,140
파이썬 코드 중에 오픈하고 새 파일을 만들어서 W라는 모드로
실행을 해서 얘를 만들어주고 클로즈를 했기 때문에 생겼습니다

4792
05:12:48,660 --> 05:12:52,020
그래서 이거를 활용하는 방법을 하나씩 배워보도록 하겠습니다

4793
05:12:52,300 --> 05:12:56,360
그래서 파일 객체를 만들어주려면
오픈이라는 함수를 쓰면 됩니다

4794
05:12:56,620 --> 05:13:01,520
그래서 오픈에 파라미터가 이렇게 두 개가
들어가는데 그거를 배워보도록 하겠습니다

4795
05:13:01,800 --> 05:13:04,720
그래서 파일 열기 모드는 W로 열었잖아요, W

4796
05:13:04,980 --> 05:13:10,587
그래서 이게 Write 모드, 쓰기 모드여서
이렇게 아까 파일이 생성된 거고 R모드는

4797
05:13:10,611 --> 05:13:15,160
읽기 모드로 파일을 읽을 때 쓰고 A모드는
추가 모드로 내용을 추가할 때 씁니다

4798
05:13:15,200 --> 05:13:17,820
이거를 각각 하나씩 실습을 해보도록 하겠습니다

4799
05:13:18,080 --> 05:13:23,240
지금은 아무것도 경로를 지정
안 해줘서 상대 경로라고 하거든요

4800
05:13:23,580 --> 05:13:29,920
그 경로를 파일 이름만 쓰게 되면 그 스크립트를
실행한 위치에 그 위치에 생성을 해주게 됩니다

4801
05:13:30,140 --> 05:13:35,800
이 새 파일이 지금 우리가 스크립트를
실행한 위치가 C에 파이썬에서 실행을 했죠

4802
05:13:35,860 --> 05:13:43,260
C에 파이썬에서 실행을 했기 때문에 이렇게 오픈 새 파일하고
새 파일을 생성하면 지금 C에 파이썬 안쪽에 생기게 됩니다

4803
05:13:43,680 --> 05:13:46,200
여기서 실행하면 새 파일이 여기에 생기게 됩니다

4804
05:13:46,340 --> 05:13:48,160
이렇게 지정을 해줄 수도 있어요

4805
05:13:48,320 --> 05:13:54,960
어떤 폴더에 어떻게 생겨라 라고 한다면
예를 들어서 여기에 이렇게도 해보겠습니다

4806
05:13:55,280 --> 05:13:56,820
이 do it이라는 폴더를 만들었어요.

4807
05:13:57,040 --> 05:13:58,560
Do it 안에는 지금 아무것도 없죠

4808
05:13:58,640 --> 05:14:06,640
근데 이 새 파일 그냥 생성하는 게 아니라 경로를
지정해서 do it이라고 입력하고 여기에 새 파일을 만들어주겠다

4809
05:14:07,760 --> 05:14:09,700
이렇게 하면 실행을 해볼게요

4810
05:14:09,860 --> 05:14:12,180
여기 do it 안에 새 파일이 지금 생겼습니다

4811
05:14:12,240 --> 05:14:12,380
새로

4812
05:14:12,500 --> 05:14:12,857
이렇게

4813
05:14:12,881 --> 05:14:15,420
이렇게 특정 경로를 지정해서 할 수도 있습니다

4814
05:14:15,600 --> 05:14:20,880
이 함수를 실행하는 경로를 기준으로
거기서 이렇게 상대적으로 찾아갈 수도 있고요

4815
05:14:21,040 --> 05:14:25,640
아니면 여기 예시로 나온 것처럼
아예 C 드라이브가 가장 근본이죠

4816
05:14:25,780 --> 05:14:31,081
그러니까 가장 바닥부터 C 드라이브에
do it이라는 폴더에 만들고 싶다라고

4817
05:14:31,105 --> 05:14:35,700
한다면 이렇게 절대 경로라고 하는데
이렇게 바닥부터 올라와서 쓸 수도 있습니다

4818
05:14:36,160 --> 05:14:42,082
그래서 이렇게 쓰는 절대 경로로도 써줄 수
있고 아니면 이 스크립트를 실행하는 위치인

4819
05:14:42,106 --> 05:14:47,660
여기에서 파이 C에 파이썬에서 어디로 갈지를
이렇게 상대 경로로도 적어줄 수가 있습니다

4820
05:14:47,800 --> 05:14:55,800
이렇게 해줄 수 있고 파일 경로는 이제 슬래시를 쓸 수도 있고 그
백 슬래시를 쓸 수도 있는데 이렇게 두 개를 써주면 된다고 합니다

4821
05:14:57,700 --> 05:15:00,880
그래서 이거 경로로 표시는 슬래시를 써주시면 됩니다

4822
05:15:01,240 --> 05:15:03,440
이번에는 절대 경로로 한번 생성을 해볼게요

4823
05:15:03,600 --> 05:15:07,320
그럼 C에 do it에 새 파일인데
이거를 실행하면 지금은 안 될 거예요

4824
05:15:07,440 --> 05:15:07,700
왜냐?

4825
05:15:07,920 --> 05:15:11,497
그 C에 do it에 새 파일을
지금 만들 수가 없기 때문이죠

4826
05:15:11,521 --> 05:15:12,580
폴더 자체가 없으니까

4827
05:15:13,360 --> 05:15:14,800
그래서 만들어주겠습니다

4828
05:15:15,680 --> 05:15:22,440
이 윈도우로 들어와서 내 컴퓨터에 C로
들어와서 여기에 do it이라는 폴더를 만들어줬어요

4829
05:15:22,520 --> 05:15:24,080
여기 C에 do it이라는 게 생겼죠?

4830
05:15:24,140 --> 05:15:27,840
그리고 이거를 실행하게 되면 이제는 실행이 됩니다

4831
05:15:28,140 --> 05:15:28,880
왜냐?

4832
05:15:28,940 --> 05:15:31,000
C에 do it이라는 폴더가 있기 때문이죠

4833
05:15:31,180 --> 05:15:34,860
그래서 C에 do it 안에 이렇게
새 파일이 생기게 됐습니다

4834
05:15:35,560 --> 05:15:38,640
그러면 이거를 실행했더니 지금 새 파일이 생겼습니다

4835
05:15:38,780 --> 05:15:40,620
그래서 이 새 파일을 열어보면...

4836
05:15:41,520 --> 05:15:42,436
이렇게 나옵니다

4837
05:15:42,460 --> 05:15:50,460
새 파일이 지금 이렇게 C에 do it에 새 파일이라서 여기에 지금
이 구문이 수행되고 이게 이렇게 들어가서 이렇게 출력이 됐습니다

4838
05:15:52,600 --> 05:15:57,740
그래서 이게 어떻게 출력됐는지를 좀 생각을
해보면 반복문, 지난 시간에 배운 개념이죠

4839
05:15:57,940 --> 05:16:02,300
그래서 1에서 10일 미만이니까 1에서 10까지죠

4840
05:16:02,940 --> 05:16:10,771
1에서 10까지 동안 이 데이터를 먼저 몇 번째 줄입니다를
만들고 그 데이터를 f.write라는 화면을 만들고 이 데이터를 f.

4841
05:16:10,795 --> 05:16:13,060
Write라는 함수를 이용해서 써줬습니다

4842
05:16:13,160 --> 05:16:20,396
이 f.write를 통해서 이 파일을 열었는데 이
파일 안에 이렇게 한 줄씩, 한 줄씩, 한 줄씩

4843
05:16:20,420 --> 05:16:26,680
작성을 해서 이게 열 번째 줄임자까지 작성하고
f .close를 통해서 이거를 만들어 준 거겠죠

4844
05:16:26,820 --> 05:16:31,240
그래서 이렇게 파일의 어떤 값을
쓸 때 이런 식으로 사용하게 됩니다

4845
05:16:31,720 --> 05:16:39,380
그래서 이렇게 비교해보면 이거는 반복문을
아신다면 사실 어렵지 않게 f .write으로 쓸 수가 있다

4846
05:16:39,460 --> 05:16:41,420
라는 거를 이해해 보실 수가 있겠습니다

4847
05:16:41,520 --> 05:16:44,520
이제 명령 프롬프트 창의 첫 번째 예제를 실행해보자

4848
05:16:44,620 --> 05:16:47,560
그래서 이거 실행해서 이것까지 확인을 해봤죠

4849
05:16:47,640 --> 05:16:49,860
이 내용을 한번 수행을 해봤습니다

4850
05:16:50,280 --> 05:16:51,660
근데 이런 경우도 있어요

4851
05:16:51,800 --> 05:16:55,100
이렇게 해서 그냥 이렇게 새 파일을 써볼게요

4852
05:16:55,360 --> 05:16:57,140
상대 경로니까 여기에 써졌겠죠

4853
05:16:57,320 --> 05:16:59,860
이걸 열어보면 이런 식으로 깨질 때가 있습니다

4854
05:17:00,280 --> 05:17:01,280
이걸 실행해봤어요

4855
05:17:01,320 --> 05:17:07,860
이걸 실행했는데 새 파일을 그럼 생성된 걸 열어보니까
이렇게 뭐 숫자는 살아있는데 막 문자는 막 깨져 있어요

4856
05:17:08,490 --> 05:17:09,877
이런 경우는 어떤 경우냐

4857
05:17:09,901 --> 05:17:11,580
인코딩이 깨진 겁니다

4858
05:17:11,780 --> 05:17:19,780
그래서 여기에 한글 인코딩이라고 문자를 표현할 때
컴퓨터는 원래 바이너리니까 0101010 이렇게 돼 있잖아요

4859
05:17:20,760 --> 05:17:26,280
그런데 그거를 안 깨진 문자 한글이 안
깨지게 하려면 사실 인코딩을 추가해야 됩니다

4860
05:17:26,740 --> 05:17:33,170
그래서 이 세 번째 파라미터 중에 인코딩이라는
파라미터에 지정을 해서 어떤 걸 넣어줘야

4861
05:17:33,194 --> 05:17:39,000
되는데 utf-8이라는 걸 넣어주면 utf-8이라는
인코딩을 쓰면 한글이 안 깨지게 됩니다

4862
05:17:39,180 --> 05:17:39,797
그래서 이렇게

4863
05:17:39,821 --> 05:17:46,480
이렇게 다시 한 번 실행을 해보면 이제는 새 파일을
열었을 때 잘 안 깨지고 한글이 나온 것을 확인할 수가 있습니다

4864
05:17:46,660 --> 05:17:49,500
그래서 이렇게 인코딩을 정해줘야 되는 경우도 있습니다

4865
05:17:49,780 --> 05:17:52,460
그래서 이렇게 파일 쓰는 것을 배워봤습니다

4866
05:17:52,760 --> 05:17:56,020
그래서 이제 파일 쓰기에 대해서 한 번 실습을 해봤고요

4867
05:17:56,140 --> 05:17:59,520
그다음에 파일을 읽는 여러 가지
방법들을 알아보도록 하겠습니다

4868
05:17:59,740 --> 05:18:00,500
파일 읽는 방법

4869
05:18:00,680 --> 05:18:04,360
아까 C두잇의 새 파일은 생성해
놨으니까 이걸 그대로 활용해 보겠습니다

4870
05:18:04,660 --> 05:18:07,960
그러면 이제 두 번째 인자로 R모드를 사용해 봤어요

4871
05:18:08,020 --> 05:18:09,237
아까까지는 W모드

4872
05:18:09,261 --> 05:18:13,960
즉, Write모드를 사용했는데
지금은 이제 Read모드죠, Read모드.

4873
05:18:14,100 --> 05:18:22,000
Read모드로 해서 오픈을 해서 파일 객체를 만들면
얘는 f .readline이라는 함수를 사용할 수가 있습니다

4874
05:18:22,240 --> 05:18:24,740
그래서 Read라인을 사용하게 되면 어떻게 되냐

4875
05:18:24,800 --> 05:18:27,460
실행을 해보면 1번째 줄입니다가 출력이 됩니다

4876
05:18:27,820 --> 05:18:34,840
그 Read라인을 통해서 나온 것은 첫 번째 줄을
가져와서 이걸 라인에 담아주고 그걸 출력을 해 준 거겠죠.

4877
05:18:35,060 --> 05:18:39,217
F는 파일의 약자로 아마 F로
썼을 건데 이건 당연히 변수입니다

4878
05:18:39,241 --> 05:18:40,880
이건 변수기 때문에 아무거나 써도 됩니다

4879
05:18:41,000 --> 05:18:42,200
조코딩 이렇게 써도 됩니다

4880
05:18:42,340 --> 05:18:45,580
이건 변수기 때문에 그냥 변수에 담아준 것일 뿐입니다

4881
05:18:45,740 --> 05:18:47,480
이렇게 해도 다 당연히 됩니다

4882
05:18:47,700 --> 05:18:49,520
파일을 줄여서 F라고 쓴 겁니다

4883
05:18:49,720 --> 05:18:52,120
그래서 Read라인 함수를 이용해서 해 봤고요

4884
05:18:52,220 --> 05:18:57,620
그다음에 Read라인이 한 줄을 읽는 거라면
여러 줄을 읽고 싶을 때 어떻게 해야 되냐

4885
05:18:57,680 --> 05:18:58,720
이렇게 할 수가 있겠습니다

4886
05:18:59,160 --> 05:19:03,477
여러 줄을 읽고 싶다면 while
true 반복문 배운 거 기억나시나요?

4887
05:19:03,501 --> 05:19:09,580
반복문을 통해서 계속 반복하면서 read라인을 해줄
때마다 다음 줄, 다음 줄, 다음 줄을 읽어 나가게 됩니다

4888
05:19:09,760 --> 05:19:17,760
그래서 f.readline을 통해서 한 줄씩 읽고 그거를 라인에 저장한
다음에 if not line이라는 거는 이 라인이 어떤 스트링이 들어간다고

4889
05:19:19,161 --> 05:19:24,820
하면 아무것도 안 들어갔을 때 force가 되면서
이거 패션 코딩이 여기 들어갔는데 이렇게 되는 거죠

4890
05:19:24,960 --> 05:19:27,180
그러니까 break를 만나서 빠져나오게 됩니다

4891
05:19:27,440 --> 05:19:33,217
이걸 다시 실행해보면 이렇게 하고 종료가 되는데
이해가 안 되신다면 디버깅을 해보면 좋을 것 같습니다

4892
05:19:33,241 --> 05:19:33,520
네

4893
05:19:33,580 --> 05:19:36,860
이거를 한 줄씩 수행해 보면
while's true니까 무한반복이 되죠?

4894
05:19:37,160 --> 05:19:40,520
Readline을 해서 line에 첫
번째 줄입니다가 담깁니다

4895
05:19:40,620 --> 05:19:48,420
그래서 첫 번째 줄입니다가 담겼는데 not line이라는
거는 얘가 문자열이기 때문에 not을 하면 false가 됩니다

4896
05:19:48,680 --> 05:19:49,180
왜냐?

4897
05:19:49,240 --> 05:19:52,100
지난 시간에 배운 개념인 문자 이거 있죠

4898
05:19:52,680 --> 05:19:53,980
자료형의 참과 거짓

4899
05:19:54,120 --> 05:19:55,120
기억나시나요?

4900
05:19:55,500 --> 05:19:58,580
문자열이면 참이고, 없으면 거짓이고

4901
05:19:58,760 --> 05:19:58,940
네

4902
05:19:59,420 --> 05:20:01,760
문자열이라도 속성이 있다고 말씀드렸죠

4903
05:20:02,100 --> 05:20:02,717
라인은

4904
05:20:02,741 --> 05:20:06,420
첫문장은 문자열이기 때문에
이것의 반대는 false가 됩니다

4905
05:20:06,580 --> 05:20:06,860
왜냐?

4906
05:20:06,900 --> 05:20:08,840
문자열이 true니까 not은 반대죠

4907
05:20:08,960 --> 05:20:11,820
그래서 1번째 줄입니다는 이걸 통과해버립니다

4908
05:20:11,940 --> 05:20:13,080
If 안으로 못 들어가요

4909
05:20:13,120 --> 05:20:19,752
그리고 쭉 프린트를 해주고 첫번째 줄입니다가
나오고 두번째로 읽고 또 두번째 줄입니다가

4910
05:20:19,776 --> 05:20:25,080
나오고 또 세번째 읽고 세번째 쭉쭉쭉
나오다가 마지막 줄에는 빈 문자열이 담깁니다

4911
05:20:25,200 --> 05:20:27,180
Read line을 했더니 다음에 없어요

4912
05:20:27,420 --> 05:20:33,740
그냥 그 다음 문장이 없기 때문에 빈 문자열이
나와서 빈 문자열이 담기게 되고 그렇다면

4913
05:20:33,764 --> 05:20:38,321
빈 문자열은 원래는 false인데
false가 not을 만나니까 true가 되죠

4914
05:20:38,360 --> 05:20:41,320
그래서 break를 만나서 얘를 빠져나옵니다

4915
05:20:41,660 --> 05:20:46,240
그리고 f.close로 닫아주기
때문에 이렇게 읽을 수가 있겠습니다

4916
05:20:46,960 --> 05:20:48,760
그래서 중간에 빈 줄이 있으면 끊깁니다

4917
05:20:48,900 --> 05:20:54,320
근데 여기서 약간 특이한 점은 지금 몇
번째 줄입니다 하고 한 줄 더 띄워져 있죠?

4918
05:20:54,440 --> 05:21:00,657
그 c에 저장된 이 세 파일 열어보면
알고 보면 한 칸씩 지금 떨어져 있잖아요?

4919
05:21:00,681 --> 05:21:03,200
맨 뒤에 줄바꿈 문자 이거 있죠?

4920
05:21:03,300 --> 05:21:06,880
Backslash n 이게 우리 눈에는 안
보이지만 여기 들어가 있는 겁니다

4921
05:21:07,040 --> 05:21:14,740
우리는 메모장으로 열었기 때문에 안 보이지만 사실 줄바꿈 문자가
들어가 있기 때문에 이렇게 다음 줄 다음 줄 다음 줄 넘어가게 되는 거죠

4922
05:21:14,860 --> 05:21:16,580
그래서 이것까지도 불러옵니다

4923
05:21:16,660 --> 05:21:21,820
지금 우리가 여기 프린트를 해주면 이 라인
안에는 줄바꿈 문자까지도 들어가 있습니다

4924
05:21:22,060 --> 05:21:26,080
네, 여기 다시 한번 정확하게 보면
여기 줄바꿈 문자도 들어가 있죠?

4925
05:21:26,200 --> 05:21:29,917
그렇기 때문에 아까 한 줄 출력되고
한 칸이 더 내려가버린 겁니다

4926
05:21:29,941 --> 05:21:33,576
그래서 프린트도 원래 한 칸 띄워주는데
이것 때문에 한 칸이 더 띄워집니다

4927
05:21:33,600 --> 05:21:35,660
그래서 이거를 한번 살펴봤습니다

4928
05:21:35,780 --> 05:21:40,000
그래서 그 줄바꿈 문자 때문에 한
칸 더 띄워진다 까지도 알아봤고요

4929
05:21:40,060 --> 05:21:43,700
이거는 뭐 간단한 예제 인풋 받는 거 아까 배웠었죠?

4930
05:21:43,740 --> 05:21:47,000
데이터가 있으면 브레이크 이거는 패션코딩이죠

4931
05:21:47,100 --> 05:21:48,100
이렇게 이거랑 같죠?

4932
05:21:48,260 --> 05:21:51,400
데이터가 있으면 계속 1을 넣으면 1이 나오죠

4933
05:21:51,440 --> 05:21:57,680
왜냐하면 true인데 not을 만나니까 false가 돼서
여기 안 들어가는데 아무것도 입력을 안 하면 종료가 되죠

4934
05:21:57,720 --> 05:21:58,057
왜냐?

4935
05:21:58,081 --> 05:22:04,380
입력 없는 거는 빈 문자열이라 false인데 not을
만나서 true가 돼서 브레이크가 되기 때문에 빠져나갑니다

4936
05:22:04,420 --> 05:22:11,420
그럼 if not line break 대신에 if not line
continue 근데 continue는 반복문 처음으로 돌아가는 거잖아요

4937
05:22:11,520 --> 05:22:13,980
그러면은 다시 계속 무한 반복이 될 수가 있겠죠

4938
05:22:14,120 --> 05:22:16,940
그래서 브레이크로 해야 빠져나갈 수가 있겠죠

4939
05:22:17,120 --> 05:22:18,040
그 반복문을

4940
05:22:18,100 --> 05:22:21,160
0도 false라고 했는데 0을 입력하면 빠져나오나요?

4941
05:22:21,280 --> 05:22:21,780
어 맞습니다

4942
05:22:21,900 --> 05:22:23,720
0도 입력하면 빠져나옵니다

4943
05:22:23,760 --> 05:22:25,420
0을 입력하면 아 그게 있죠

4944
05:22:25,540 --> 05:22:33,460
0도 숫자 0이면 빠져나오는데 string이 있기 때문에 이게 좀
헷갈릴 수 있는 부분이 input이 아까 string으로 받는다고 했잖아요

4945
05:22:33,600 --> 05:22:35,400
데이터를 해보면 네 string입니다

4946
05:22:35,560 --> 05:22:36,740
그래서 이겁니다

4947
05:22:36,820 --> 05:22:38,180
사실 이게 들어가 있는 거예요

4948
05:22:38,300 --> 05:22:39,196
이 문자열 0이

4949
05:22:39,220 --> 05:22:47,220
그거를 원래대로 하고 싶다 하면은 데이터는 int로 바꿔서 데이터로
하게 되면 integer로 변환해서 담으면은 그 예상대로 동작을 하겠죠

4950
05:22:47,720 --> 05:22:49,780
그래서 실행을 해보면 0을 넣으면 종료가 됩니다

4951
05:22:49,980 --> 05:22:50,320
왜냐?

4952
05:22:50,420 --> 05:22:52,040
0은 false기 때문이죠

4953
05:22:52,180 --> 05:22:55,480
네 그래서 숫자형 문자형 이런 자료형이 되게 중요합니다

4954
05:22:55,620 --> 05:22:57,080
그래서 여기까지 배워봤고요

4955
05:22:58,080 --> 05:23:04,920
일단은 readline으로 한 줄 한 줄씩 반복문을 통해서 읽는
걸 배워봤는데 이번에는 readlines라는 함수도 있습니다.

4956
05:23:05,060 --> 05:23:05,780
S가 붙었죠

4957
05:23:05,860 --> 05:23:06,880
이건 어떤 함수냐

4958
05:23:06,940 --> 05:23:13,960
이번에는 readlines는 lines라는 변수 안에
여기 있는 파일들을 다 모아서 담아줍니다

4959
05:23:14,140 --> 05:23:18,060
이걸 또 디버깅으로 보면은
readlines라면 lines에 뭐가 담기냐

4960
05:23:18,160 --> 05:23:20,140
리스트의 형태로 이렇게 담깁니다

4961
05:23:20,260 --> 05:23:21,260
1번째 줄입니다

4962
05:23:21,400 --> 05:23:22,320
2번째 줄입니다

4963
05:23:22,420 --> 05:23:25,240
줄바꿈까지 포함해서 이렇게 쭉 담기게 됩니다

4964
05:23:25,440 --> 05:23:33,440
그래서 readlines라는 함수는 여기 있는 텍스트 파일들의
각각의 줄을 다 쪼개서 리스트에 담아서 그거를 뱉어주게 됩니다

4965
05:23:35,540 --> 05:23:37,080
즉 리턴을 해주게 됩니다

4966
05:23:37,280 --> 05:23:40,180
그러면 이 lines는 리스트가 들어가겠죠

4967
05:23:40,300 --> 05:23:48,097
그래서 리스트가 들어갔기 때문에 이거를 한 줄씩 실행해주면 line을
for문이니까 lines 중에 하나씩 뽑아와서 line을 뽑아서 출력을

4968
05:23:48,121 --> 05:23:54,300
해주는 그런 구조이기 때문에 이렇게 각각
몇 번째 줄이다가 하나씩 뽑혀서 나오게 되겠죠

4969
05:23:54,440 --> 05:23:55,797
이렇게 쓸 수가 있겠습니다

4970
05:23:55,821 --> 05:23:58,900
그래서 readlines 함수에 대해서도 배워봤습니다

4971
05:23:58,960 --> 05:24:01,960
그래서 이 줄바꿈 문자가 약간 거슬릴 수 있잖아요

4972
05:24:02,160 --> 05:24:09,040
계속 한 칸 떨어져 있는 건 알겠는데 출력해보니까 계속
지저분하게 한 칸씩 띄워지니까 이걸 없애려면 어떻게 해야 되냐

4973
05:24:09,100 --> 05:24:09,820
이렇게 하면 됩니다

4974
05:24:10,080 --> 05:24:16,920
줄바꿈 문자를 제거하려면 2장 자료형 할 때 저희 배웠었는데
strip 함수를 통해서 문자를 제거를 해줄 수가 있습니다.

4975
05:24:17,140 --> 05:24:21,160
Strip 함수를 쓰면 줄 끝에
줄바꿈 문자를 제거를 해줍니다

4976
05:24:21,340 --> 05:24:26,200
그래서 이거를 실행해보면 이번엔
따닥따닥 붙여서 나오는 것을 볼 수가 있죠

4977
05:24:27,000 --> 05:24:28,000
Replace도 됩니다

4978
05:24:28,140 --> 05:24:31,820
굉장히 복습을 열심히 하고 계신
것 같은데 동일하게 이렇게 됩니다

4979
05:24:32,020 --> 05:24:37,760
그래서 strip을 써도 되고 아니면 replace로
아예 줄바꿈 문자를 빈 문자열로 바꿔주면 되겠죠

4980
05:24:37,880 --> 05:24:39,900
그래서 이렇게 활용을 해볼 수가 있겠습니다

4981
05:24:40,140 --> 05:24:47,760
그 다음에 readlines를 했으면 read라는 함수도 쓸
수 있는데 read는 아예 통채로 다 가져오는 겁니다

4982
05:24:48,200 --> 05:24:49,397
그래서 이거를 출력을 해보겠습니다

4983
05:24:49,421 --> 05:24:57,180
Read를 하게 되면 이거 파일 자체를 통채로 가져와서
데이터에 넣고 출력을 해보면 이렇게 통채로 다 나오게 됩니다

4984
05:24:57,340 --> 05:25:00,640
그 다음에 이제 파일 객체를
for문과 함께 사용할 수도 있습니다

4985
05:25:01,040 --> 05:25:08,827
아예 그냥 readline read 이런거 안쓰고 for문
자체적으로 어떤 파일을 열어서 이거를 담으면

4986
05:25:08,851 --> 05:25:15,280
이 f 자체를 그 하나의 리스트처럼 생각해서
for문 안에 있으면 한 줄씩 뽑아올 수가 있습니다

4987
05:25:15,480 --> 05:25:21,062
그래서 readlines를 마치 한 것처럼
그 아예 파일 객체 안에서도 이렇게

4988
05:25:21,086 --> 05:25:25,580
한 줄씩 한 줄씩 기본적으로 뽑아올
수 있게 파이썬이 설계가 되어 있습니다

4989
05:25:25,740 --> 05:25:33,380
그래서 이거를 실행해 보면 마치 readlines를 쓴 것처럼
이렇게 똑같이 이렇게 모든 줄이 다 출력이 되게 됩니다

4990
05:25:33,620 --> 05:25:36,780
그래서 이렇게 쓸 수도 있다 라고 소개를 드립니다

4991
05:25:37,300 --> 05:25:40,020
파일에 새로운 내용 추가하기도 보도록 하겠습니다

4992
05:25:40,340 --> 05:25:45,340
지금까지 읽는 모드, w모드, 쓰기
모드는 해봤는데 a모드는 안 써봤죠.

4993
05:25:45,620 --> 05:25:51,220
A모드가 추가 모드라고 해서 w모드를 쓰게 되면
기존의 파일이 있으면 그걸 아예 덮어 써버립니다

4994
05:25:51,360 --> 05:25:56,220
그래서 기존에 있던 것을 유지하면서
추가를 하려면 a모드를 쓰면 됩니다

4995
05:25:56,440 --> 05:25:57,460
크게 다르지 않습니다

4996
05:25:57,600 --> 05:25:59,960
뒤에 a모드를 적어주면 됩니다

4997
05:26:00,440 --> 05:26:01,700
그래서 이거를 보도록 하겠습니다

4998
05:26:02,340 --> 05:26:03,980
네 지금 이 파일이 있죠

4999
05:26:04,080 --> 05:26:12,080
뒤에 파일이 있기 때문에 a모드를 이용하면 이 파일을
불러와서 그 뒤에 그러니까 마지막 뒤쪽으로 append를 해줍니다

5000
05:26:12,360 --> 05:26:16,837
여기 11부터 20이라면 11부터 19까지가 포함이 되겠죠

5001
05:26:16,861 --> 05:26:21,100
11번째 줄입니다부터 19번째
줄입니다까지 들어갈 수 있겠죠

5002
05:26:21,220 --> 05:26:23,740
그래서 얘를 출력해주면 네 실행이 됐구요

5003
05:26:23,840 --> 05:26:31,840
그 파일을 열어보시면 이렇게 10번째 줄 아래로 11번째부터
19번째까지 이렇게 추가가 된 것을 확인할 수 있습니다

5004
05:26:32,300 --> 05:26:34,200
그래서 이게 w모드면 어떻게 될까요?

5005
05:26:34,710 --> 05:26:38,460
W모드로 실행하면은 어떻게 되냐 덮어 써집니다

5006
05:26:38,560 --> 05:26:43,600
그래서 11번째부터 19번째 만
남아서 그러면 이게 망가지겠죠

5007
05:26:43,760 --> 05:26:49,596
그래서 a모드를 쓰는 이유는 덧붙이기
위해서 이렇게 하면 여기에 덧붙여집니다

5008
05:26:49,620 --> 05:26:50,176
기존꺼에

5009
05:26:50,200 --> 05:26:52,120
그래서 기존꺼를 보존할 수가 있겠죠

5010
05:26:52,570 --> 05:26:54,120
그래서 이렇게 추가가 됐죠

5011
05:26:54,160 --> 05:27:02,160
이것도 그 다음에 이제 with문 with문도 있는데 이거는 이제 변수의
범위 그 지역변수 전역변수를 이해하셨으면 이것도 이해가 좋습니다

5012
05:27:03,700 --> 05:27:08,340
그 지금까지 살펴본 예제들은 항상 f.close를 해줬어요

5013
05:27:08,420 --> 05:27:14,260
이게 왜 그러냐면 open을 통해서 문서를
하나 열었으면 이거를 닫아줘야 됩니다

5014
05:27:14,960 --> 05:27:21,620
왜 그러면 예를 들어 open을 통해서 하나 열었는데 같은
거를 또 열어주고 막 또 열어주고 하면은 이게 꼬이고 안되겠죠

5015
05:27:21,700 --> 05:27:22,520
오류가 날 수 있겠죠

5016
05:27:22,700 --> 05:27:26,640
그래서 한번 열은 문서는 다
쓰고 close를 해줘야 됩니다

5017
05:27:26,840 --> 05:27:33,740
그래서 close를 해주는 게 기본인데 프로그램이 종료가 되면 당연히
자연스럽게 close는 되는데 이거를 자동으로 처리할 수 있는 것도 있습니다

5018
05:27:34,080 --> 05:27:35,780
네 with라는 구문이 있는데요

5019
05:27:35,960 --> 05:27:42,937
어떤 open을 한 다음에 as 뭘로 써서 이
open한 그 결과를 여기에 담을 수가 있습니다.

5020
05:27:42,961 --> 05:27:44,880
Open이 아니더라도 다른 걸 써도 돼요

5021
05:27:44,940 --> 05:27:52,940
그래서 with하고 어떤 걸 수행한 다음에 나온 결과를 f에 저장해주는데
이 with구문은 이 들여쓰기 안쪽 여기에서만 사용되는 지역 변수입니다

5022
05:27:55,160 --> 05:28:02,650
어떤 걸 open해서 그거를 f에 저장한 다음에
그 저장한 거를 이 with구문 안쪽 이 들여쓰기

5023
05:28:02,674 --> 05:28:09,480
안쪽에서만 쓰고 이게 끝나면은 이제 f를
없애버리고 싶을 때 f.close 그냥 자동으로 해줍니다

5024
05:28:09,580 --> 05:28:11,440
종료가 돼서 f가 없어지기 때문이죠

5025
05:28:11,540 --> 05:28:15,900
그래서 이 뒤로 막 프로그램이 있다고
하면 이때부터는 f를 쓸 수가 없습니다

5026
05:28:16,100 --> 05:28:18,040
이 안쪽 에서 쓰이기 때문이죠

5027
05:28:18,140 --> 05:28:22,080
그래서 with구문을 쓴다라고
하면은 지역 변수로 만드는 겁니다.

5028
05:28:22,160 --> 05:28:22,460
F를

5029
05:28:22,560 --> 05:28:24,660
그래서 이게 종료되면 없어질 수 있도록

5030
05:28:24,780 --> 05:28:28,320
네 그럼 이렇게 해서 파일 읽고 쓰기까지 배워봤습니다

5031
05:28:28,480 --> 05:28:31,180
네 프로그램의 입력과 출력을 진행해보도록 하겠습니다

5032
05:28:31,400 --> 05:28:38,440
이 명령어 프롬프트 아마 그냥 일반적으로는 거의 활용을 안
해보셨을 텐데 프로그래밍 할 때는 가끔 활용할 일이 좀 있습니다

5033
05:28:38,780 --> 05:28:40,140
명령어 프롬프트를 이용해서

5034
05:28:40,240 --> 05:28:44,640
그러면은 뭐 이런 파이썬도 이런
거 실행해보신 적 있으시잖아요

5035
05:28:44,680 --> 05:28:51,200
파이썬 hello. Py 이런 거 수행했을 때 이게
이제 명령어 고 뒤에 이걸 파라미터라고 부릅니다

5036
05:28:51,300 --> 05:28:58,980
그래서 막 뭐 마이너스 a니 뭐 노드 gs에서도
막 뭐 i니 이런 키워드들을 쭉 써서 이렇게

5037
05:28:59,004 --> 05:29:04,421
터미널 안에 입력하는 경우가 있는데 요런
거를 다루는 방법을 좀 배워보도록 하겠습니다

5038
05:29:04,600 --> 05:29:09,800
그러면 이렇게 명령어 아까 파이썬 명령도
파이썬하고 인수들이 쭉쭉 들어간 거예요

5039
05:29:09,960 --> 05:29:12,080
그래서 여기 이게 arguments들인 거죠

5040
05:29:12,180 --> 05:29:15,020
그래서 이거를 활용하는 방법을 배워보도록 하겠습니다

5041
05:29:15,620 --> 05:29:17,260
시스템이란 모듈을 써야 돼요

5042
05:29:17,340 --> 05:29:24,760
Sys 모듈을 사용해야 되는데 어 요거는 이제 외부
모듈을 가져와 쓰는 건데 이건 사실 다음 주에 배웁니다

5043
05:29:24,840 --> 05:29:29,820
다음 주에 배우는데 좀 미리 땡겨서
배워보자면 네 이게 4-1이 지금 챕터 4 안에 있죠

5044
05:29:29,960 --> 05:29:31,620
그래서 하나 이동을 해보겠습니다

5045
05:29:31,840 --> 05:29:37,180
지금 파이썬 폴더 안인데 챕터 4 안에
있어서 cd하고 챕터 4로 들어가보겠습니다

5046
05:29:37,420 --> 05:29:41,277
그러면 이제 경로가 이제 파이썬의
챕터 4가 돼서 여기로 들어가면 들어왔죠

5047
05:29:41,301 --> 05:29:46,120
그럼 여기서 실행하려면 4-1.py를
이렇게 실행할 수가 있습니다

5048
05:29:46,300 --> 05:29:47,460
그래서 요거를 실행해봤습니다

5049
05:29:47,580 --> 05:29:49,680
그러면 어 요거를 새로 만들게요

5050
05:29:49,800 --> 05:29:51,437
Sys1으로 예제가 나와있으니

5051
05:29:51,461 --> 05:29:55,380
1.py를 만들고 계속 4-1로만
우려먹었는데 요걸로 해보겠습니다

5052
05:29:55,580 --> 05:29:59,560
그러면 이제 챕터 4 안에 들어왔으니까
여기 안에 요거를 실행할 수가 있겠죠

5053
05:29:59,720 --> 05:30:07,720
그러면 파이썬 원래 sys1.py를 실행하게 되면 요게 쭉
실행이 되는데 어 일단 그 여기 있는 거 아무것도 출력이 안됐어요

5054
05:30:08,040 --> 05:30:09,280
프린트문에 왜 그러냐

5055
05:30:09,320 --> 05:30:13,480
여기에 시스템을 이용해서 argument
value를 지금 가져오는 거예요

5056
05:30:13,680 --> 05:30:17,760
알스 안에 근데 여기 1번부터 뒤에 끝까지라고 돼있죠

5057
05:30:17,820 --> 05:30:24,300
그렇다는 거는 이 arguments가 요렇게 입력한 이 명령어
뒤에 arguments를 넣어주면 이게 여기에 들어가게 됩니다

5058
05:30:24,500 --> 05:30:25,240
이게 무슨 말이냐

5059
05:30:25,300 --> 05:30:31,751
여기 뒤에 한 칸 띄우고 뭐 123 이렇게
넣게 되면 이 arguments에 123 요게 다 담겨서

5060
05:30:31,775 --> 05:30:37,360
요게 들어가서 이게 여기에 저장이 되고 이거를
for문으로 하나씩 출력을 해서 요렇게 나오는 겁니다

5061
05:30:37,580 --> 05:30:41,200
그러면 이거를 0번째부터로 바꾸면 어떻게 될까요

5062
05:30:41,320 --> 05:30:45,820
똑같이 0번째부터로 바꾸고 실행을
해보면 이번에는 이렇게 파일명 있죠

5063
05:30:45,980 --> 05:30:49,680
요것 마저도 arguments의 0번째가 이 파일명입니다

5064
05:30:49,840 --> 05:30:53,820
그래서 이게 0번 이게 1번 이게 2번 이게 3번인 거죠

5065
05:30:53,920 --> 05:31:00,398
그래서 이게 마치 리스트 인덱스처럼 어떤
명령어에도 이 시스템 명령어 안에도 arguments가 이렇게

5066
05:31:00,422 --> 05:31:07,060
1234개가 지금 들어가 있는데 이런 식으로
마치 함수의 파라미터를 받듯이 받을 수가 있습니다

5067
05:31:07,300 --> 05:31:09,237
그래서 요게 여기로 이렇게 들어가는 거죠

5068
05:31:09,261 --> 05:31:12,480
그러면은 이거를 응용해보면 뭐 이런 것도 할 수 있겠죠

5069
05:31:12,580 --> 05:31:20,580
그럼 123 이런 거를 더해서 그러면은 sum이라는 거를 처음에
0이라고 해놨다가 arguments들을 이것도 한 함수처럼 쓸 수가 있겠습니다

5070
05:31:22,720 --> 05:31:30,720
그래서 이것도한 파이썬하고 시스 원점 파이에 여기에 뭐
253 이렇게 하면 그 arguments가 스트링으로 날라갑니다

5071
05:31:31,420 --> 05:31:38,320
그래서 스트링으로 날라가기 때문에 253을 넣었더니 이게
들어가서 각각의 arguments들을 sum과 더해서 10이 됩니다

5072
05:31:38,520 --> 05:31:41,380
왜냐 2 더하기 5 더하기 3이 되기 때문이죠

5073
05:31:41,460 --> 05:31:49,240
그래서 이런 식으로 마치 함수를 활용하듯 command line 명령어
프로그래밍에서도 이런 식으로 arguments들을 받을 수가 있습니다

5074
05:31:49,580 --> 05:31:53,780
그래서 이렇게 활용할 일이 종종 있어서
이거는 알아두시면 좋을 것 같습니다

5075
05:31:54,040 --> 05:32:00,520
그래서 여기 나왔듯이 이게 argument 0번이 요거고
1번째가 요거고 2번째가 요거고 3번째가 요겁니다

5076
05:32:00,600 --> 05:32:03,800
그래서 명령을 입력할 때 이렇게
여러 가지를 받을 수가 있습니다

5077
05:32:04,020 --> 05:32:04,740
여기서도 나오죠

5078
05:32:04,780 --> 05:32:08,320
이렇게 하면 이게 0123번째
arguments들을 받는 겁니다

5079
05:32:08,480 --> 05:32:09,540
마치 이런 거 같죠

5080
05:32:09,620 --> 05:32:17,160
함수에서도 함수 단원 배울 때 add 함수하고 a b c
이렇게 받으면은 이거를 받아서 뭔가 처리를 할 수 있었잖아요.

5081
05:32:17,200 --> 05:32:22,485
Return a 더하기 b 더하기 c 이렇게
처리를 할 수 있었던 것처럼 요런 arguments가

5082
05:32:22,509 --> 05:32:27,020
사실 이 파일부터 시작되는 요런
arguments가 사실 요거랑 개념이 비슷합니다

5083
05:32:27,200 --> 05:32:32,140
그래서 요거 개념이랑 요거랑 같이 이해하시면
좀 이해하기가 편할 수 있을 것 같습니다

5084
05:32:32,320 --> 05:32:34,080
그래서 요렇게 실행할 수 있고요

5085
05:32:34,540 --> 05:32:37,960
그러면은 예제 하나 간단한 거를 또 해보도록 하겠습니다

5086
05:32:38,180 --> 05:32:46,180
여기에 이제 arguments들을 1번째부터 끝까지 받아서 저장한 다음에
그거를 대문자로 변경하고 각각 받은 거를 그리고 end 이거는 기억나시나요?

5087
05:32:48,580 --> 05:32:53,180
한 칸 원래는 프린트하면 아래로 내려가는데
그거 대신에 띄어쓰기를 넣겠다는 거죠

5088
05:32:53,300 --> 05:33:00,728
그래서 이거를 이용해서 파이썬 sys2.py에 뭐 hello
조코딩 이런 걸 치면은 이렇게 각각의 파라미터들이

5089
05:33:00,752 --> 05:33:08,420
날라가서 arguments에 담았으니까 그거를
이제 i로 받아서 i.upper 이거는 2주차 때 배웠죠

5090
05:33:08,460 --> 05:33:16,460
대문자로 바꾸기 함수인데 출력할 때 띄어쓰기로 연결해서 출력을 한다
라고 하니까 이렇게 입력한 파라미터들이 대문자로 변환돼서 출력이 됐습니다

5091
05:33:17,660 --> 05:33:19,140
요렇게 활용할 수가 있겠습니다

5092
05:33:19,400 --> 05:33:25,600
이게 함수로 치자면 사실 더 간단하게도 표현이
되는데 sys를 마냥 안 쓰고 up이라는 함수를 만들어 볼게요.

5093
05:33:25,720 --> 05:33:28,000
Args를 받아서 똑같이 쓸 수가 있겠죠.

5094
05:33:28,140 --> 05:33:33,900
Args를 받고 이거를 저장한 다음에
upper하고 end라고 한다면 사실 이거랑 같죠

5095
05:33:34,000 --> 05:33:39,060
그래서 up에다가 hello world 조코딩을
네 요거랑 사실상 비슷한 개념입니다

5096
05:33:39,200 --> 05:33:42,800
그래서 요거를 실행해보시면 결과가 똑같이 나옵니다

5097
05:33:42,860 --> 05:33:49,405
이런 함수의 개념이 이해가 되셨다면 이런 args를
여기 커맨드 라인 상에서도 받아서 이렇게 넣을 수가

5098
05:33:49,429 --> 05:33:56,880
있고 아니면 이렇게 함수를 이해하셨으면 요렇게 써서
요거랑 같은 개념이다 라고 이해하시면 좋을 것 같습니다

5099
05:33:57,300 --> 05:34:04,420
네 그래서 이렇게 해서 이제 커맨드 라인을 이용한 그
프로그램의 입력과 출력에 대해서 쭉 예제를 다 해봤습니다

5100
05:34:05,020 --> 05:34:08,300
파이썬 5장 파이썬 날개 달기를 들어가보도록 하겠습니다

5101
05:34:08,500 --> 05:34:12,120
그러면 오늘을 뭘 배울 거냐 좀
정리를 해보면 되게 많은 걸 배울 겁니다

5102
05:34:12,320 --> 05:34:15,840
그래서 좀 자세히 나가려면 진짜
끝도 없이 자세히 나갈 수 있고요

5103
05:34:16,020 --> 05:34:23,400
근데 또 그렇게 중요도를 따지자면 클래스는 그냥
개념 정도가 중요하지 이게 사실은 필요 없을 수 있어요

5104
05:34:23,520 --> 05:34:29,720
왜냐 클래스 없이도 다 만들 수 있기 때문에
클래스는 좀 사용자 관점에서 봐도 좋을 것 같고요

5105
05:34:29,760 --> 05:34:33,560
기초를 배우고자 하시는 분들은
아니면 모듈 패키지도 마찬가지예요

5106
05:34:33,640 --> 05:34:39,200
이게 여기를 막 깊게 판다기보다는 사용법
위주로 그 중심으로 아시면 될 것 같습니다

5107
05:34:39,280 --> 05:34:40,520
왜냐면 이게 좀 어려워요

5108
05:34:40,600 --> 05:34:48,600
처음에 접하면 조금 어려운 부분이라서 좀 사용자 관점에서 만드는 방법은
아 이정도 있구나 라고 그냥 익혀두시면 좋을 것 같고 클래스 누가 만들어 놓은

5109
05:34:49,921 --> 05:34:55,520
거 쓰는 방법 모듈 패키지가 있으면 쓰는 방법 요
정도만 아셔도 굉장히 많은 부분을 할 수가 있습니다

5110
05:34:55,760 --> 05:34:59,380
예외 처리는 이거가 그나마
조금 더 중요도가 높은 것 같아요

5111
05:34:59,480 --> 05:35:04,417
중요도 순위를 좀 매겨보자면
50점 얘는 40점 얘가 한 60점?

5112
05:35:04,441 --> 05:35:10,360
4장으로 얘는 너무 상식적인 거라 이거는 그냥
점수 매기게 되면 4장 함수는 지금까지 써왔던 겁니다

5113
05:35:10,560 --> 05:35:16,640
그래서 뭐 점수는 높겠지만 써왔던 거고 이것도
써왔던 거고 이것도 사용법만 알면 돼서 얘도 한 60점?

5114
05:35:16,920 --> 05:35:23,220
아무튼 예외 처리나 요 정도가 중요한데 일단은
하나씩 나가보면서 자세한 거는 설명드리도록 하겠습니다

5115
05:35:23,460 --> 05:35:31,460
아무튼 오늘은 좀 자세히 배우려면 어렵지만 그래도 큰 개념만 이해하고
사용 방법 위주로 학습하신다고 생각하시면 조금 더 마음은 편하실 것 같습니다

5116
05:35:32,180 --> 05:35:33,920
몰라도 할 수 있는 부분이 굉장히 많습니다

5117
05:35:34,040 --> 05:35:34,996
이번에 배울 것 중에

5118
05:35:35,020 --> 05:35:38,580
네 그러면 클래스 부터 나가보도록 하겠습니다

5119
05:35:38,860 --> 05:35:42,480
클래스는 쉽게 말해서 반복되는 변수와 메서드

5120
05:35:42,540 --> 05:35:47,480
이게 메서드라는 말이 이제 자주 나올 텐데
처음 들으면 어려운데 사실 함수랑 똑같은 말입니다

5121
05:35:47,700 --> 05:35:54,460
그래서 지난 주차를 배우신 분들은 함수 개념을 좀 이해하셨을
텐데 함수랑 메서드랑 뭐 같다라고 생각하셔도 무방합니다

5122
05:35:54,660 --> 05:35:59,353
근데 뭐 클래스 안에 들은 걸 메서드라고
하긴 하는데 사실 또 용어가 두 개면

5123
05:35:59,377 --> 05:36:03,460
헷갈리니까 메서드랑 함수랑 뭐 같은
개념이라고 봐도 사실 포함관계이긴 하죠

5124
05:36:03,520 --> 05:36:04,900
함수 안에 이제 메서드가 있는 건데

5125
05:36:05,020 --> 05:36:09,220
이렇게 헷갈리니까 그냥 메서드가
함수다라고 생각하시면 좀 편할 것 같습니다

5126
05:36:09,260 --> 05:36:12,340
그래서 변수랑 함수를 미리 정해놓은 틀

5127
05:36:12,600 --> 05:36:13,800
설계도의 개념입니다

5128
05:36:14,080 --> 05:36:18,660
그래서 이거 지금 보면 어떤 말인지 잘
모르실 텐데 하나씩 같이 보도록 하겠습니다

5129
05:36:18,980 --> 05:36:23,040
초보 개발자들에게 넘기 힘든
장벽과 같은 존재라고 할 수 있습니다

5130
05:36:23,180 --> 05:36:29,816
미리 말씀드리지만 약간 어려운데 이거를 막 온전히
막 다 외워서 쓰지 않아도 할 수 있는 부분이 많아서

5131
05:36:29,840 --> 05:36:35,660
그냥 큰 개념을 익히고 아 이게 이런 거구나 하고
사용법 위주로만 아셔도 꽤 많은 것들 할 수가 있습니다

5132
05:36:35,780 --> 05:36:38,700
그래서 이제 기초부터 차근차근 배워보도록 하겠습니다

5133
05:36:38,900 --> 05:36:45,196
일단은 클래스가 왜 필요한가를 보면은 이 여기서
또 강조된 게 C언어가 되게 많이 쓰이는 언어잖아요

5134
05:36:45,220 --> 05:36:46,540
C언어에는 클래스가 없습니다

5135
05:36:46,800 --> 05:36:50,840
그렇다는 거는 굳이 클래스가
없어도 프로그램을 만들 수가 있습니다

5136
05:36:51,100 --> 05:36:58,937
그래서 여기서 좌절해서 아 파이썬 포기해야지라고 하기에는 그냥 클래스
없이도 할 수 있는 게 많기 때문에 어떻게 보면 참고 이 어려운 걸 조금이라도

5137
05:36:58,961 --> 05:37:02,820
이해한 다음에 사용자 관점에서만
이해해도 굉장히 많은 것들을 할 수가 있습니다

5138
05:37:03,020 --> 05:37:09,000
그래서 네 그 파이썬 잘 만들면 프로그램 중에서도
클래스를 사용하지 않고 작성한 것들이 많습니다

5139
05:37:09,120 --> 05:37:14,820
계산기 프로그램을 만들면서 일단 클래스를
일단은 만들어보는 게 조금 이해가 될 수 있잖아요

5140
05:37:14,980 --> 05:37:17,340
그래서 개념을 좀 배우기 전에 만들어 보도록 하겠습니다

5141
05:37:17,540 --> 05:37:23,731
이렇게 뭐 더쌤 이런 기능을 하는 계산기를
클래스로 한번 구현을 해보면서 그거에 왜

5142
05:37:23,755 --> 05:37:28,300
필요한지나 어떤 개념인지를 좀 대략적으로나마
익히고 좀 시작을 해보도록 하겠습니다

5143
05:37:28,560 --> 05:37:36,560
계산기의 더하기 기능이 구현된 파이썬 코드를 만들어 보자면
이거는 뭐 지난 시간에 나온 함수만은 일단 구현을 해보면 이렇게 될 겁니다

5144
05:37:37,380 --> 05:37:43,800
Result라는 변수가 있는데 얘는 전역 변수라서
함수 안에서 쓰려면 글로벌 이런 걸로 불러와야 됐죠

5145
05:37:43,880 --> 05:37:46,660
그래서 전역 변수를 글로벌로 불러와서 가져왔습니다

5146
05:37:46,800 --> 05:37:52,845
그리고 더하기 함수를 만드니까 add라고
이름을 지었고 숫자를 받아서 이 result 글로벌 result

5147
05:37:52,869 --> 05:37:58,060
변수에 num을 하나씩 더해주는 그리고
result를 다시 돌려주는 네 요런 함수가 있습니다

5148
05:37:58,280 --> 05:38:06,280
그러면 add 3을 입력하고 4를 입력하면 3 들어갔다가 4가
들어가면은 3 더하기 4가 계속 순차적으로 여기 쌓이겠죠.

5149
05:38:06,520 --> 05:38:12,191
Result에 그래서 실행을 해보면 처음에 이제
이거 들어갔을 때는 3이 딱 들어갔다가 이제

5150
05:38:12,215 --> 05:38:17,880
4가 들어가면 3 더하기 4가 돼서 7이 되는
네 요런 간단한 함수를 짜볼 수가 있겠습니다

5151
05:38:18,060 --> 05:38:23,480
그럼 이게 함수인데 여기서 두 개의
값을 따로따로 계산하고 싶을 수도 있잖아요

5152
05:38:23,640 --> 05:38:31,640
그러니까 한쪽 계산기는 어떤 다른 일을 처리하고 또 다른 계산기는 또 다른
일을 처리하고 싶을 때 이 계산기 두 대를 만든다 라고 생각을 해보겠습니다

5153
05:38:32,361 --> 05:38:35,220
그럼 코드에서 계산기 두 대를 만들려면 어떻게 해야 되냐

5154
05:38:35,280 --> 05:38:39,080
그리고 그 각각이 따로따로
역할을 하려면 이렇게 하면 됩니다

5155
05:38:39,300 --> 05:38:43,340
일단은 result1과 result2가
있는데 이거를 각각 놨어요

5156
05:38:43,440 --> 05:38:43,660
왜냐?

5157
05:38:43,720 --> 05:38:44,720
섞이면 안 되잖아요

5158
05:38:44,900 --> 05:38:49,660
그러니까 한쪽은 뭐 1번에 대한 계산을
하고 싶고 한쪽은 뭐 2번에 대한 계산을

5159
05:38:49,684 --> 05:38:54,460
하고 싶어서 이 두 개가 같이 데이터가
섞이지 않으려면 변수를 따로따로 둬야겠죠

5160
05:38:54,600 --> 05:38:56,480
Add1, add2를 나눠놨습니다

5161
05:38:56,600 --> 05:38:57,000
왜냐?

5162
05:38:57,160 --> 05:39:02,335
Result1에 저장하는 함수가 있을
것이며 result2에 저장하는 함수가 따로따로

5163
05:39:02,359 --> 05:39:07,181
되어있어야 되기 때문에 이런 식으로 똑같은
함수인데 굳이 두 개를 만들어 줘야 됩니다

5164
05:39:07,280 --> 05:39:07,680
왜냐?

5165
05:39:07,760 --> 05:39:11,920
이 저장하는 변수가 달라야지 서로
다른 계산을 처리를 할 수가 있겠죠

5166
05:39:12,040 --> 05:39:14,060
안 그러면 막 계산이 섞이면 안 되잖아요

5167
05:39:14,220 --> 05:39:18,960
아니면 하나를 처리하고 끝난 다음에 처리하고
이래야 되는데 그러려면 좀 취지와 맞지 않죠

5168
05:39:19,020 --> 05:39:20,800
여러 개의 계산기를 만든다는 취지에는

5169
05:39:20,920 --> 05:39:28,920
이렇게 만들어야 1번 계산은 1번끼리 하고 2번 계산은 2번끼리
해서 이거를 수행했을 때 이렇게 원하는 결과 여기 1번에 대한 계산,

5170
05:39:29,701 --> 05:39:35,180
2번에 대한 계산이 별도로 이루어질 수
있으려면 이렇게 똑같은 함수를 2번씩이나 써야 돼요

5171
05:39:35,240 --> 05:39:36,820
변수도 2번이나 만들어야 되고요

5172
05:39:36,920 --> 05:39:38,760
이러면 좀 비효율이 느껴지죠

5173
05:39:38,940 --> 05:39:44,936
이거를 아 이러면 계산기가 막 100개, 1000개면은 이거
함수를 똑같은 함수인데 100개, 1000개를 만들어야 되나?

5174
05:39:44,960 --> 05:39:46,300
라는 생각이 들 수 있습니다

5175
05:39:46,560 --> 05:39:49,080
그래서 나온 게 이제 클래스의 개념입니다

5176
05:39:49,280 --> 05:39:56,880
그래서 미리 이거를 좀 전체 큰 그림을 보기 위해서 클래스를
구현한 것을 좀 가져와 보면 지금 이거랑 코드를 하나 더 만들어 볼까요?

5177
05:39:57,060 --> 05:39:57,300
네

5178
05:39:57,360 --> 05:39:59,580
이거랑 두 개를 비교를 해보도록 하겠습니다

5179
05:39:59,800 --> 05:39:59,897
네

5180
05:39:59,921 --> 05:40:02,856
그러면 왼쪽은 그 클래스라는 개념이 없을 때

5181
05:40:02,880 --> 05:40:03,220
네

5182
05:40:03,280 --> 05:40:06,440
없을 때 그냥 2번씩 함수를 다 만들어주는 개념이고요

5183
05:40:06,520 --> 05:40:09,760
오른쪽은 클래스를 사용했을 때 만들어지는 코드입니다

5184
05:40:09,900 --> 05:40:17,900
그래서 클래스를 사용하게 되면 일단은 Calculator에 대한 정의를
Class로 만들어 놓고 그다음에 Calculator를 찍어 내서 여기 보면.

5185
05:40:18,541 --> 05:40:25,060
Calculator1, Calculator2를 그냥 요렇게
찍어서 담는 방식으로 두 개를 만들어 줍니다

5186
05:40:25,240 --> 05:40:33,240
그다음에 각각 Cal1에 대해서 계산을 하고 Cal2에 대해서 계산을
해서 똑같은 함수를 두 번 만들어주는 일을 여기서는 안 해도 됩니다

5187
05:40:34,360 --> 05:40:40,625
클래스를 사용한 이유는 이렇게 중복된 여러
가지를 계속 찍어내기에는 너무 비효율적일 때 그때

5188
05:40:40,649 --> 05:40:47,260
하나의 클래스로 묶어서 좀 더 효율적으로 작성을
해보자 라는 취지에서 이런 클래스가 생겼습니다

5189
05:40:47,560 --> 05:40:49,980
그래서 그냥 취지에 대해서 한번 설명을 드렸고요

5190
05:40:50,120 --> 05:40:53,660
샤르님, 코드만 다를 뿐 결과값은 똑같은 거죠?

5191
05:40:53,800 --> 05:40:54,060
맞습니다

5192
05:40:54,240 --> 05:40:56,897
그래서 이걸 실행해도 똑같은 결과가 나옵니다

5193
05:40:56,921 --> 05:41:03,240
그래서 이거를 좀 더 효율적으로 클래스를
이용해서 찍어내보자 라는 그런 취지입니다

5194
05:41:03,340 --> 05:41:07,560
그거를 조금 더 단원을 나가면서 설명드리도록 하겠습니다

5195
05:41:08,040 --> 05:41:10,480
그래서 이거를 구현을 해볼 건데 맞아요

5196
05:41:10,540 --> 05:41:16,952
이게 계산기에 예를 들어 빼기 기능을 추가하고
싶다고 하면 예를 들어 함수를 각각 만들었으면

5197
05:41:16,976 --> 05:41:22,480
아까처럼 또 이 각각에 대해서 빼기 함수를
추가 추가해주면 총 함수가 4개가 되어버리겠죠?

5198
05:41:22,640 --> 05:41:29,360
그래서 그렇게 낭비를 안 하기 위해서 하나의 설계도를
만들어서 그걸로 찍어낸다로 생각하시면 좀 좋을 것 같습니다

5199
05:41:29,520 --> 05:41:34,720
그래서 이렇게 클래스를 쓰면 하나만 추가하면
된다라는 큰 개념을 일단 먼저 설명을 드렸고요

5200
05:41:34,820 --> 05:41:41,993
완벽한 비유는 아니겠지만 그래도 좀 현실
세계와 맞닿는 비유를 좀 해보면 클래스를 가장

5201
05:41:42,017 --> 05:41:47,540
잘 설명해주는 과자 틀이 클래스고 각각의
과자가 객체라고 좀 이해하시면 좋을 것 같습니다

5202
05:41:47,720 --> 05:41:52,900
그 객체라는 것도 처음 들으면 약간
이게 뭐지 싶을 텐데 사실 별거 없습니다

5203
05:41:53,060 --> 05:41:59,000
그냥 클래스로 인해서 만들어낸 하나의 개체,
즉 하나의 과자라고 이해하시면 좋을 것 같습니다

5204
05:41:59,120 --> 05:42:01,060
다양한 비유를 들면 좋을 것 같은데요

5205
05:42:01,100 --> 05:42:05,480
이해를 돕기 위해서 먼저 과자
틀과 과자에 대한 비유도 있을 거고요

5206
05:42:05,560 --> 05:42:10,680
가장 또 많이 사용되는 비유 중에 하나가
붕어빵 틀과 붕어빵으로 많이 비유도 합니다

5207
05:42:11,080 --> 05:42:16,940
그러면 붕어빵 틀은 이렇게 한 번 만들어놓으면
똑같은 형태로 이렇게 여러 개를 계속 찍어낼 수가 있잖아요

5208
05:42:17,180 --> 05:42:23,797
이렇게 붕어빵 틀과 붕어빵이 이 클래스와
객체의 관계라고 이해하셔도 좋을 것 같습니다

5209
05:42:23,821 --> 05:42:29,754
설계 도면이 있으면 얘는 이렇게 도면을
쫙 설계를 해놓은 다음에 이대로 만약에 집을

5210
05:42:29,778 --> 05:42:35,040
여러 채를 지어야 된다 하면 설계 도면만
있으면 여러 채를 집을 막 찍어낼 수가 있겠죠

5211
05:42:35,180 --> 05:42:43,180
이런 식으로 어떤 설계 도면이 클래스고 건물이 객체 이렇게 비유를 해볼 수도
있겠고 아니면 게임 좋아하시는 분들은 스타크래프트 이런 걸로 비유하면 좀 더

5212
05:42:45,561 --> 05:42:53,561
와닿을 텐데 실제로 이게 게임 개발할
때 당연히 클래스를 정해놓고 인스턴스를

5213
05:42:53,801 --> 05:42:53,777
찍어내는 이런 방식으로 실제로 개발이
되기 때문에 이런 방식으로 설계 도면이 있겠죠

5214
05:42:53,801 --> 05:42:57,496
약간 커맨드 센터 같은 데서
이 SCB라는 거를 뽑아내잖아요

5215
05:42:57,520 --> 05:43:02,681
그때 커맨드 센터가 이제 그 SCB를
생산하는 방법을 아는 설계도를 가지고

5216
05:43:02,705 --> 05:43:08,501
있는 거고 그리고 SCB를 이렇게
찍어내면은 이게 나오는 게 각각이 객체입니다

5217
05:43:08,540 --> 05:43:11,880
이렇게 여러 가지 비유를 좀
들었는데 이러면 조금 와닿으시나요?

5218
05:43:11,980 --> 05:43:15,860
즉 클래스는 그냥 우리가 이렇게
만들 것이다 라는 설계도고요

5219
05:43:15,960 --> 05:43:21,240
그리고 실제로 만들어낸 그 결과물들이
객체이다라고 이해하시면 좋을 것 같습니다

5220
05:43:21,500 --> 05:43:26,800
여기서도 또 약간 핵심적인 개념이 나오는
이런 각각의 객체들은 두 가지가 있어요

5221
05:43:26,940 --> 05:43:30,280
여기 HP라는 이런 어떤 값이 있고요

5222
05:43:30,480 --> 05:43:38,480
그러니까 어떤 숫자가 저장되거나 뭐 문자가 저장되는 어떤
값이 있고 그리고 뭐 미네랄 캐기 수리하기 뭐 이런 행동이 있습니다

5223
05:43:39,220 --> 05:43:42,000
이 객체가 가지고 있는 속성은 두 가지밖에 없습니다

5224
05:43:42,240 --> 05:43:43,240
이것만 기억하시면 됩니다

5225
05:43:43,400 --> 05:43:44,800
어떤 값이 있을 것이고요

5226
05:43:44,880 --> 05:43:48,200
그리고 이 미네랄 캐기 수리하기와
같은 이런 행동이 있을 겁니다

5227
05:43:48,400 --> 05:43:51,640
객체는 무조건 값과 행동밖에 없습니다

5228
05:43:51,880 --> 05:43:52,717
다른 건 없어요

5229
05:43:52,741 --> 05:43:55,600
값과 행동을 지닌 어떤 찍어낸 것들

5230
05:43:55,660 --> 05:43:57,900
이런 각각의 scv가 객체이고요

5231
05:43:58,020 --> 05:44:03,616
그래서 이거를 좀 더 유식한 말로 표현을
하자면 다시 처음으로 돌아가서 반복되는 변수

5232
05:44:03,640 --> 05:44:06,340
변수가 아까 그 hp와 같은 값이죠

5233
05:44:06,500 --> 05:44:08,980
그 다음에 메서드 함수가 어떤 행동이죠

5234
05:44:09,120 --> 05:44:16,717
그래서 이 값이랑 행동을 미리 딱 설계를 해놓고 그거를
찍어내는 개념이 클래스라고 이해하시면 좋을 것 같습니다

5235
05:44:16,741 --> 05:44:24,040
일단 좀 다양한 비유들을 들었는데 이제 실제로 코드를 보면서
그 비유가 어떻게 적용되는지 실제 코드로 보도록 하겠습니다

5236
05:44:24,220 --> 05:44:29,720
그러면 일단은 파이썬 클래스의 가장
간단한 기본 툴부터 알아보도록 하겠습니다

5237
05:44:30,260 --> 05:44:31,360
클래스를 만든다

5238
05:44:31,400 --> 05:44:33,700
즉 설계도를 만들 때 어떻게 만들어야 되냐

5239
05:44:33,760 --> 05:44:37,920
먼저 클래스라는 예약어, 미리 정해진 명령을 써줍니다

5240
05:44:38,040 --> 05:44:40,020
함수는 def를 적어줬죠.

5241
05:44:40,220 --> 05:44:42,120
Def하고 함수 이름을 적어줬잖아요

5242
05:44:42,300 --> 05:44:46,600
여기서는 클래스라고 적어주고 여기에 대문자로

5243
05:44:46,740 --> 05:44:47,520
여기 좀 규칙이 있습니다

5244
05:44:47,700 --> 05:44:55,320
맨 앞글자를 대문자로 하는 게 좀 파이썬 규칙에 맞게
쓰려면 이렇게 써야 되는 게 좀 파이썬의 규격에 맞는 방법입니다

5245
05:44:55,500 --> 05:45:00,560
그래서 클래스는 대문자를 항상 앞에
써주고 그 다음에 그 이름을 정해줍니다

5246
05:45:00,660 --> 05:45:06,100
그리고 마찬가지로 콜론을 써주고 그 아래는
이제 설계도에 해당하는 것들을 작성해주면 됩니다

5247
05:45:06,300 --> 05:45:08,020
클래스 기초를 한번 만들어 봤고요

5248
05:45:08,100 --> 05:45:12,620
그러면 이 클래스를 만들었으면 이제
찍어내는 그 결과를 담아야 되잖아요

5249
05:45:12,780 --> 05:45:13,920
그걸 어떻게 담냐

5250
05:45:14,080 --> 05:45:15,440
변수를 하나 만듭니다

5251
05:45:15,520 --> 05:45:16,540
쿠키 클래스다

5252
05:45:16,740 --> 05:45:19,060
초코 쿠키 아몬드 쿠키를 만들어 드리겠습니다

5253
05:45:19,260 --> 05:45:23,180
그래서 쿠키에서 이렇게 담아주고
이렇게 해서 담아줄 수가 있습니다

5254
05:45:23,380 --> 05:45:26,760
물론 지금은 그냥 되게 비유적인
거고 아직 아무것도 없잖아요

5255
05:45:26,820 --> 05:45:27,260
클래스 안에

5256
05:45:27,400 --> 05:45:33,240
그래서 일단은 가장 큰 그림, 기본만
보자면 설계도가 있고 설계도를 찍어내는 방법

5257
05:45:33,460 --> 05:45:40,130
이제 클래스를 불러와서 마치 함수를 호출할 때처럼
이 괄호 열고 닫고 이 안에 뭔가 매개변수를 넣거나 하는

5258
05:45:40,154 --> 05:45:48,154
행위는 있을 텐데 그래도 기본적으로 이렇게 쿠키라는
클래스를 이렇게 찍어내면 리턴값으로 인스턴스가 나옵니다

5259
05:45:48,900 --> 05:45:51,520
그래서 여기에 인스턴스가 들어가게 되고요

5260
05:45:51,860 --> 05:45:55,700
그러면 여기 쿠키 여러 개를 찍어서
변수에 이렇게 담아줄 수가 있겠죠

5261
05:45:55,900 --> 05:46:00,680
그래서 이렇게 기본적으로 구성되는
게 클래스의 완전 기초적인 개념입니다

5262
05:46:00,940 --> 05:46:02,200
이것까지는 안 어렵죠

5263
05:46:02,240 --> 05:46:07,380
그런데 약간씩 어려워지는데 그래도 일단은
이렇게 된다라는 큰 그림을 먼저 설명을 드리고요

5264
05:46:07,480 --> 05:46:12,300
그다음에 또 용어가 여긴 항상 용어가
막 이상한 게, 비슷한 게 많이 나와요

5265
05:46:12,720 --> 05:46:16,680
객체라고도 하고 찍어낸 그 쿠키를
인스턴스라고도 하긴 하거든요

5266
05:46:16,740 --> 05:46:20,000
어... 클래스로 만들어낸 객체를 인스턴스라고 합니다

5267
05:46:20,120 --> 05:46:21,820
그래서 사실 같다고 보시면 돼요

5268
05:46:21,880 --> 05:46:29,880
이게 뭐... 뭐 면밀한 차이를 만들 수는 있겠지만 여기서 굳이 이제
처음이니까 보자면은 객체와 인스턴스의 차이는 무엇일까라고 하면 어...

5269
05:46:29,923 --> 05:46:32,000
A는 객체, 왜냐하면 쿠키로 찍어낸 거죠

5270
05:46:32,140 --> 05:46:36,100
그리고 A 객체는 쿠키의 인스턴스라고 부를 수가 있겠습니다

5271
05:46:36,320 --> 05:46:39,920
선수의 뭐 인자니 뭐... 뭐 파라미터니
이렇게 되게 용어가 많았잖아요?

5272
05:46:40,060 --> 05:46:45,883
근데 그거가 다 비슷한 개념인 것처럼
그냥 A가 그 찍어낸 쿠키가 객체이고

5273
05:46:45,907 --> 05:46:51,240
그리고 A 객체는 그 쿠키라는 클래스의
인스턴스다 라고 이해하실 수가 있겠습니다

5274
05:46:51,420 --> 05:46:57,200
뭐 굳이 이렇게 분류하자면 다르게 할 수는
있는데 인스턴스나 객체나 뭐 다 비슷한 거다

5275
05:46:57,240 --> 05:46:58,520
그냥 똑같이 쓰면 된다

5276
05:46:58,560 --> 05:47:00,200
라고 하시면 좋을 것 같습니다

5277
05:47:00,580 --> 05:47:05,660
이제 실제로 클래스를 조금 더 그럼
구체적으로 만들어보면서 익혀보도록 하겠습니다

5278
05:47:06,020 --> 05:47:08,900
네, 그러면은 이제 계산기를 한번 만들어보도록 하겠습니다

5279
05:47:09,160 --> 05:47:16,123
일단은 좀 큰 그림을 그려보자면 어... 계산기
클래스를 사측 연산이 가능하도록 만드는 그

5280
05:47:16,147 --> 05:47:21,260
계산기를 여러 개 찍어낼 수 있는 계산기의
설계도를 한번 이번 시간에 만들어보도록 하겠습니다

5281
05:47:21,460 --> 05:47:27,720
그러려면 사측 연산에서 두 숫자를 일단 입력받기
위해서 이 클래스라는 게 결국 두 가지밖에 없잖아요?

5282
05:47:27,880 --> 05:47:31,980
변수가 있을 것이며 함수가 있는데
이걸로만 기억하시면 좀 편해요

5283
05:47:32,100 --> 05:47:36,120
그래서 변수 혹은 함수를 어떻게
설계를 한 다음에 찍어내는 겁니다

5284
05:47:36,340 --> 05:47:41,439
변수를 일단 사측 연산을 할 거니까
두 가지 숫자를 입력받는 즉 변수를

5285
05:47:41,463 --> 05:47:47,100
만들어야겠다라는 생각이 그러니까 숫자
1, 숫자 2가 들어갈 수 있는 변수를 만들고요

5286
05:47:47,200 --> 05:47:53,020
더하기 기능, 빼기 기능, 곱하기 기능, 나누기
기능을 담은 각각의 함수를 만들 수가 있겠죠

5287
05:47:53,160 --> 05:47:57,760
그래서 어떠한 클래스든 변수와
함수만 만들어주면 다 만들 수 있습니다

5288
05:47:57,980 --> 05:48:01,540
클래스는 변수와 함수에 대한
설계도다라고 이해하시면 좋을 것 같습니다

5289
05:48:01,640 --> 05:48:05,240
그래서 기본적으로 이렇게 구성이
된다라고 이해를 해볼 수가 있겠고요

5290
05:48:05,340 --> 05:48:07,520
그 다음에 실제로 한번 만들어보도록 하겠습니다

5291
05:48:08,060 --> 05:48:08,436
어... 네

5292
05:48:08,460 --> 05:48:10,680
그 수행하는 것부터 여기서는 보여주고 있어요

5293
05:48:10,860 --> 05:48:18,860
그래서 포칼이라는 클래스를 만들었다고 하면 이 포칼을 통해서
계산기를 찍어내면 이렇게 a라는 곳에 즉 포칼의 인스턴스가 a에 들어갈 겁니다

5294
05:48:20,700 --> 05:48:28,460
이 a라는 거는 이제 하나의 계산기가 담겨있으니까
여기에 .setData라는 이 메서드를 쓸 수가 있습니다

5295
05:48:28,700 --> 05:48:32,340
그래서 setData를 통해서 4와 2를 저장을 해주고요

5296
05:48:32,420 --> 05:48:40,420
그 다음에 .add를 통해서 이 두 개의 숫자를 더해준 값을 받을
수가 있고 또 곱하기도 .뭐를 통해서 곱한 값도 받을 수가 있고 a.

5297
05:48:41,784 --> 05:48:46,240
Sub을 통해서 빼기.divide .div를 통해서
나누기 이렇게 해볼 수가 있겠습니다

5298
05:48:46,420 --> 05:48:48,640
그래서 그럼 클래스를 하나씩 만들어 보도록 하겠습니다

5299
05:48:48,840 --> 05:48:54,800
그러면 아까는 쿠키였는데 이제 포칼 좀 실증적인
그 클래스를 하나씩 만들어 보도록 하겠습니다

5300
05:48:55,040 --> 05:48:56,880
그러면 기본 구조는 일단 같습니다

5301
05:48:57,100 --> 05:49:01,600
포칼이라는 함수를 만들되 여기에
보면은 그 맨 앞 글자가 대문자죠

5302
05:49:01,700 --> 05:49:06,380
대문자고 클래스를 썼으니까 이게
클래스라는 걸 좀 명확히 표시하는 방법입니다

5303
05:49:06,560 --> 05:49:11,040
그리고 여기 또 대문자가 또 있는데
이거는 그 표기법 중에 하나예요

5304
05:49:11,140 --> 05:49:17,036
이게 표기법이 막 자주 쓰는 게 몇 가지 있는데
이렇게 대문자로 서로 다른 걸 구분해서 많이 써요

5305
05:49:17,060 --> 05:49:18,580
예를 들어서 뭐 그런 거 있죠

5306
05:49:18,680 --> 05:49:22,636
뭐 애플 주스 이런 거 있으면 네
이렇게 애플과 주스가 다른 단어 잖아요

5307
05:49:22,660 --> 05:49:28,580
근데 이거를 같이 하나의 변수로 만들 때
보통 이렇게 각각 첫 글자를 대문자로 많이 씁니다

5308
05:49:28,960 --> 05:49:31,640
그러면 포칼을 이용해서 일단은 바로 찍어내볼게요

5309
05:49:31,720 --> 05:49:39,720
아직 기능은 없지만 그냥 뭐 a라는 변수에 포칼이라는 걸로 만들어서
그러면 이제 이 클래스로 만든 인스턴스 즉 붕어빵을 지금 a에 담은 거죠

5310
05:49:42,260 --> 05:49:42,756
네

5311
05:49:42,780 --> 05:49:43,736
계산기를 a에 담고

5312
05:49:43,760 --> 05:49:46,920
그러면 이제 타입을 찍어볼 수가 있겠죠

5313
05:49:47,060 --> 05:49:47,540
네

5314
05:49:47,600 --> 05:49:48,640
그러면은 이렇게 됩니다

5315
05:49:48,900 --> 05:49:54,460
그 포칼이라는 클래스를 담은 그
객체가 이런 식으로 담기게 됩니다

5316
05:49:54,660 --> 05:50:00,860
즉 a에는 이제 포칼이라는 클래스로
만든 인스턴스 객체가 담기게 되는 것이죠

5317
05:50:01,140 --> 05:50:01,436
네

5318
05:50:01,460 --> 05:50:03,520
그다음에 하나씩 만들어보도록 하겠습니다

5319
05:50:03,760 --> 05:50:09,800
객체 연산할 숫자를 지정하기를 통해서 한번
숫자를 지정하는 것을 만들어 보도록 하겠습니다

5320
05:50:10,040 --> 05:50:10,396
네

5321
05:50:10,420 --> 05:50:12,640
그러려면 이제 포칼을 다시 정의를 해야겠죠

5322
05:50:13,760 --> 05:50:15,760
결국에 드디어 이제 첫 번째 뭔가를 넣습니다

5323
05:50:16,600 --> 05:50:18,040
SetData라는 함수죠

5324
05:50:18,100 --> 05:50:19,100
이 df 들어갔으니까

5325
05:50:19,300 --> 05:50:19,817
네

5326
05:50:19,841 --> 05:50:21,420
함수를 넣어보도록 하겠습니다

5327
05:50:21,920 --> 05:50:22,120
네

5328
05:50:22,160 --> 05:50:24,900
이렇게 일단 첫 번째 함수를 추가해 봤습니다

5329
05:50:25,100 --> 05:50:25,457
네

5330
05:50:25,481 --> 05:50:28,100
그럼 포칼이라는 클래스가 이제 드디어 뭔가 생겼습니다

5331
05:50:28,620 --> 05:50:30,480
SetData라는 함수를 넣어줬어요

5332
05:50:30,560 --> 05:50:35,420
그래서 이거를 뭐 메소드라고 부르기도
하는데 뭐 결국에 함수 안에 속한 거죠

5333
05:50:35,580 --> 05:50:37,180
근데 여기는 좀 특별합니다

5334
05:50:37,360 --> 05:50:38,700
이거는 뭐가 특별하냐

5335
05:50:38,760 --> 05:50:43,557
그 self라는 것과 first,
second를 이 파라미터로 받죠

5336
05:50:43,581 --> 05:50:43,820
여기서

5337
05:50:43,900 --> 05:50:50,580
여기서 self. First라고 쓰고 또 self.
Second에 이렇게 first, second를 넣어줍니다

5338
05:50:50,700 --> 05:50:53,300
그래서 이게 약간 혼동이 될 수가 있어요

5339
05:50:53,420 --> 05:50:54,280
이게 뭐 하는 짓인가

5340
05:50:54,380 --> 05:50:56,100
하나씩 좀 설명을 드리도록 하겠습니다

5341
05:50:56,420 --> 05:51:02,720
일단은 포칼이라는 걸 만들었고 setData라는 함수를
통해서 여기 포칼 일단 계산기를 찍어내서 a에 담았죠

5342
05:51:02,780 --> 05:51:07,680
그다음에 a.setData를 여기에 정의를
해놨으니까 이걸 사용할 수가 있습니다

5343
05:51:07,820 --> 05:51:07,960
이렇게

5344
05:51:08,080 --> 05:51:10,780
특이하게 지금 4하고 2밖에 안 넣었어요

5345
05:51:10,920 --> 05:51:12,717
우리가 함수를 배운 걸 생각해 보면

5346
05:51:12,741 --> 05:51:16,680
여기 4하고 2밖에 안 들어가니까 이 개수가 모자라죠

5347
05:51:16,720 --> 05:51:21,552
그래서 여기 self랑 first, second가
있는데 왜 개수를 모자라게 만들었지라고

5348
05:51:21,576 --> 05:51:26,480
생각할 수 있는데 사실은 이 self는 일단
뒤에 배우겠지만 그냥 자기 자신을 의미합니다

5349
05:51:26,600 --> 05:51:27,180
진짜 말 그대로

5350
05:51:27,340 --> 05:51:30,400
그리고 4가 여기 first에 들어가고
2가 second에 들어갑니다

5351
05:51:30,460 --> 05:51:38,460
그래서 4가 first에 저장이 되고 2가 second에 저장이
돼서 a .first와 a.second를 각각 찍어보면 이렇게 됩니다

5352
05:51:38,880 --> 05:51:42,697
여기 4, 2가 각각 first와
second에 저장돼서 이게 4입니다

5353
05:51:42,721 --> 05:51:45,260
이게 4고 이게 2가 된 것을 확인할 수가 있죠

5354
05:51:45,380 --> 05:51:47,660
좀 구체적으로 보자면 이렇게 되는 겁니다

5355
05:51:47,800 --> 05:51:52,400
좀 더 원리적으로 보자면 여기
a.setData 함수를 호출했잖아요

5356
05:51:52,580 --> 05:51:56,440
이때 이 앞에 있는 a 실제 그 계산기가 담긴 객체 있죠

5357
05:51:56,560 --> 05:51:59,400
그 객체 자체가 self로 먼저 들어갑니다

5358
05:51:59,460 --> 05:52:02,416
그렇기 때문에 이 self는 a를 의미하고요.

5359
05:52:02,440 --> 05:52:03,180
A 그 자체를

5360
05:52:03,340 --> 05:52:09,200
그다음에 first, second가 각각 여기 괄호 안에
들어간 이 매개 변수들이 이렇게 들어가게 됩니다

5361
05:52:09,480 --> 05:52:12,440
그렇기 때문에 이제 이 총 개수가 안 맞는다라고

5362
05:52:12,720 --> 05:52:13,400
생각할 수가 있는데

5363
05:52:13,600 --> 05:52:18,360
근데 이렇게 쓰는 이유가 이제 a 안에
뭔가 어떤 값을 저장하기 위해서인 겁니다

5364
05:52:18,580 --> 05:52:26,580
그래서 a 안에 어떤 값을 저장하기 위해서는 이 self. First self
.second 안에다가 이제 이 값들을 저장하는 그런 구조가 되겠습니다.

5365
05:52:28,280 --> 05:52:32,200
Self 안에는 이제 어느 객체가 호출한
건지 그 객체 자체가 들어가게 됩니다

5366
05:52:32,440 --> 05:52:39,540
뭐 이 변수 이름은 당연히 다르게 써도 되는데 가장 첫 번째
인수로 들어가게 되는 게 그 객체이다라고 이해하시면 좋을 것 같습니다

5367
05:52:39,820 --> 05:52:42,500
네 그래서 이렇게 기본적인 원리를 알아봤고요

5368
05:52:42,720 --> 05:52:44,120
Self는 필수인가요?

5369
05:52:44,220 --> 05:52:45,420
파이썬에서는 필수입니다

5370
05:52:45,520 --> 05:52:48,120
이게 자바에서는 이 self 이런 개념이 없거든요

5371
05:52:48,220 --> 05:52:54,020
그래서 다른 언어 배우시다가 파이썬을 배우면 약간
헷갈릴 수 있는데 파이썬에서는 좀 규칙이 이렇게 됩니다

5372
05:52:54,340 --> 05:52:59,600
그래서 여기 보면은 네 일단은 다시 위에 다시
보면 이 setData는 일단 method라고 부르고요

5373
05:52:59,720 --> 05:53:01,120
이게 결국 함수입니다

5374
05:53:01,220 --> 05:53:01,440
함수

5375
05:53:01,500 --> 05:53:03,800
그래서 내부 함수는 항상 method라고 표현이 됩니다

5376
05:53:04,060 --> 05:53:06,640
네 이렇게 저장하는 것까지 구현을 해봤고요

5377
05:53:06,740 --> 05:53:12,180
그래서 여기서 a가 self고 4가 first, 2가
second 이렇게 들어간다라고 봤습니다

5378
05:53:12,720 --> 05:53:17,440
여기서 그 self를 명시적으로 표현하는
것은 파이썬만의 독특한 특징입니다

5379
05:53:17,560 --> 05:53:20,460
그래서 다른 자바와 같은 언어에서는 self를 안 씁니다

5380
05:53:20,520 --> 05:53:28,520
그냥 self 자체를 써줌으로써 명시적으로 이 객체가 들어가서 이
객체의 값을 저장하겠다라고 좀 명시적으로 표현하는 그런 개념입니다.

5381
05:53:30,620 --> 05:53:32,040
Method로 호출하는 방법

5382
05:53:32,400 --> 05:53:34,320
이런 식으로도 활용할 수 있습니다

5383
05:53:34,440 --> 05:53:42,440
그 self를 굳이 안 쓰고 싶다라고 한다면 이제 그
클래스를 일단 찍어내서 저장한 다음에 그 아예 그 클래스

5384
05:53:55,005 --> 05:54:03,005
자체에서 그래서 이렇게 특정한 객체에 저장되는 그
객체만이 갖는 변수를 객체 변수 또는 속성이라고 부릅니다

5385
05:54:07,300 --> 05:54:12,080
이것도 용어가 많아서 헷갈려 할
수 있는데 사실 뭐 비슷한 개념입니다

5386
05:54:12,200 --> 05:54:17,480
그냥 하나로 퉁쳐서 좀 단순하게
외우자면 그냥 객체 안에 변수입니다

5387
05:54:17,620 --> 05:54:19,800
즉 이 a라는 계산기 있죠?

5388
05:54:19,880 --> 05:54:25,100
A가 계산기를 찍어내서 담은 거니까 그
a 안에는 그 두 가지 변수가 저장돼 있어요

5389
05:54:25,300 --> 05:54:30,760
그 first, 그래서 a.first 이렇게 쓰는
게 a에 저장된 변수이기 때문이에요

5390
05:54:30,840 --> 05:54:37,717
그래서 이 a 안에 들어간 first가 뭐 4고 a 안에
들어간 second가 2고 이런 식으로 저장이 된 거죠

5391
05:54:37,741 --> 05:54:44,756
그래서 그 특정 a라는 객체에 들어간
변수를 객체 변수 또는 속성이라고 부릅니다

5392
05:54:44,780 --> 05:54:45,120
어?

5393
05:54:45,300 --> 05:54:47,120
SetData는 내장 메소드가 아닙니다

5394
05:54:47,200 --> 05:54:48,420
그래서 만들어 줘야 됩니다

5395
05:54:48,660 --> 05:54:50,380
그래서 이렇게 만들어 준 겁니다

5396
05:54:50,620 --> 05:54:52,660
여기 보면은 이렇게 setData를 만들어 줬죠

5397
05:54:52,700 --> 05:54:56,220
이렇게 setData를 만들어 줬기
때문에 이걸 쓸 수가 있는 겁니다

5398
05:54:56,480 --> 05:54:57,800
안 만들어 주면 못 씁니다

5399
05:54:58,040 --> 05:55:04,880
만약에 그러면은 이게 객체 변수 이거 속성 이거의
개념을 조금 더 이해하려면 이런 식으로 이해하면 좋겠죠

5400
05:55:05,040 --> 05:55:06,337
두 개를 찍어내 보겠습니다

5401
05:55:06,361 --> 05:55:08,980
그럼 a, b를 각각 한번 찍어내 볼게요

5402
05:55:09,020 --> 05:55:15,158
붕어빵 틀 그 개념을 좀 생각해 보면
focal이라는 걸로 계산기 하나를 찍어냈다는 건

5403
05:55:15,182 --> 05:55:20,600
얘 a라는 붕어빵과 여기서 찍어낸 이 b라는
붕어빵은 서로 다른 붕어빵을 찍어낸 거죠

5404
05:55:20,740 --> 05:55:25,340
지금 만약 a에 4, 2를 넣고 b에는 1, 3을 넣는다

5405
05:55:25,380 --> 05:55:31,060
뭐 이렇게 따로따로 저장하자면 그럼 a에
저장된 값이랑 b에 저장된 값이랑 다르겠죠

5406
05:55:31,240 --> 05:55:36,057
그래서 a.first랑 b.first를 비교해 보자면 네

5407
05:55:36,081 --> 05:55:41,845
이렇게 출력을 하면 이제 a.first는
a에 저장된 첫 번째 값 즉 4가 저장이

5408
05:55:41,869 --> 05:55:46,840
되어 있고 b라는 계산기에는 b에
저장된 first 첫 번째 값은 1이겠죠

5409
05:55:47,000 --> 05:55:53,420
그래서 이렇게 각각 다른 속성을 가지고 있다
라고 해서 그 객체의 변수 속성 이렇게 부릅니다

5410
05:55:53,560 --> 05:55:59,800
그래서 용어가 많아서 그냥 헷갈리는데 쉽게 말해서 그
객체 안에 저장된 각각 가지고 있는 변수를 의미합니다

5411
05:56:00,000 --> 05:56:02,280
그래서 이렇게 클래스를 좀 이해해 볼 수가 있겠습니다

5412
05:56:02,520 --> 05:56:02,600
네

5413
05:56:02,660 --> 05:56:04,960
더하기 기능을 이제 추가를 해 보도록 하겠습니다

5414
05:56:05,180 --> 05:56:09,120
값을 저장하는 메서드를 하나 만들어 봤는데
추가적인 메서드를 또 만들어 보겠습니다

5415
05:56:09,300 --> 05:56:12,840
Add라는 메서드 그 더하기라는
기능을 한번 만들어 보겠습니다

5416
05:56:12,960 --> 05:56:14,157
코드를 추가해서 네

5417
05:56:14,181 --> 05:56:16,180
설계도에 이제 add라는 걸 추가를 해 줬어요

5418
05:56:16,260 --> 05:56:22,280
그러면 이 클래스를 이용해서 만든 그 각각의
객체들이 add라는 걸 사용할 수 있게 된 겁니다

5419
05:56:22,480 --> 05:56:22,780
네

5420
05:56:22,820 --> 05:56:28,240
SetData를 하고 그 다음에 add를 출력하면 어떻게
되는지 그 과정을 한 번씩 보여 드리도록 하겠습니다.

5421
05:56:28,420 --> 05:56:31,920
A.add를 호출해서 이거를 프린트를 해 보겠습니다

5422
05:56:32,040 --> 05:56:33,997
그러면 여기서 실행을 해 보면 네

5423
05:56:34,021 --> 05:56:34,740
6이 나오죠

5424
05:56:34,800 --> 05:56:35,757
왜 6이 나왔냐?

5425
05:56:35,781 --> 05:56:38,000
그 add라는 일단 메서드를 추가해 줬고요.

5426
05:56:38,080 --> 05:56:43,740
SetData는 아까 봤듯이 이제 4, 2를
각각 first, second에 각각 저장을 했죠

5427
05:56:43,780 --> 05:56:44,500
속성 안에

5428
05:56:44,640 --> 05:56:50,900
그 다음에 add라는 걸 호출하면 그 self가 아까
말했듯이 이 a라는 게 이걸로 self로 들어가는 거죠.

5429
05:56:51,020 --> 05:56:52,500
A가 self로 들어갑니다

5430
05:56:52,580 --> 05:56:56,180
그러면 a.first 즉 얘는 4가 되겠죠

5431
05:56:56,300 --> 05:56:59,040
그리고 a.second 얘는 2가 되겠죠

5432
05:56:59,180 --> 05:57:06,460
이걸 더해서 result를 만들고 즉 result는 6이고 return
6을 했기 때문에 이 프린트로 해서 6이 나오는 겁니다

5433
05:57:06,640 --> 05:57:06,760
네

5434
05:57:06,820 --> 05:57:11,160
이런 식으로 self를 받아서 처리하는
이 메서드를 만들어 주게 되었습니다

5435
05:57:11,340 --> 05:57:11,497
네

5436
05:57:11,521 --> 05:57:13,380
그래서 이렇게 구현을 할 수가 있겠고요

5437
05:57:13,440 --> 05:57:18,615
마찬가지로 곱하기 빼기 나누기 이것도
빠르게 그냥 바로 붙여 넣어 보자면 그래서 이것도

5438
05:57:18,639 --> 05:57:24,140
마찬가지 add 해 봤는데 여기에 뭐 그러면
지금 곱하기 빼기 나누기까지도 해 봤습니다

5439
05:57:24,260 --> 05:57:32,065
그러면 mull도 해 보고 sub도 해 보고 div도 해
본다면 각각 이 4, 2라는 값을 저장된 상태에서

5440
05:57:32,089 --> 05:57:37,920
이 사측 연산을 수행해서 이렇게 각각 사측 연산을
수행해서 수행한 값들이 잘 들어온 것을 확인할 수 있죠

5441
05:57:38,000 --> 05:57:38,440
네

5442
05:57:38,520 --> 05:57:46,520
그러면 이렇게 되면 이제 이 구조가 이미 잡혀 있으니까 다음으로
b라는 계산기를 만들어서 a랑 완전 별도로 처리하고 싶어도 할 수가 있죠

5443
05:57:48,420 --> 05:57:56,420
그래서 여기에 뭐 15 이런 걸 담아도 a 대신에 b를
담아도 이렇게 a랑은 별도로 a는 a대로 나오고 b는

5444
05:57:56,892 --> 05:58:04,892
b대로 나오고 이런 식으로 각각 처리를 인스턴스를
따로따로 뽑아서 얘는 a라는 계산기 얘는 b라는 계산기

5445
05:58:05,460 --> 05:58:06,900
이렇게 이렇게 따로따로 처리할 수가 있겠죠

5446
05:58:07,000 --> 05:58:09,600
그래서 이거는 한 번씩 찍어
보시면 도움이 되실 것 같습니다

5447
05:58:09,740 --> 05:58:10,857
한 줄씩 복사...

5448
05:58:10,881 --> 05:58:18,881
a 선택한 거는 ctrl d 누르면 ctrl d, ctrl d, ctrl d,
ctrl d 하고 여러 개 선택하고 지우고, 바꾸고 할 수가 있습니다

5449
05:58:19,440 --> 05:58:25,300
이렇게 그러면 계산기 설계도가 있으니 여러 개
막 찍어낼 수 있는 그런 설계도를 만들게 된 겁니다

5450
05:58:25,480 --> 05:58:27,680
그래서 이렇게까지 만들어 봤습니다

5451
05:58:27,820 --> 05:58:30,000
그래서 a랑 b 나눠서 이것도 해 봤죠

5452
05:58:30,060 --> 05:58:32,020
그래서 각각 여러 개로 할 수가 있겠습니다

5453
05:58:32,120 --> 05:58:35,436
그러면은 이제 생성자라는 개념을 좀 배워보도록 하겠습니다

5454
05:58:35,460 --> 05:58:37,340
생성자를 왜 쓰냐?

5455
05:58:37,400 --> 05:58:45,400
생성자가 뭔지 한번 알아보자면... 약간 클래스는 설계도긴
한데 그 설계도를 좀 사람들이 잘 쓸 수 있도록 만들어주면 좋겠죠

5456
05:58:46,180 --> 05:58:54,180
이렇게 지금 설계도를 만들었는데 어떤 사람이 그 focal이라는
계산기를 일단 a에 뽑아내고 바로 숫자를 지정해두기도 전에 a.

5457
05:58:56,166 --> 05:58:58,400
Add를 그냥 수행을 해버릴 수도 있겠죠

5458
05:58:58,560 --> 05:59:00,880
이거는 뭐 사용자가 어떻게 사용할지 모르니까

5459
05:59:00,980 --> 05:59:04,477
그래서 이렇게 수행해버리면 실행했을 때 오류가 납니다

5460
05:59:04,501 --> 05:59:05,700
왜 오류가 나냐?

5461
05:59:05,760 --> 05:59:13,760
Focal object has no attribute first라고 나오는데
이게 왜 그러냐면 우리가 setData를 통해서 변수 값들을 저장해줬는데 a

5462
05:59:16,041 --> 05:59:21,080
안에 있는 first와 a 안에 있는 second를
저장을 해줬는데 그 과정이 없죠.

5463
05:59:21,120 --> 05:59:25,020
Add를 호출하니까 이 add 안에서
이게 없기 때문에 지금 오류가 난 겁니다

5464
05:59:25,260 --> 05:59:29,980
그래서 이거는 설계를 좀
잘못했구나라는 걸 좀 느낄 수가 있습니다

5465
05:59:30,160 --> 05:59:36,704
왜냐하면 계산기라는 것은 일단 setData를
한 이후에 무언가를 다 수행해야 되는데

5466
05:59:36,728 --> 05:59:41,980
이 setData를 강제로 강제해주지 않으니까
이렇게 실수하는 경우도 생기는 겁니다

5467
05:59:42,160 --> 05:59:48,292
그래서 처음에 어떤 클래스로 인스턴스를
만들어낼 때 좀 필수적인 것들은 미리 처음

5468
05:59:48,316 --> 05:59:54,420
시작하자마자 입력하는 무언가 있으면
좋겠다라는 생각에 나온 게 생성자라는 개념입니다

5469
05:59:54,560 --> 06:00:01,070
이렇게 생성자를 보면 오류가 안 나게 하고
싶으면 이제 생성자라는 개념을 써서 인스턴스를

5470
06:00:01,094 --> 06:00:05,861
찍어낼 때 무조건 강제로 실행 안 하면
인스턴스 자체가 안 생기게 만들 수가 있습니다

5471
06:00:05,940 --> 06:00:13,940
그래서 이렇게 init이라고 쓰고 앞뒤로 이제 그 언더바 두 개를
밑줄 두 개를 붙여 쓴 이렇게 쓰게 되면 얘는 생성자라는 건데요

5472
06:00:14,820 --> 06:00:21,460
그렇게 되면 이 생성할 때 즉 클래스로부터 인스턴스를
찍어낼 때 무조건 처음에 실행되는 그런 함수입니다

5473
06:00:21,600 --> 06:00:24,300
그래서 이거를 어떻게 쓰냐 일단
이대로 넣어보도록 하겠습니다

5474
06:00:24,600 --> 06:00:31,280
SetData랑 구조는 똑같은데 얘는 init이라는 예약어라고
해서 이제 파이썬에서 좀 지정된 단어들이 좀 있어요

5475
06:00:31,400 --> 06:00:33,676
그래서 init이라고 쓰면 얘는 생성자입니다

5476
06:00:33,700 --> 06:00:39,400
생성자는 무조건 클래스로 인스턴스를 찍어내는
그 시점에 처음으로 일바로 실행되는 거예요

5477
06:00:39,460 --> 06:00:40,860
일바로 무조건 실행이 됩니다

5478
06:00:41,120 --> 06:00:49,120
그렇다는 거는 이제 이 focal을 그냥 실행하려고 했을 때 이 add 자체도
안 쓰고 그냥 인스턴스 찍어내야지 하고 이렇게 실행하자마자 오류가 납니다

5479
06:00:50,320 --> 06:00:54,020
여기 보면 focal init이 일단
이 과정에서 바로 실행이 돼요

5480
06:00:54,120 --> 06:00:56,960
실행이 되는데 missing
two arguments가 없다

5481
06:00:57,100 --> 06:01:04,500
그럼 두 개의 arguments가 왜 필요하냐를 보면은 여기 init이라는
이 처음 생성자에 바로 first, second를 받고 시작을 하죠

5482
06:01:04,540 --> 06:01:10,840
그렇다는 건 클래스로부터 인스턴스를 찍어낼 때 이
조건을 충족하지 못하면 아예 찍어내지 자체를 못합니다

5483
06:01:10,980 --> 06:01:12,700
즉 이렇게 찍어내는 걸 강제하는 거죠

5484
06:01:12,840 --> 06:01:14,280
그래서 어떻게 하냐

5485
06:01:14,420 --> 06:01:20,860
생성자에 들어가는 이 값들은 클래스로부터 인스턴스를
찍어낼 때 이때 초기 값을 이렇게 설정을 해 줄 수가 있습니다

5486
06:01:21,260 --> 06:01:25,818
그러면은 이렇게 찍어내는 이 과정에서
바로 init이 처음으로 실행이 되면서

5487
06:01:25,842 --> 06:01:30,420
여기에 first는 4, second는 2가
돼서 이렇게 초기 값 설정이 됩니다

5488
06:01:30,620 --> 06:01:32,137
이렇게 정리를 해 볼 수 있겠고요

5489
06:01:32,161 --> 06:01:38,260
그리고 self는 그 객체 a라는 그 객체가 그 자체가
들어가고 4, 2 이렇게 매개변수가 들어가게 됩니다

5490
06:01:38,460 --> 06:01:44,240
그래서 init도 마찬가지로 self가 다른 그냥
메서드처럼 들어간다 라고 이해하시면 좋을 것 같고요

5491
06:01:44,320 --> 06:01:52,320
그래서 그 아까 예시로 보여드린 것처럼 이렇게 포칼 처음에
생성할 때부터 그때 받는 값이 이제 그 생성자가 받는 값입니다

5492
06:01:53,000 --> 06:02:01,000
그래서 이거를 받고 시작하면 강제를 해 주는 거기 때문에 생성할 때부터 숫자를
입력 받고 시작하기 때문에 뒤에 있는 거를 오류 없이 수행할 수가 있겠죠

5493
06:02:02,160 --> 06:02:06,080
그래서 기본적인 클래스 그리고
생성자 이런 것들을 배워봤습니다

5494
06:02:06,220 --> 06:02:09,120
약간 어려워... 이제부터 조금 어려워지기 시작했죠

5495
06:02:09,280 --> 06:02:14,400
약간 클래스라는 게 되게 추상적인 개념이라
처음에 배우면 약간 이해가 쉽지는 않습니다

5496
06:02:14,640 --> 06:02:20,720
근데 처음에 설명드렸다시피 엄청나게 막
이걸 빡세게 안 다음에 해야 되지는 않고요

5497
06:02:20,840 --> 06:02:24,560
그냥 사용자로서 뭐 a.first
이런 거 막 가끔 쓸 일 있잖아요

5498
06:02:24,800 --> 06:02:32,136
그래서 이게 무슨 뜻인가라고 하면 a가 그 클래스로
찍어낸 인스턴스고 그리고 .first라는 건 그 a 안에 있는...

5499
06:02:32,160 --> 06:02:39,380
그 first라는 속성을 가져오는 거구나 정도로 그냥 큰 그림만
이해되시면 이렇게 프로그램을 짜는데 큰 무리는 없으실 겁니다

5500
06:02:39,540 --> 06:02:42,740
그 다음에 이제 클래스의 상속에
대해서 배워보도록 하겠습니다

5501
06:02:43,020 --> 06:02:46,480
상속은 그 상속자들에 나오는 그 상속이 맞습니다

5502
06:02:46,620 --> 06:02:48,600
그래서 부모님한테 물려받는 거죠

5503
06:02:48,680 --> 06:02:52,540
부모한테 물려받는 그
inheritance의 그 상속의 개념이 맞고요

5504
06:02:52,640 --> 06:02:54,940
그래서 클래스도 이 개념을 적용할 수가 있는데요

5505
06:02:55,180 --> 06:02:58,860
그래서 클래스를 만들 때 다른
클래스 기능을 물려받을 수도 있습니다

5506
06:02:59,060 --> 06:02:59,500
왜냐?

5507
06:02:59,540 --> 06:03:02,136
클래스를 쉽게 사용하기 위해서 만든 거잖아요

5508
06:03:02,160 --> 06:03:04,620
그래서 계산기를 만들었는데 이런 거 있겠죠

5509
06:03:04,780 --> 06:03:09,300
계산기를 만들었는데 이미 있는
상태에서 공항용 계산기를 만들고 싶어요

5510
06:03:09,380 --> 06:03:12,400
근데 아 이거를 처음부터 또 만들라니 너무 귀찮잖아요

5511
06:03:12,580 --> 06:03:17,563
아 이게 너무 귀찮네 하고 얘를 그냥
물려받아서 그 기본적인 4층 연산을 사용할 수

5512
06:03:17,587 --> 06:03:22,120
있고 그리고 추가적인 기능들을 그것만
개발하면 좋으니까 이렇게 만들 수도 있겠습니다

5513
06:03:22,360 --> 06:03:30,200
이런 식으로 focal이라는 기본 계산기가 있는데 여기에
추가적인 계산기를 각각 상속을 받아서 화살표를 이렇게 표시합니다

5514
06:03:30,380 --> 06:03:32,136
그래서 얘가 부모고 얘네가 부모입니다

5515
06:03:32,160 --> 06:03:32,780
얘가 자식인 거죠

5516
06:03:32,900 --> 06:03:35,940
그래서 부모 거를 4층 연산을 물려받되 뭐 다른 기능

5517
06:03:35,980 --> 06:03:38,960
얘도 4층 연산을 물려받되 얘는 다른 기능 다른 기능

5518
06:03:39,020 --> 06:03:42,400
이런 걸 추가하고 싶다면 이렇게
상속을 받아서 쓸 수가 있습니다

5519
06:03:42,640 --> 06:03:45,920
네 그래서 이 상속을 받는 것을
한번 만들어 보도록 하겠습니다

5520
06:03:46,120 --> 06:03:48,120
그러면 이제 모 focal을 만들어 볼 거예요

5521
06:03:48,280 --> 06:03:52,640
네 focal을 만들었고 굉장히 복잡한
함수인데 이거를 그대로 이용하고 싶어요

5522
06:03:52,740 --> 06:03:54,240
그러려면 굉장히 간단합니다

5523
06:03:54,620 --> 06:04:00,417
자 상속을 받으려면 그 클래스를 만들 때 원래
모 focal하고 여기 focal하고 아무것도 없었죠

5524
06:04:00,441 --> 06:04:03,060
괄호를 열고 여기에 부모를 넣어줍니다

5525
06:04:03,140 --> 06:04:11,140
부모가 여기 들어가면 이 자식 모 focal이라는 자식은 이
부모가 가진 그 클래스의 속성을 다 그대로 이어받습니다

5526
06:04:12,280 --> 06:04:18,174
자 이거를 그러면 수행을 해보면 a
안에 모 focal을 하고 여기에 뭐 a .print

5527
06:04:18,198 --> 06:04:22,960
a.add를 하면 네 모 focal은
패스밖에 없는데 결과가 6이 잘 나오죠

5528
06:04:23,020 --> 06:04:29,277
이게 왜 그러냐면 이 모 focal이라는 이 클래스는 그냥
이렇게 찍어냈지만 여기 안에 이 부모 찬스가 있는 거죠

5529
06:04:29,301 --> 06:04:37,301
그러니까 금수저는 이제 태어나자마자 막 엄청난 재산이 있는 것처럼 그래서
이 focal이라는 부모가 딱 읽어놓은 게 있으니까 이거를 그냥 아무것도 안

5530
06:04:38,081 --> 06:04:44,020
하고 패스만 썼는데도 다 모든 기능을 상속을
받아서 이 모 focal이라는 애가 쓸 수가 있습니다

5531
06:04:44,180 --> 06:04:48,800
그렇다는 거는 이거를 구현을 굳이
자식은 안 해도 다 그냥 갖고 시작하는 거죠

5532
06:04:48,900 --> 06:04:50,820
그래서 이렇게 상속을 받을 수가 있습니다

5533
06:04:51,000 --> 06:04:51,800
굉장히 간단하죠

5534
06:04:51,920 --> 06:04:52,960
그래서 간단합니다

5535
06:04:53,020 --> 06:05:00,820
클래스 이름에 자식 이름에 옆에 괄호 열고 어 우리 부모님이
누구요 라고 하면 그 부모님의 그 재산 이런 것들을 다 물려받습니다

5536
06:05:00,920 --> 06:05:03,280
그래서 굉장히 편하게 물려받을 수가 있습니다

5537
06:05:03,560 --> 06:05:05,800
네 이렇게 똑같이 수행하는 거를 수행해 봤고요

5538
06:05:05,900 --> 06:05:08,920
Add만 해봤는데 당연히 곱하기 빼기 나누기 다 되겠죠

5539
06:05:09,280 --> 06:05:10,580
상속기는 왜 쓰는 걸까?

5540
06:05:10,620 --> 06:05:11,420
너무 상식적이죠

5541
06:05:11,480 --> 06:05:14,100
그냥 만들어 놓은 게 있으니까
아까우니까 가져다 쓰는 겁니다

5542
06:05:14,540 --> 06:05:17,600
그러면 이제 자식이 새로운 걸 만들 수도 있겠죠

5543
06:05:17,700 --> 06:05:22,820
당연히 부모를 싹 상속받은 다음에 부모가
못하는 어떤 것을 추가로 할 수도 있겠죠

5544
06:05:22,960 --> 06:05:24,960
그래서 그거를 해보도록 하겠습니다

5545
06:05:25,440 --> 06:05:26,817
어 부모님 바뀔 수도 있겠네요

5546
06:05:26,841 --> 06:05:27,480
아 맞아요

5547
06:05:27,580 --> 06:05:28,580
부모님 바뀔 수 있죠

5548
06:05:28,680 --> 06:05:31,340
괄호 안에 어떤 부모를 넣느냐에 따라 다르죠

5549
06:05:31,460 --> 06:05:37,097
그러니까 여기 안에 포칼을 넣으면 이제 포칼의
자식이 되는 건데 뭐 다른 부모가 있으면 이 다른

5550
06:05:37,121 --> 06:05:42,060
부모를 넣으면은 네 이렇게 부모를 바꾸면은
그 부모를 이제 상속받아서 그걸 쓸 수가 있겠죠

5551
06:05:42,220 --> 06:05:45,500
아무튼 이제 모포칼의 좀 본연의 기능을 만들어 보겠습니다

5552
06:05:46,000 --> 06:05:52,780
그럼 자식을 만들었는데 이 부모를 상속받긴 했지만
네 부모 상속 말고도 다른 기능을 추가할 수도 있겠죠

5553
06:05:52,920 --> 06:05:56,580
그래서 여기는 파워 그 제곱을 한번 추가를 해봤습니다

5554
06:05:56,840 --> 06:06:00,876
그러면 제곱은 첫 번째에 이 별 두 개 기억나시나요

5555
06:06:00,900 --> 06:06:04,600
이게 첫 시간인가 두 번째 시간쯤에
배웠는데 별 두 개면 제곱이죠

5556
06:06:04,720 --> 06:06:08,660
퍼스트 예를 들어 이게 4하고
2면은 4에 2승 이렇게 하는 거죠

5557
06:06:08,780 --> 06:06:14,480
4 곱하기 4니까 16이 되고 뭐 이런 게 별 두
개인데 이 파워라는 거는 이제 부모한테는 없는 거예요

5558
06:06:14,960 --> 06:06:16,120
자식한테만 추가해줬습니다

5559
06:06:16,260 --> 06:06:21,280
네 그러면 어떻게 되냐 네 자식은 뭐 add도
쓸 수 있는데 이 파워도 쓸 수가 있습니다

5560
06:06:21,500 --> 06:06:25,617
그래서 한번 이대로 실행을 해보면
add는 그 부모한테 온 기능이죠.

5561
06:06:25,641 --> 06:06:31,720
Add를 쓰기도 썼는데 자기가 가지고 있는
이 파워 본인이 만든 거를 또 쓸 수도 있습니다

5562
06:06:31,860 --> 06:06:36,540
얘는 맞아요 선천적인 능력이 add
파워는 후천적인 개발한 능력이죠

5563
06:06:36,660 --> 06:06:40,940
그래서 이렇게 선천적과 후천적을 모두
쓸 수 있는 게 이제 상속의 기능입니다

5564
06:06:41,420 --> 06:06:44,360
그다음에 메서드 오버라이딩이라는 게 있습니다

5565
06:06:44,560 --> 06:06:46,060
사실 그런 경우 있죠

5566
06:06:46,160 --> 06:06:48,460
막 부모님이 막 뭐 회장님이에요 회장

5567
06:06:48,540 --> 06:06:52,960
이제 자식이 그 회사를 물려받을 수
있는데 다른 길로 가고 싶을 수 있죠

5568
06:06:53,060 --> 06:06:54,440
저는 이 회사 필요 없습니다

5569
06:06:54,660 --> 06:06:55,616
군인이 되고 싶습니다

5570
06:06:55,640 --> 06:06:57,480
그래서 갑자기 뭐 군대에 간다던가 할 수도 있겠죠

5571
06:06:57,620 --> 06:06:59,760
그래서 그게 이제 오버라이딩의 개념입니다

5572
06:06:59,880 --> 06:07:02,680
부모님이 막 뭘 물려줬는데 그걸 뒤엎어요

5573
06:07:02,760 --> 06:07:04,160
그래서 약간 그런 말 있잖아요

5574
06:07:04,380 --> 06:07:05,660
자식 이기는 부모 없다

5575
06:07:05,800 --> 06:07:09,420
이런 말 있는 것처럼 하고 싶은 게 있으면 자식이 이깁니다

5576
06:07:09,480 --> 06:07:12,440
그래서 자식이 부모가 준 거를 덮어 씌울 수가 있어요

5577
06:07:12,780 --> 06:07:16,357
이게 말 그대로 오버라이딩 그러니까 올라탄다의 개념이잖아요

5578
06:07:16,381 --> 06:07:16,936
라이딩이

5579
06:07:16,960 --> 06:07:19,680
그러니까 부모님이 뭔가를 줬는데 그거에 올라타요

5580
06:07:19,780 --> 06:07:21,440
그래서 얘를 다 바꿔버려요

5581
06:07:21,540 --> 06:07:23,120
이걸 한번 구현을 해보도록 하겠습니다

5582
06:07:23,960 --> 06:07:29,220
모포칼이라는 자식이 있는데 얘가 4하고
0을 넣었다고 해보고 a.div를 해볼게요.

5583
06:07:29,360 --> 06:07:34,020
Div가 뭐냐면 나누기인데 0으로
나누는 이런 행위를 한번 해볼게요

5584
06:07:34,160 --> 06:07:35,240
이렇게 오류가 납니다

5585
06:07:35,540 --> 06:07:36,540
Division by 0

5586
06:07:36,640 --> 06:07:39,040
0으로 나누면 안 된다고 오류가 났죠

5587
06:07:39,120 --> 06:07:43,900
왜냐하면 부모의 div라는 게 0으로
나눈 거를 그냥 허용을 해버렸어요

5588
06:07:44,000 --> 06:07:48,520
그렇기 때문에 자식이 그걸 그대로 물려받았으니
이 자식이 수행하면 똑같은 오류가 나겠죠

5589
06:07:48,680 --> 06:07:52,997
그러면 이제 부모는 이런 걸 물려줬지만 자식은 그걸 뒤엎고

5590
06:07:53,021 --> 06:07:54,540
새로운 걸 만들 수도 있습니다

5591
06:07:54,660 --> 06:07:59,580
그래서 새로운 걸 만들자면 이런 식으로
세이프포칼이라는... 이걸 새로 만들어 볼게요

5592
06:07:59,660 --> 06:08:00,660
이렇게 클래스를

5593
06:08:01,460 --> 06:08:03,740
세이프포칼이라는 자식은 다른 자식이죠

5594
06:08:03,900 --> 06:08:04,360
맞습니다

5595
06:08:04,640 --> 06:08:08,060
모포칼이라는 자식도 있고
세이프포칼이라는 자식도 부모는 같아요

5596
06:08:08,280 --> 06:08:09,360
부모는 다 포칼입니다

5597
06:08:09,580 --> 06:08:12,540
이 다른 자식은 div를 부모님 걸 똑같이 썼어요

5598
06:08:12,660 --> 06:08:13,880
그러니까 부모랑 싸우는 거죠

5599
06:08:14,060 --> 06:08:15,720
E.div도 있고 e.div도 있어요

5600
06:08:15,840 --> 06:08:16,836
그럼 누가 이기느냐

5601
06:08:16,860 --> 06:08:17,700
자식이 이깁니다

5602
06:08:17,760 --> 06:08:18,660
부모가 집니다

5603
06:08:18,780 --> 06:08:22,457
이 세이프포칼이 div를 호출하면 자기 div를 호출합니다

5604
06:08:22,481 --> 06:08:23,740
부모 꺼는 버리고요

5605
06:08:23,780 --> 06:08:24,800
그래서 이렇게 됩니다

5606
06:08:25,000 --> 06:08:29,720
그러면 모브 포칼 말고 세이프 포칼로
마찬가지 똑같이 호출하면은 디브를 썼잖아요

5607
06:08:29,860 --> 06:08:30,140
디브

5608
06:08:30,200 --> 06:08:31,520
실행해보면 0이 나옵니다

5609
06:08:31,600 --> 06:08:33,760
아까는 오류가 났는데 0이 나왔어요

5610
06:08:33,860 --> 06:08:36,820
포칼을 상속받았지만 디브를 새롭게 정의했어요

5611
06:08:37,160 --> 06:08:44,520
나는 이 디브를 오류 안 나는 디브로 만들 거야 하고 if문을
추가해서 0으로 나누는 값이 나오면 0을 무조건 리턴한다를 추가했어요

5612
06:08:44,700 --> 06:08:47,120
그랬더니 이제 이 디브가 이긴 거죠

5613
06:08:47,280 --> 06:08:54,500
그래서 부모 꺼를 물려받았지만 이때 수행했을 때 자식의 디브가
호출되면서 오류가 안 나고 0이 잘 나온 것을 확인할 수 있겠습니다

5614
06:08:54,680 --> 06:08:54,900
네

5615
06:08:54,980 --> 06:08:56,180
이거 이해가 되시나요?

5616
06:08:56,240 --> 06:08:59,940
부모랑 자식이 싸우면 자식이
이긴다라고 이해하시면 좋을 것 같습니다

5617
06:09:00,100 --> 06:09:02,960
그게 이제 이름을 메서드 오버라이딩이라고 부릅니다

5618
06:09:03,060 --> 06:09:06,820
부모 꺼를 오버라이드해서 덮어 씌운다라는 개념입니다

5619
06:09:06,960 --> 06:09:08,140
그래서 이렇게 해봤고요

5620
06:09:08,220 --> 06:09:10,056
그러면은 이제 또 새로운 개념

5621
06:09:10,080 --> 06:09:12,000
클래스 변수라는 것도 있습니다

5622
06:09:12,220 --> 06:09:16,120
그 클래스라면 공통적으로 갖고 있는 변수를 만들고 싶어요

5623
06:09:16,200 --> 06:09:17,440
예를 들어 이런 게 있겠죠

5624
06:09:17,600 --> 06:09:18,600
그 패밀리

5625
06:09:18,720 --> 06:09:26,720
김씨 집안 클래스를 만든다고 하면은 그 김씨 집안은
공통적으로 자식을 아무리 많이 낳고 여기서는 좀 자식보다는

5626
06:09:27,240 --> 06:09:35,240
인스턴스일 텐데 설계도를 설계할 때 김씨 패밀리 설계도를
만들었다면 김씨 패밀리로 찍어내는 모든 애들은 다 김씨겠죠

5627
06:09:36,160 --> 06:09:42,580
그래서 이런 것처럼 클래스 변수라고 해서 모든
애들이 공통적으로 갖고 있는 값을 정해줄 수가 있습니다

5628
06:09:42,780 --> 06:09:49,277
예를 들어 아까 계산기에서는 지금 여기 퍼스트
세컨드가 각각 찍어낼 때마다 다른 값이 들어갈 수 있잖아요

5629
06:09:49,301 --> 06:09:57,301
B를 찍어낼 때는 여기엔 뭐 O, E 이렇게 들어가도 되고 얘네는 퍼스트
세컨드 이 각각의 객체 안에 있는 변수들은 다 다른 값이 들어갈 수가 있어요

5630
06:09:58,760 --> 06:10:06,760
이렇게 공통된 값을 만들려면 여기에 김씨 이런 걸 만들려면 이런
식으로 객체 변수가 아닌 클래스 차원에서의 변수를 만들어줄 수도 있습니다

5631
06:10:07,600 --> 06:10:10,460
그래서 클래스 변수를 한번 만들어 보도록 하겠습니다

5632
06:10:10,960 --> 06:10:11,100
네

5633
06:10:11,160 --> 06:10:16,000
라스트 네임이라는 그 변수는
이제 얘는 셀프 뭐 이런 거 안 써 있죠

5634
06:10:16,120 --> 06:10:19,276
그렇다는 건 각각의 객체한테 들어가 있는 변수들

5635
06:10:19,300 --> 06:10:22,080
변수가 아니라 클래스 공통으로 지는 변수입니다

5636
06:10:22,810 --> 06:10:24,920
그래서 이걸로 그러면 찍어내 보겠습니다

5637
06:10:25,200 --> 06:10:27,740
패밀리로 A라는 사람을 찍어내 볼게요

5638
06:10:27,880 --> 06:10:29,840
B라는 사람도 찍어냈습니다

5639
06:10:30,650 --> 06:10:38,650
그때 이제 A.래스트 네임이랑 B.래스트
네임을 호출을 해보면 얘는 똑같이 김, 김이 나오죠

5640
06:10:39,420 --> 06:10:41,960
A, B는 완전히 다른데 김, 김이 나옵니다

5641
06:10:42,040 --> 06:10:49,276
그래서 이렇게 완전히 다른 인스턴스더라도 동일한
클래스로 찍어냈을 때 동일한 값을 얻어낼 수 있습니다

5642
06:10:49,300 --> 06:10:57,300
A래스트 네임을 갖고 싶다면 셀프 이렇게 쓰는 건 각각의 객체가
가진 거고 클래스 공통으로 쓰고 싶다면 클래스 변수를 사용하면 됩니다

5643
06:10:57,680 --> 06:10:58,820
개명도 할 수 있습니다

5644
06:10:58,960 --> 06:11:04,500
당연히 이제 각각 인스턴스들은
본인이 받은 거를 수정할 수 있어요

5645
06:11:04,620 --> 06:11:05,500
예를 들어 이런 거죠

5646
06:11:05,620 --> 06:11:08,340
A의 래스트 네임을 박씨 이렇게 바꿔볼게요

5647
06:11:08,460 --> 06:11:11,300
이렇게 하고 호출하면 이제 박씨로 바뀌었어요

5648
06:11:11,460 --> 06:11:14,860
각각 자식들은 바꿀 수 있는데 개명할 수 있잖아요 우리도

5649
06:11:14,940 --> 06:11:19,276
그렇다고 이 패밀리 집안에 ABC가
있는데 한 명이 개명한다고요?

5650
06:11:19,300 --> 06:11:21,440
그래서 ABC가 다 개명되지는 않죠

5651
06:11:21,480 --> 06:11:27,120
A만 이렇게 개명하면은 당연히 A만
박으로 바뀌고 나머지는 다 김씨겠죠

5652
06:11:27,320 --> 06:11:28,400
근데 이럴 수는 있어요

5653
06:11:28,600 --> 06:11:34,060
아예 그 패밀리 클래스 자체를 바꿔버리면
클래스를 예를 들어 조씨 클래스로 바꿀게요

5654
06:11:34,160 --> 06:11:39,400
패밀리 자체를 바꾸면 당연히 이
패밀리로 찍어낸 ABC 모두가 다 조씨겠죠

5655
06:11:39,580 --> 06:11:43,460
얘는 A는 바꿔치기 했으니까 A만
박시고 조조가 나오게 되겠습니다

5656
06:11:43,860 --> 06:11:46,380
이렇게 하는 게 이제 클래스 변수라고 부릅니다

5657
06:11:46,500 --> 06:11:48,037
그래서 이거를 해봤습니다

5658
06:11:48,061 --> 06:11:50,560
이렇게 바꿔치기 하는 것도 실습을 해봤습니다

5659
06:11:50,620 --> 06:11:53,780
네 이렇게 해서 이제 클래스를 모두 다 배워봤습니다

5660
06:11:53,920 --> 06:11:59,480
그래서 약간은 어려울 수 있는데 그
비유적인 개념인 이 과자틀, 과자가 객체다

5661
06:11:59,520 --> 06:12:06,653
이 정도만 이해하시고 이거를 뭐 각각
객체별로 점 뭐 해서 호출해서 쓰고 점 메소드 해서

5662
06:12:06,677 --> 06:12:12,340
쓰고 이 정도의 개념만 이해하셔도 충분히
이번 클래스를 잘 배운 거다라고 할 수 있겠습니다

5663
06:12:12,760 --> 06:12:16,377
네 그다음에 모듈 패키지는 사실 만들 일이 없어요

5664
06:12:16,401 --> 06:12:22,467
그러니까 모듈을 직접 아 나는 모듈 개발자가 될
거야가 아닌 이상 모듈을 사용하는 입장이지 모듈을

5665
06:12:22,491 --> 06:12:27,300
만들 일은 잘 없기 때문에 네 모듈 패키지는
좀 사용자 관점에서 수업을 해보도록 하겠습니다

5666
06:12:27,420 --> 06:12:30,180
함수나 변수 또는 클래스를 모아놓은 파이썬 파일입니다

5667
06:12:30,320 --> 06:12:34,957
이것도 어떻게 보면 클래스랑 비슷한데
클래스는 이렇게 만들어 놓고 찍어내는

5668
06:12:34,981 --> 06:12:39,980
개념이었다면 모듈은 어떤 파일을 만들었으면
이 파일을 그냥 불러와서 쓰는 개념이에요

5669
06:12:40,080 --> 06:12:41,980
이게 직접 보면서 배워보도록 하겠습니다

5670
06:12:42,220 --> 06:12:44,900
네 그러면은 이거 모듈 하나 만들어 볼게요

5671
06:12:45,000 --> 06:12:46,376
네 모드 1이라는 파일입니다

5672
06:12:46,400 --> 06:12:47,000
이렇게 파일을 만들었어요

5673
06:12:47,100 --> 06:12:51,943
그리고 그러면 이렇게 파일 안에
함수들을 쫙 만들어 놓은 다음에 이거를 어디

5674
06:12:51,967 --> 06:12:56,640
저장해 놨다가 그 새로 파일을 만들었는데
여기서 불러와서 쓰고 싶을 수도 있겠죠

5675
06:12:56,780 --> 06:12:59,220
그래서 그럴 때 사용하는 게 이 모듈의 개념입니다

5676
06:12:59,380 --> 06:13:03,300
그래서 모듈 불러오기를 해보면
모듈 불러오기 모듈 파일이 여기 있죠

5677
06:13:03,380 --> 06:13:06,560
여기에 add 더하기랑 빼기 함수를 만들어 놨어요

5678
06:13:06,620 --> 06:13:09,420
만들어 놨는데 여기서는 아 이걸 또 만들기 귀찮아요

5679
06:13:09,520 --> 06:13:13,740
그냥 누가 만들어 놓은 함수가 있으니까
얘를 갖다 쓰고 싶다라고 한다면 어떻게 하냐

5680
06:13:13,800 --> 06:13:14,800
네 import.

5681
06:13:15,380 --> 06:13:18,780
Import라는 명력을 쓰고 모드 1이라는 이 파일명 있죠

5682
06:13:18,900 --> 06:13:20,020
이거를 여기 써줍니다

5683
06:13:20,100 --> 06:13:22,780
그러면 이 파일 자체를 가져오는 효과가 납니다

5684
06:13:22,920 --> 06:13:25,400
진짜 이렇게 가져와서 그 파일을 가지고 있는 거예요

5685
06:13:25,500 --> 06:13:29,100
그렇다는 건 이제 모드 1에 있는
add란 함수를 쓸 수가 있습니다

5686
06:13:29,300 --> 06:13:34,633
그래서 모드 1.add를 하면 이렇게 34
add라는 걸 우리가 정의를 안 했는데도

5687
06:13:34,657 --> 06:13:38,760
그냥 가져와서 실제로 3 더하기 4인
7 값을 잘 출력하는 걸 볼 수가 있죠

5688
06:13:38,880 --> 06:13:44,477
즉 이렇게 모듈을 만들어진 게 있으면 이거를
import라는 걸로 가져와서 그걸 쓰면 되는 겁니다

5689
06:13:44,501 --> 06:13:48,740
파일의 사용은 클래스이고 별도
파일을 관리하는 건 모듈인가요?

5690
06:13:48,840 --> 06:13:51,840
근데 이 모듈 안에도 클래스를 넣어 놓을 수가 있습니다

5691
06:13:51,980 --> 06:13:53,260
그렇게 구분하기는 어렵고요

5692
06:13:53,340 --> 06:13:59,155
파일 자체를 가져와서 그 안에 있는 뭐
클래스니 함수니 변수니 이런 거를 쓸 수 있는 것이

5693
06:13:59,179 --> 06:14:03,861
모듈이고 클래스는 어떤 설계도고 그걸
인해서 여러 개를 찍어낼 수 있다면 클래스입니다

5694
06:14:04,020 --> 06:14:06,220
그렇게 좀 다르게 구분을 할 수가 있겠습니다

5695
06:14:06,440 --> 06:14:08,000
그래서 얘는 설계도는 아니잖아요

5696
06:14:08,220 --> 06:14:12,678
예를 들어 모드 1을 막 이렇게 여러 개를
한다고 해서 이 34라는 게 어딘가에 저장되고

5697
06:14:12,702 --> 06:14:16,880
쓰고 이런 개념이 아니라 그냥 만들어진 걸
불러와서 쓰는 개념이라서 조금은 다릅니다

5698
06:14:16,980 --> 06:14:24,980
클래스는 인스턴스를 찍어낼 때 공장같이 이렇게 여러 개 객체를 만들어
놓을 때 쓰는 거고 모듈은 그냥 가져와서 거기 있는 코드를 쓰겠다 이겁니다

5699
06:14:25,520 --> 06:14:29,760
그래서 약간은 어려울 수 있지만
사용자의 관점에서만 이해해도 충분합니다

5700
06:14:29,920 --> 06:14:31,180
완벽하게 이해할 필요는 없습니다

5701
06:14:31,800 --> 06:14:37,520
그래서 import 모듈 이름 이렇게 가볍게 가져와서
거기 있는 파일 안에 있는 것들을 다 쓸 수가 있고요

5702
06:14:37,680 --> 06:14:39,280
그래서 이런 식으로 쓸 수도 있어요

5703
06:14:39,700 --> 06:14:43,597
그 from 모듈 이름 import
함수 이렇게도 쓰는데 이건 뭐죠?

5704
06:14:43,621 --> 06:14:45,037
아까와 뭐가 심각한 건aksi방 как 씁니다

5705
06:14:45,061 --> 06:14:45,280
아까와 뭐가 다르냐?

5706
06:14:45,320 --> 06:14:53,320
모듈 1이라는 파이썬 파일에서 가져와서 import
add라는 건 add라는 함수만 가져오겠다는 것입니다

5707
06:14:54,000 --> 06:14:59,160
그렇다는 것은 이 모듈 1에서는 add를
가져왔으니까 이거 자체를 바로 쓸 수가 있어요

5708
06:14:59,300 --> 06:15:04,040
그래서 modeone을 쓸 필요도
없고 이걸 지워도 쓸 수가 있습니다

5709
06:15:04,560 --> 06:15:08,580
이것만으로 add를 가져왔기 때문에
mode 1에 add라는 함수가 있죠

5710
06:15:08,680 --> 06:15:11,060
그래서 이 함수 자체를 import 한 것입니다

5711
06:15:11,140 --> 06:15:13,596
그렇기 때문에 이렇게 바로 쓸 수가 있습니다

5712
06:15:13,620 --> 06:15:16,400
그러면 서브를 불러오면 어떻게 될까요?

5713
06:15:16,560 --> 06:15:17,560
이렇게 되겠죠

5714
06:15:17,660 --> 06:15:22,300
너는 add만 지금 지명해서 가져왔는데
서브는 안 가져왔는데 왜 쓰려고 그래?

5715
06:15:22,380 --> 06:15:23,460
하고 오류가 납니다

5716
06:15:23,600 --> 06:15:24,380
즉, 모릅니다

5717
06:15:24,480 --> 06:15:25,000
서브가 뭐야?

5718
06:15:25,140 --> 06:15:27,200
라고 서브 is not defined라고 나오죠

5719
06:15:27,260 --> 06:15:28,260
그래서 이렇게 됩니다

5720
06:15:28,420 --> 06:15:30,640
그래서 add만 가져오고 이럴 수가 있습니다

5721
06:15:30,960 --> 06:15:32,440
너무 많은 것들이 있다

5722
06:15:32,520 --> 06:15:35,620
그러면 이렇게 하나씩 필요한 기능만 가져올 수도 있겠죠

5723
06:15:36,080 --> 06:15:37,600
그래서 이렇게 할 수가 있겠습니다

5724
06:15:37,960 --> 06:15:40,537
두 개 가져오려면 이렇게
콤마로 연결해서 두 개 쓰면 되겠죠

5725
06:15:40,561 --> 06:15:43,740
Add 콤마 서브 이렇게 하면 둘
다 가져와서 쓸 수가 있겠습니다

5726
06:15:43,880 --> 06:15:47,300
그러면 이제 정상적으로 둘 다
다 잘 수행한 것을 볼 수가 있죠

5727
06:15:47,380 --> 06:15:48,760
그 다음에 이런 경우가 있습니다

5728
06:15:48,960 --> 06:15:51,660
예를 들어 모드원이라는 파일을 만드는 분도 있을 거잖아요

5729
06:15:51,800 --> 06:15:56,280
그래서 모듈을 만드시는 분이 이거를
만드는데 여기서 뭔가 실행을 해보고 싶어요

5730
06:15:56,360 --> 06:16:03,509
그래서 모드원에서 한번 실행을 해보자 하고
print add 이렇게 해서 뭔가 add를 여기 모드원 안에서

5731
06:16:03,533 --> 06:16:11,280
쓰면은 이렇게 실행하면 모드원에서는 이렇게 3 해가지고
출력해서 볼 수가 있는데 이거를 남겨놓으면은 어떻게 되냐?

5732
06:16:11,340 --> 06:16:18,780
딴 데서 이 모드원을 사용하려고 이렇게 import만
했을 뿐인데 이걸 실행하면 갑자기 3이 나옵니다

5733
06:16:18,860 --> 06:16:19,380
그래서 어?

5734
06:16:19,440 --> 06:16:22,120
나 import만 했는데 왜 3이 나오지?

5735
06:16:22,160 --> 06:16:28,720
라고 생각해보면 모드원을 이제 개발하신 분이 이런 걸
남겨놨으면 불러오는 것만으로도 이렇게 막 찍혀 버리겠죠

5736
06:16:28,860 --> 06:16:33,760
이런 거를 좀 구분할 필요가 있겠다 라는
니즈로 인해 생겨난 게 뭐냐면 이런 게 있습니다

5737
06:16:33,980 --> 06:16:39,790
Underbar underbar name이 메인일
때 이 조건문을 하나 달아서 이 조건문

5738
06:16:39,814 --> 06:16:45,520
아래쪽에 써주게 되면 이 name이라는 게
메인일 때만 이걸 실행해라 라고 적은 게 되겠죠

5739
06:16:45,620 --> 06:16:51,500
이거를 실행했을 때는 지금 3이라고 나오는데
5-2에서 실행했을 때 얘는 다른 파일이죠

5740
06:16:51,580 --> 06:16:54,420
다른 파일에서 실행했을 때는 아무것도 안 나옵니다

5741
06:16:54,520 --> 06:17:02,520
이렇게 name은 메인이라고 같은지 검사를 하는 걸 추가해주고 그
아래에 적게 되면 이제 외부에서 호출할 때는 이게 수행이 안 되는 거죠

5742
06:17:03,620 --> 06:17:07,020
그래서 이거를 좀 더 구체적으로 보자면
아예 프린트로 name을 찍어보겠습니다

5743
06:17:07,380 --> 06:17:08,576
그럼 이 name이 뭐냐?

5744
06:17:08,600 --> 06:17:09,157
이 name.

5745
06:17:09,181 --> 06:17:13,600
Underbar underbar 들어간 거 이런 거는
좀 예약어에 속하는데 미리 정해진 값이죠

5746
06:17:13,720 --> 06:17:20,140
그래서 이거를 한번 실제로 출력을 해보면 이렇게 지금
mode1에서 실행할 때는 실제로 main이라는 게 나옵니다

5747
06:17:20,200 --> 06:17:25,340
즉 이거를 실행할 때 이 파일이
main으로 실행하고 있어라는 그런 뜻이고요

5748
06:17:25,440 --> 06:17:30,960
그리고 5-2에서 실행할 때는 main이
아닌 mode1이라고 나오게 됩니다

5749
06:17:31,160 --> 06:17:37,148
이 name은 그 파일 자체를 실행할
때는 main이라고 수행이 되는데 5-2에서

5750
06:17:37,172 --> 06:17:41,880
호출 그냥 불러올 때는 다른 지금
mode1이라는 값이 여기 찍혔습니다

5751
06:17:41,980 --> 06:17:45,880
그렇다는 거는 이게 if문이 일치하지
않아서 이 아래쪽이 수행이 안 되겠죠

5752
06:17:46,040 --> 06:17:48,580
네, main이 현 페이지에서 main을 의미합니다

5753
06:17:48,680 --> 06:17:48,920
맞습니다

5754
06:17:49,080 --> 06:17:54,580
그래서 이 파일을 실행할 때만 이 name 값이
main으로 실행이 돼서 이 코드가 실행됩니다

5755
06:17:54,720 --> 06:18:00,467
그래서 이 모듈 안에서의 뭔가 코드 중에
이렇게 해놓는다면 그 모듈 자체를 실행할

5756
06:18:00,491 --> 06:18:05,360
때만 이거를 수행할 수 있고 외부에서
불러올 때는 얘가 수행이 안 될 수 있겠죠

5757
06:18:05,500 --> 06:18:08,597
그래서 이런 것도 사용이 된다라고 알 수가 있겠습니다

5758
06:18:08,621 --> 06:18:11,920
근데 이거는 사실은 막 좀 어려우면
몰라도 되는 개념이긴 합니다

5759
06:18:12,080 --> 06:18:15,020
이거를 뭐 모듈을 직접 만들 일이 얼마나 있겠어요

5760
06:18:15,140 --> 06:18:17,220
그냥 보통 그냥 가져다 쓰는 행위를 많이 하지

5761
06:18:17,340 --> 06:18:23,940
그래서 이거는 좀 지적 허용심에 가깝지만 그래도
알아놓으면 그냥 뭐 재미있게 배울 수 있는 그런 거일 수 있겠죠

5762
06:18:24,560 --> 06:18:26,440
그래도 이해 안 된다면 그냥 넘어가셔도 됩니다

5763
06:18:26,560 --> 06:18:27,240
이 정도는

5764
06:18:27,340 --> 06:18:34,000
그래서 이렇게 할 수가 있겠고 뭐 name 변수에 대해 나오는데
name 변수는 파이썬이 내부적으로 사용되는 특별한 변수입니다

5765
06:18:34,120 --> 06:18:38,280
그래서 이거를 그 underbar, underbar
이렇게 들어간 건 좀 특별한 거예요

5766
06:18:38,620 --> 06:18:46,620
모듈이 지정된 거 그 직접 이 파일을 실행할 경우에는 메인이 되고
아니면 다른 파이썬 모듈에서 불러오면 그때는 그 모듈의 이름이 들어갑니다

5767
06:18:46,800 --> 06:18:48,620
그래서 이렇게 쓸 수가 있겠습니다

5768
06:18:48,780 --> 06:18:51,400
그래서 클래스나 변수를 포함한 모듈

5769
06:18:51,480 --> 06:18:58,860
그러니까 모듈이 그냥 코드 뭉치라고 말씀드렸는데 그 코드
뭉치 안에 뭐 변수도 있을 수 있겠고 클래스도 있을 수 있겠죠

5770
06:18:58,980 --> 06:19:01,640
그래서 그런 거를 한번 빠르게 보도록 하겠습니다

5771
06:19:01,900 --> 06:19:06,060
그래서 모드2를 만들어 보면 그
뭐 파이라는 변수도 만들었고요

5772
06:19:06,360 --> 06:19:07,677
클래스도 만들었습니다

5773
06:19:07,701 --> 06:19:15,701
그래서 굉장히 많은 걸 만들었는데 이거를 모드2를 실행을
해보면 좀 나눠서 모드2를 불러와서 그러면 이렇게 할 수도 있어요

5774
06:19:16,660 --> 06:19:24,660
뭐 마찬가지로 아까랑 거의 연장선인데 이거를 실행해보면 당연히 이 모드2
거 이 변수를 가져왔으니까 모드2.파이는 여기에 저장된 이 파이 값이 나오겠죠

5775
06:19:26,980 --> 06:19:30,200
그리고 마찬가지로 이 클래스도 쓸 수 있습니다

5776
06:19:30,380 --> 06:19:38,380
그래서 클래스도 불러오는 거를 그대로 쓰면 모드라는 거 안에
이렇게 코드 뭉치가 있으니까 여기 있는 걸 그냥 쑥 뽑아와서 모드2

5777
06:19:39,348 --> 06:19:45,580
Math라는 거는 Math라는 클래스가 여기 써져 있으니까
여기에 인스턴스를 이제 a에 저장하는 꼴이 되겠죠

5778
06:19:45,660 --> 06:19:50,640
이 a.solve를 하면은 요거를
수행해서 요걸 호출할 수가 있겠죠

5779
06:19:50,800 --> 06:19:56,840
그래서 이렇게 모듈로 만들어 놓은 거를 그대로 불러와서
사실상 이 코드가 여기 그대로 있는 거랑 마찬가지입니다

5780
06:19:56,960 --> 06:20:03,860
근데 이렇게 모듈로 구분을 해 놓으면 어느 모듈에서 불러왔는지
이렇게 좀 명시적으로 보여주니까 이렇게 좀 편할 수가 있겠죠

5781
06:20:04,020 --> 06:20:06,096
그래서 이런 개념이다라고 얘기했습니다

5782
06:20:06,120 --> 06:20:06,780
이해하시면 좋을 것 같습니다

5783
06:20:07,000 --> 06:20:15,000
네 이거 지금까지 여기 위에서는 그 파이썬 바로 실행하는 그 레펠
방식으로 했는데 이제 파일에서 불러오는 거를 저희는 해 봤습니다

5784
06:20:15,860 --> 06:20:18,060
그래서 파일에서 불러오는 거 이렇게 해 봤고요

5785
06:20:18,160 --> 06:20:21,080
아 네 다른 디렉터리는 이게 못 찾는 경우가 있습니다

5786
06:20:21,240 --> 06:20:21,820
어떤 거냐

5787
06:20:21,860 --> 06:20:29,860
우리는 지금 챕터5 안에다가 파일을 싹 다 때려 박았기 때문에 아는데
예를 들어 이 파일을 막 전혀 다른 데다 저장해 놨으면 파이썬도 모르겠죠

5788
06:20:31,160 --> 06:20:34,477
어 내가 찾으려고 하는데 예를
들어 모드3를 한번 만들어 볼게요

5789
06:20:34,501 --> 06:20:42,501
그리고 이걸 그대로 가져오면 그럼 5-2에서 모드3를 불러오고
얘도 모드3를 불러오려고 하니까 이걸 실행해 보면 실행이 될까요

5790
06:20:44,180 --> 06:20:45,200
어 안 되네요

5791
06:20:45,280 --> 06:20:49,840
어 안 되는 이유가 모드3가 어디 있는 거야 라고 못 찾죠

5792
06:20:49,900 --> 06:20:55,900
왜냐하면 지금 우리가 실행하는 파일은
이 5-2.파이 이건데 지금 폴더 바깥에 있죠

5793
06:20:55,980 --> 06:20:57,880
바깥에 지금 모드3가 여기 있습니다

5794
06:20:58,060 --> 06:21:04,457
그렇기 때문에 import 모드3가 완전 마법은
아닌 게 얘가 모드3가 어디 있는데 라고 안 알려주면

5795
06:21:04,481 --> 06:21:05,200
당연히 모르겠죠

5796
06:21:05,340 --> 06:21:08,660
이 뭐 전체를 뒤져서 막 모드3에 찾아올 수가 없으니까요

5797
06:21:08,700 --> 06:21:13,800
네 그렇다는 거는 이 모드3를 찾기 위해서는
어디에 모드3가 있다는 걸 알려주는 과정이 필요합니다

5798
06:21:13,960 --> 06:21:16,240
그래서 그걸 어떻게 알려주는지 보도록 하겠습니다

5799
06:21:16,500 --> 06:21:24,300
네 알려주려면 이렇게 그 시스템을
시스템이라는 거 이거 지난 시간에 한번 써봤죠

5800
06:21:24,400 --> 06:21:27,360
그래서 시스템이라는 모듈도 마찬가지로 파이썬 파일입니다

5801
06:21:27,560 --> 06:21:31,620
그래서 이걸 이용해서 system. Path
안에 여러 가지 경로가 들어가 있어요.

5802
06:21:31,760 --> 06:21:34,137
System. Path라는 게 이제 리스트인데

5803
06:21:34,161 --> 06:21:38,380
여기에 더해주게 되면 파일의 위치를
그 위치를 그제서야 찾을 수가 있습니다

5804
06:21:38,580 --> 06:21:40,380
그래서 실제로 한번 더해줘 볼게요

5805
06:21:40,440 --> 06:21:46,080
이거를 이용해서 import 시스를
하고 append 한 다음에 찾아줄 경로

5806
06:21:46,420 --> 06:21:49,240
저희는 C에 파이썬 안에 모드3가 있죠

5807
06:21:49,400 --> 06:21:55,120
그렇기 때문에 C에 파이썬이라는 경로를 추가를 해주겠습니다

5808
06:21:55,220 --> 06:21:58,920
시스로 그렇다는 거는 이제 그때부터는 찾을 수가 있겠죠

5809
06:21:59,100 --> 06:22:04,117
그래서 다시 해보면 원래는 못 찾았다가
이제는 값이 잘 나오는 것을 확인할 수 있습니다

5810
06:22:04,141 --> 06:22:05,060
왜냐?

5811
06:22:05,120 --> 06:22:12,100
그 system. Path 안에다가 얘를 추가해줬기 때문에 아
여기까지도 뒤져야 돼 라고 알려줬으니까 이제 찾을 수가 있겠죠

5812
06:22:12,220 --> 06:22:13,880
상대 경로로도 찾을 수 있죠

5813
06:22:14,000 --> 06:22:15,720
상대 경로로는 찾을 수가 없습니다

5814
06:22:15,960 --> 06:22:18,740
이 path는 절대 경로만 다 지금 들어가 있네요

5815
06:22:18,820 --> 06:22:21,960
그리고 이런 식으로 넣으면은 그냥 이 점 자체가 들어갑니다

5816
06:22:22,040 --> 06:22:26,260
그래서 여기 안에는 절대 경로를
넣어야 이 경로를 찾을 수 있을 것 같습니다

5817
06:22:26,360 --> 06:22:29,440
그래서 이렇게 경로를 넣는 방법까지도 알아봤습니다

5818
06:22:29,900 --> 06:22:31,837
이것마저도 알 필요가 없긴 합니다

5819
06:22:31,861 --> 06:22:37,020
왜냐하면 보통은 뭐 패키지 설치한 다음에
쓰기 때문에 설치하면 알아서 다 지정을 해줘요

5820
06:22:37,060 --> 06:22:38,260
또 지적 허용심 정도로

5821
06:22:38,480 --> 06:22:44,200
아 이렇게 원리적으로 내부적으로 추가되는구나를
알아두시면 그냥 지적 허용심 충족용입니다

5822
06:22:44,560 --> 06:22:47,440
아무튼 이렇게 path를 추가할 수 있다는 것을 배웠고요

5823
06:22:47,540 --> 06:22:55,540
아니면 파이썬 path라는 환경 변수를 사용해서 여기 안쪽에 파이썬까지도
찾을 거야 라고 이렇게 파이썬 path 안에 얘를 굳이 이렇게 set을

5824
06:22:58,021 --> 06:23:02,760
이용해서 set 명령으로 추가해주면
이걸 굳이 안 써도 이제 쓸 수가 있습니다

5825
06:23:03,060 --> 06:23:09,260
이거를 추가해 준 다음에 레펠 안에서는 이 set을
통해서 설정한 이걸로 바로 사용을 할 수가 있습니다

5826
06:23:09,460 --> 06:23:10,760
얘는 이제 경로를 알고 있죠

5827
06:23:10,900 --> 06:23:16,540
그래서 아무튼 이렇게 경로를 찾는 과정은
대부분 그냥 뭐 설치하면 알아서 경로를 추가해줍니다

5828
06:23:16,660 --> 06:23:20,560
그래서 import를 뭐 굳이 시스템
path로 추가할 일이 없습니다

5829
06:23:20,900 --> 06:23:23,260
이건 정말 특별한 걸 하지 않는 이상 쓸 일이 없습니다

5830
06:23:23,540 --> 06:23:25,340
물론 쓸 일이 있을 때 찾아보면 되죠

5831
06:23:25,580 --> 06:23:28,020
찾아봐서 이걸 보고 그대로 하시면 됩니다

5832
06:23:28,380 --> 06:23:30,800
이렇게 해서 이제 모듈 단원을 마치겠습니다

5833
06:23:31,300 --> 06:23:36,060
그래서 모듈은 그냥 어떤 파이썬 파일을 그대로
불러오는 거다 라고 이해하시면 좋을 것 같습니다

5834
06:23:36,200 --> 06:23:38,860
그 다음에 패키지도 비슷한 개념입니다

5835
06:23:39,020 --> 06:23:40,800
모듈의 집합을 말합니다

5836
06:23:40,960 --> 06:23:48,960
즉 어떠한 큰 파이썬 파일들을 막 여러 개 만들었는데
그거를 묶어서 하나의 모듈로 이렇게 가져오는 그런 개념입니다

5837
06:23:50,460 --> 06:23:52,620
일단은 크게 중요한 개념이 아닙니다

5838
06:23:52,700 --> 06:23:56,000
일단은 이렇게 설명드린 이유가 이걸 사실 알 필요는 없어요

5839
06:23:56,140 --> 06:24:00,880
왜냐하면 그냥 불러와 쓰는 개념이라
이거를 구조를 막 이해할 필요가 없긴 합니다

5840
06:24:01,300 --> 06:24:03,556
그래서 패키지도 마찬가지로 어떤 거냐?

5841
06:24:03,580 --> 06:24:11,580
이런 패키지 안에 막 이렇게 복잡하게 있는데 각각 이 안에 사운드라는
패키지, 그래프라는 패키지, 플레이라는 게 있고 게임이라는 큰 패키지 안에

5842
06:24:13,381 --> 06:24:18,560
이런 여러 가지들이 들어와 있는 이런 파이썬
파일들이 여러 개 있는 이런 거를 의미합니다

5843
06:24:18,760 --> 06:24:24,680
그래서 패키지 만들기는 사실 아마 패키지를
여러분들이 만드실 일은 초보 때는 없을 겁니다

5844
06:24:24,880 --> 06:24:26,640
그래서 이걸 알 필요는 없습니다

5845
06:24:27,360 --> 06:24:29,260
근데 그래서 그냥 있는 걸로 한번 볼게요

5846
06:24:29,300 --> 06:24:30,437
전 미리 만들어 놨는데

5847
06:24:30,461 --> 06:24:33,260
그걸 기반으로 한번 보도록 하겠습니다

5848
06:24:33,480 --> 06:24:35,320
그래서 이미 만들어 놨습니다

5849
06:24:35,540 --> 06:24:42,238
그래서 여기 보면 do it이라는 게임이라는
패키지 안에 그 폴더 구조를 만들어 놔서 그래프라는

5850
06:24:42,262 --> 06:24:48,780
init 안에 뭐 이렇게 그 구조를 보면 게임이라는
폴더 안에 그래픽이라는 게 있고 사운드가 있어요

5851
06:24:48,960 --> 06:24:55,920
게임이라는 모듈 안에 그래픽 사운드가 있는데 그
안에 render라는 거 echo라는 이 모듈들이 들어 있습니다

5852
06:24:56,180 --> 06:25:04,180
그래서 이런 구조를 봤을 때 이런 식으로 불러온다는 걸 좀 보여드리면
그럼 이 게임이라는 모듈을 사용하기 위해서 이 바깥쪽에 하나 더 만들게요

5853
06:25:06,120 --> 06:25:13,020
이 테스트 지금 게임이라는 폴더가 있는 이
파이썬 안쪽에 지금 테스트라는 걸 만들었어요

5854
06:25:13,620 --> 06:25:15,880
이렇게 같은 경로에 있죠 지금

5855
06:25:16,000 --> 06:25:18,360
그래서 이렇게 바로 해보도록 하겠습니다

5856
06:25:19,100 --> 06:25:20,520
이런 식으로 불러올 수가 있습니다

5857
06:25:21,100 --> 06:25:28,100
어떻게 하냐 이 게임이라는 폴더가 있으니까
게임 안에 있는 사운드 안에 있는 echo라는 파일

5858
06:25:28,500 --> 06:25:30,780
게임 안에 사운드 안에 echo가 있죠

5859
06:25:30,880 --> 06:25:35,240
그러면 여기 안에 echo test라는 함수가
있기 때문에 이런 식으로 불러올 수가 있습니다

5860
06:25:35,540 --> 06:25:42,500
그러면 import game 안에 sound 안에 echo 이렇게
불러와서 이 echo test라는 함수를 여기서도 사용할 수가 있습니다

5861
06:25:42,740 --> 06:25:48,240
그래서 그냥 이 test. Py를 실행해보면 이렇게
echo라고 나오는 게 이걸 사용할 수 있기 때문이죠

5862
06:25:48,440 --> 06:25:52,600
네 어렵네요 어려워는 이거는 어려운
게 맞는데 이걸 이해할 필요가 없습니다

5863
06:25:52,920 --> 06:25:55,840
그냥 이렇게 가져와 쓴다라는 개념만은 이해하시면 됩니다

5864
06:25:56,060 --> 06:25:57,117
그래서 이걸 알 필요는 없습니다

5865
06:25:57,141 --> 06:26:05,141
그래서 이렇게 불러오는 방법 그냥 여러 개만 보여드리면 이런 식으로
마찬가지로 게임 안에 사운드 안에 에코를 불러와서 그거를 이제 from

5866
06:26:05,621 --> 06:26:10,895
import를 구문으로 에코만 따로
이렇게 불러오게 되면 게임 점 사운드 점

5867
06:26:10,919 --> 06:26:15,960
이렇게 하나씩 갈 필요 없이 바로 에코의
에코 테스트 이렇게 불러올 수가 있겠죠

5868
06:26:16,080 --> 06:26:19,060
그래서 실행해보면 마찬가지 똑같이 가져올 수가 있습니다

5869
06:26:19,320 --> 06:26:20,320
네 맞아요 폴더 구조입니다

5870
06:26:20,440 --> 06:26:24,017
그래서 게임 폴더 안에 사운드 안에
에코라는 파일을 가져오겠다 이겁니다

5871
06:26:24,041 --> 06:26:30,160
그래서 모듈이랑 비슷한데 그냥 폴더로 여러가지 뭉탱이
있는 걸 하나씩 빼와 하는 개념이라고 이해하시면 좋습니다

5872
06:26:30,300 --> 06:26:32,220
아예 함수 단위로 가져올 수도 있어요

5873
06:26:32,740 --> 06:26:37,540
그 여기는 지금 에코라는 파일을 가져온 건데
에코 테스트라는 함수만 가져올 수도 있습니다

5874
06:26:38,040 --> 06:26:43,060
네 이렇게 해도 에코 테스트 함수를 임포트
했으니 바로 그냥 갖다가 쓸 수가 있습니다

5875
06:26:43,240 --> 06:26:43,680
똑같습니다

5876
06:26:43,760 --> 06:26:45,480
그래서 이렇게 할 수가 있습니다

5877
06:26:45,760 --> 06:26:48,560
이거는 크게 중요한 개념은 아니라 넘어가겠습니다

5878
06:26:48,960 --> 06:26:51,560
불러올라면 이닛에 정의한 것만 참조할 수 있다

5879
06:26:51,640 --> 06:26:53,400
이런 게 있는데 이게...

5880
06:26:54,040 --> 06:26:57,180
3.3 버전부터는 이닛 파일 없이도 막 가져올 수 있거든요

5881
06:26:57,400 --> 06:27:01,280
그래서 이거는 조금 옛날 개념이긴 한데 이건 넘어가겠습니다

5882
06:27:01,460 --> 06:27:08,140
그다음에 패키지 변수 및 함수의 정의를 보면은
이닛이라는 파일에 이닛이 뭔지 그냥 잘 쓸 리는 없을

5883
06:27:08,164 --> 06:27:16,164
텐데 대충 설명만 드리면 여기 게임이라는 패키지를
만들었고 여기 안에 지금 그 이닛이라는 파일이 있어요

5884
06:27:16,860 --> 06:27:20,840
그럼 얘는 게임을 총괄하는 뭔가 파일이라고 보시면 됩니다

5885
06:27:21,020 --> 06:27:24,016
그래서 게임 폴더 안에 있는
이 이닛은 무슨 역할을 하는가?

5886
06:27:24,040 --> 06:27:29,440
이게 무슨 역할이냐면 해당 디렉터리가
패키지라는 것을 알려주기 위한 용도이고요

5887
06:27:29,820 --> 06:27:35,340
그래서 이 패키지가 어떤 건지 그런
것들을 설명하는 것을 이 이닛 안에 담습니다

5888
06:27:35,760 --> 06:27:38,740
그렇다는 거는 이 이닛 안에 이런 걸 담을 수가 있겠죠

5889
06:27:38,860 --> 06:27:41,796
그래서 이 게임이라는 패키지는 이렇게 생겼어

5890
06:27:41,820 --> 06:27:42,640
버전이 몇이야

5891
06:27:42,740 --> 06:27:50,700
이런 거를 만들게 되면 이제 밖에서
불러올 때 뭐 임포트 게임을 해서 game.ver

5892
06:27:50,840 --> 06:27:52,420
이렇게 출력을 해 볼 수가 있겠죠

5893
06:27:52,700 --> 06:27:53,997
버전을 출력해보고...

5894
06:27:54,021 --> 06:28:00,779
아니면 프린트 게임 프린트 버전 임포라는
함수를 여기 이닛에 넣어놨으니까 이런 식으로 모듈을

5895
06:28:00,803 --> 06:28:07,920
불러왔을 때 패키지를 불러왔을 때 이런 것들을
찍어볼 수 있는 그런 거를 보통 이닛 안에 담습니다

5896
06:28:07,960 --> 06:28:11,760
그래서 이런 개념적인 거를 좀
배워봤는데 당연히 모르셔도 됩니다

5897
06:28:11,940 --> 06:28:14,380
이 정도는 직접 패키지를 만들 일이 없죠

5898
06:28:14,420 --> 06:28:14,740
딱히

5899
06:28:15,140 --> 06:28:23,140
이닛 안에다가 이것도 조금 쓸데없는 개념이긴 한데
이 패키지 안에 이거를 미리 지정해 놓으면 이 게임 안에

5900
06:28:23,848 --> 06:28:31,540
이렇게 버전 말고 이렇게 미리 렌더 테스트를 가져오면
이거를 바로 게임을 불러 와서 쓸 수가 있는 겁니다

5901
06:28:31,680 --> 06:28:33,120
이렇게 쓸 수 있다는 거죠

5902
06:28:33,240 --> 06:28:38,257
그러니까 렌더 테스트는 게임 안에
그래픽 안에 렌더가 있는데sss ot Jeit

5903
06:28:38,281 --> 06:28:42,360
게임만 불러오고 렌더 테스트를 수행
했을 때 이렇게 랜더가 불러와집니다

5904
06:28:42,440 --> 06:28:46,900
즉 이 렌더 테스트를 이닛 안에서
이렇게 불러왔기 때문에 쓸 수가 있는 거죠

5905
06:28:47,020 --> 06:28:52,536
그래서 이건 구조가 복잡한데 그냥 불러와서
쓴다라는 전체 개념으로 투구하는 거죠

5906
06:28:52,560 --> 06:28:59,160
그래서 이것을 만들 일이 진짜 거의 없으니
그냥 아 이런 게 있구나 정도만 보시면 되겠습니다

5907
06:28:59,320 --> 06:29:04,489
패키지 초기화 이런 것도 이닛이라는 게
이제 처음 시작할 때 패키지를 불러올 때

5908
06:29:04,513 --> 06:29:09,480
쓰는 개념이니까 이런 코드가 들어가
있다면 임포트를 하자마자 이게 출력이 된다

5909
06:29:09,520 --> 06:29:12,040
막 이런 건데 크게 중요하지 않습니다

5910
06:29:12,200 --> 06:29:17,260
그냥 생성자와 비슷한 패키지를 불러올 때
실행되는 거다 정도로 이해하실 수가 있겠습니다

5911
06:29:17,700 --> 06:29:22,060
그래서 이거는 그냥 각각 불러오는 방법을 좀 배워본 거고요

5912
06:29:22,560 --> 06:29:28,580
그다음에 뭐 이런 별표 이런 거는 그래도
알아놓으면 좋으니 이거를 써보도록 하겠습니다

5913
06:29:28,840 --> 06:29:29,960
별표는 뭐냐

5914
06:29:30,140 --> 06:29:38,140
테스트 첨파할 때 게임 안에 사운드 안에 여러 가지가
있으면 그걸 다 불러오고 싶다라고 하면 별표를 써줍니다

5915
06:29:38,900 --> 06:29:45,080
그래서 별표를 써주면 다 불러오는데
그냥 다 불러와서 쓰면은 아 이건 잘 되네

5916
06:29:45,180 --> 06:29:47,520
이거는 왜 그러냐면 제가 미리 써놨기 때문입니다

5917
06:29:47,720 --> 06:29:54,181
게임 사운드에 사운드 안에도 마찬가지로
이걸 만약 안 써놨다고 이건 제가 써놓은

5918
06:29:54,205 --> 06:29:59,760
건데 그냥 게임의 사운드 밑에 있는
모든 것을 불러와서 쓰면은 오류가 납니다

5919
06:29:59,820 --> 06:30:06,595
왜냐 에코가 어디 어디 있는 거야 하고
못 찾는데 이 별표가 무슨 의미냐면 이

5920
06:30:06,619 --> 06:30:12,800
게임 안에 지금 사운드 안에 이닛 안으로
들어가서 이닛에 있는 것을 참조합니다

5921
06:30:12,940 --> 06:30:20,120
즉 여기에 에코가 있지만 이 all이라는
거 안에 어떤 모듈들이 지금 이 사운드라는

5922
06:30:20,144 --> 06:30:25,720
패키지 안에 포함되어 있는지를 쭉 적어줘야
이거를 그대로 불러와서 쓸 수가 있습니다

5923
06:30:25,900 --> 06:30:29,860
즉 얘를 살리니까 오류가 안 나고
바로 잘 나오는 걸 볼 수가 있죠

5924
06:30:30,000 --> 06:30:38,000
즉 이 별표는 이닛 안에 있는 이 all이라는 것을
참조해서 가져온다 라고 이해하시면 되는데 너무 어렵죠

5925
06:30:38,720 --> 06:30:40,240
이거를 알 필요가 없습니다

5926
06:30:40,800 --> 06:30:43,520
패키지는 모듈을 모아놓은 디렉터리의 개념이 맞습니다

5927
06:30:43,740 --> 06:30:44,460
네 정확합니다

5928
06:30:44,620 --> 06:30:51,836
그래서 디렉터리 안에 어떤 모듈들이 있는지를 막 쭉
저장해서 이렇게 모아놓은 게 패키지다 라고 이해하시면 됩니다

5929
06:30:51,860 --> 06:30:55,900
그래서 그냥 가져온다의 개념 이것만 아시면 됩니다

5930
06:30:56,020 --> 06:30:59,380
별표는 다 가져오는 개념이다 정도를 이해하시면 됩니다

5931
06:30:59,560 --> 06:31:05,640
아 Relative 패키지 이것도 조금 쓸데없는
개념이라 그냥 이거는 쭉 보고 넘어가도록 하겠습니다.

5932
06:31:05,880 --> 06:31:13,760
Relative 패키지는 패키지 안에서 다른 패키지를
부르고 막 이런 개념인데 이렇게 쓸 일이 거의 없죠

5933
06:31:13,840 --> 06:31:16,500
그래서 이것도 이렇게 이런 거 있죠?

5934
06:31:16,960 --> 06:31:20,437
점점을 쓰면은 이전 폴더라는 의미입니다

5935
06:31:20,461 --> 06:31:23,820
그러니까 이전 폴더가 무슨 의미냐 하면 이런 거죠?

5936
06:31:23,900 --> 06:31:25,316
지금 C에 파이썬 이잖아요?

5937
06:31:25,340 --> 06:31:28,760
그런데 CD..하게 되면 이전 폴더로 갑니다

5938
06:31:28,820 --> 06:31:33,796
즉 C에 파이썬에 있다가 그
이전 폴더가 이제 C 폴더 잖아요?

5939
06:31:33,820 --> 06:31:36,760
그러니까 이렇게 이전으로 넘어가는 게 점점의 개념입니다

5940
06:31:36,920 --> 06:31:41,280
이 정도만 이해하시면 되고 나머지는 딱히 모르셔도 됩니다

5941
06:31:41,420 --> 06:31:45,820
그래서 이 점점이 그 이전거다 라고만 이해하시면 됩니다

5942
06:31:45,960 --> 06:31:50,417
여기 부모 디렉터리고 점은 현재
디렉터리 이것만 아시면 됩니다

5943
06:31:50,441 --> 06:31:57,740
그래서 그 모듈 중에서도 폴더 뒤로 갔다가 그 안에 있는
모듈을 선택하고 이럴 때는 이 뒤로 가기를 여기 써주면 되겠죠

5944
06:31:57,840 --> 06:32:01,160
그래서 이렇게까지 해서 이제 패키지를 다뤄봤습니다

5945
06:32:01,380 --> 06:32:07,680
그래서 모듈 패키지는 통틀어서 그냥 가져와
쓴다만 알면 되지 다른 거는 굳이 알 필요는 없습니다

5946
06:32:08,180 --> 06:32:12,400
그리고 그냥 뭐 실용적으로 하나 실용적인
거 하나 알아두자면 이런 게 있습니다

5947
06:32:12,740 --> 06:32:18,577
Import 하고 모두 3를 하는데 as 뭐 m
이렇게 해서 줄여쓰는 것도 많이 씁니다

5948
06:32:18,601 --> 06:32:22,700
그래서 좀 실용적인 걸 배워보자면
이게 무슨 뜻인가를 알면 좋겠죠

5949
06:32:22,820 --> 06:32:29,780
그래서 모두 3 이게 되게 이름이 길다 싶으면은
이렇게 한 글자로 줄여서 as라는 걸로 쓰기도 합니다

5950
06:32:30,310 --> 06:32:33,600
그래서 m.add 이런 거를 쓸 수가 있겠죠

5951
06:32:33,740 --> 06:32:40,980
그러면은 이 모두 3를 다 안 쓰고도 줄여쓴 글자
as 뒤에 있는 요걸 갖다가 이렇게 쓸 수가 있습니다

5952
06:32:41,360 --> 06:32:43,240
그 다음에 이제 중요한 걸 나가보겠습니다

5953
06:32:43,520 --> 06:32:46,680
예외 처리가 그 이 중에서 좀 중요한 편입니다

5954
06:32:46,860 --> 06:32:49,321
예외 처리를 빠르게 한번... 나가보도록 하겠습니다

5955
06:32:49,460 --> 06:32:53,800
예외 처리는 오류가 발생하면
어떻게 처리할 것인가에 대한 겁니다

5956
06:32:54,220 --> 06:32:57,520
그래서 오류 처리를 하면 어떻게 처리할지 보도록 하겠습니다

5957
06:32:57,900 --> 06:33:01,240
그러면은 오류는 언제 발생하는가 이럴 때 발생하죠

5958
06:33:01,540 --> 06:33:01,900
네

5959
06:33:01,980 --> 06:33:08,100
나 없는 파일이라는 거를 read 하게 되면
read open이라는 게 이제 읽는 거잖아요

5960
06:33:08,260 --> 06:33:12,900
근데 read로 읽는 건데 open이
이제 파일을 여는 그런 함수잖아요

5961
06:33:13,140 --> 06:33:17,700
근데 거기서 없는 파일을 열려고
하면 어떻게 되냐 이렇게 됩니다

5962
06:33:18,320 --> 06:33:26,280
파일 not found 에러라는 게 발생하면서 나 없는 파일이
없는데 어떤 걸 열라는 거야 하고 에러를 뱉어 주게 되죠

5963
06:33:26,320 --> 06:33:32,540
그래서 이런 에러가 발생했을 때 어떻게
처리할지 이런 걸 정해주는 게 예외 처리 단원입니다

5964
06:33:32,820 --> 06:33:35,360
그래서 예외 처리를 배워보도록 하겠습니다

5965
06:33:35,740 --> 06:33:39,280
뭐 0으로 나눌 때 이것도 아까
전에 계산기 하면서 나왔었죠

5966
06:33:39,800 --> 06:33:42,880
0으로 나누면 0으로 나눌 수 없다라고 오류가 나옵니다

5967
06:33:42,960 --> 06:33:44,300
그리고 이런 것도 있었죠

5968
06:33:44,340 --> 06:33:48,277
그 리스트에서 리스트 범위 바깥에 거를 불러오려고 했었죠

5969
06:33:48,301 --> 06:33:51,640
아울러에서자동 uz turn 들어가를 때 리스트
인덱스 out of range 요런 거 많이 보셨죠

5970
06:33:51,680 --> 06:33:55,520
그래서 이런 오류들이 나오는데
이런 거를 처리할 수 있는 방법입니다

5971
06:33:55,660 --> 06:34:00,300
그래서 이게 거의 if문 조건문 생각하시면 거의 비슷해요

5972
06:34:00,400 --> 06:34:02,520
그래서 조건문이랑 거의 구조가 비슷합니다

5973
06:34:03,020 --> 06:34:08,220
예외 처리는 이제 오류가 발생할 때
어떻게 하는지 정하는 게 예외 처리입니다

5974
06:34:08,360 --> 06:34:11,500
그래서 큰 그림을 보자면 이렇게 정의할 수가 있겠습니다

5975
06:34:11,840 --> 06:34:14,020
Try except else finally.

5976
06:34:14,340 --> 06:34:16,317
If else 구문과 거의 비슷합니다.

5977
06:34:16,341 --> 06:34:20,660
Try 안에 오류가 발생할 수 있는 어떠한 구문을 넣고요

5978
06:34:20,940 --> 06:34:25,700
그리고 오류가 발생이 되면 이 구문들을 수행하게 됩니다

5979
06:34:25,900 --> 06:34:33,900
처음에 오류가 발생하면 except 안에 특정 오류를 잡아주는
어떻게 보면 조건문의 그 조건에 해당하는 오류를 작성해주게 되고요

5980
06:34:35,060 --> 06:34:38,140
그래서 이 오류가 발생했을 때 어떤 코드를 수행합니다

5981
06:34:38,460 --> 06:34:42,517
그리고 오류가 발생하지 않으면
수행하는 것도 else에 넣어줄 수 있고요.

5982
06:34:42,541 --> 06:34:50,541
Finally는 이 조건이 어떤 게 되든지 이 안에 있는 구문이
끝나면 무조건 마지막에 실행하는 것을 finally에 둡니다

5983
06:34:52,060 --> 06:34:58,020
그래서 이렇게 큰 그림을 다 살펴본 것이 오류
처리 구문인데 이걸 하나씩 배워보도록 하겠습니다

5984
06:34:58,420 --> 06:35:02,440
그럼 먼저 가장 기본적인 거 try
except 먼저 보도록 하겠습니다

5985
06:35:03,060 --> 06:35:07,040
그럼 try except를 쓰면 이런 거 있죠

5986
06:35:07,620 --> 06:35:09,780
이렇게 지금 4 나누기 0을 했어요

5987
06:35:10,000 --> 06:35:12,880
그러면 상식적으로 0으로 나눌 수가 없으니까 오류가 뜨겠죠

5988
06:35:13,220 --> 06:35:18,000
근데 이 try 안쪽에는 이렇게 오류가
발생할 수 있는 구문을 넣어놓게 되고요

5989
06:35:18,080 --> 06:35:26,080
그리고 accept에는 어떤 오류를 잡을지 오류 이름과 함께
as e는 이 오류가 발생했을 때 이거를 e라고 이거는 별칭이죠

5990
06:35:27,740 --> 06:35:34,080
이 오류를 e라고 부르겠다라고 해서 이 오류를
잡아주고 그 오류를 지금 프린트를 해주는 겁니다

5991
06:35:34,560 --> 06:35:41,377
그럼 실제로 실행을 해보면 이렇게 division by
0라는 오류가 여기 프린트가 된 것을 확인할 수 있습니다

5992
06:35:41,401 --> 06:35:48,436
그러면 여기에 뭐 오류 발생하고 이런
원하는 문구를 넣어주게 되면 마치 if else

5993
06:35:48,460 --> 06:35:54,020
구문처럼 이렇게 실행했을 때 오류 발생이라는
게 오류를 잡았기 때문에 이게 수행이 됩니다

5994
06:35:54,440 --> 06:36:00,040
그래서 오류가 발생되면 그거를 잡아서
처리하는 개념이라고 보면 되겠습니다

5995
06:36:00,540 --> 06:36:01,540
Try finally.

5996
06:36:01,820 --> 06:36:03,440
Try finally는 뭐냐

5997
06:36:03,500 --> 06:36:11,376
뭐 예를 들어 오픈했는데 없는 걸 했는데 오류가
발생하든 뭐 어쨌든 간에 파일을 열었던 거는 닫아야 되잖아요

5998
06:36:11,400 --> 06:36:17,800
그래서 이런 구문에 있어서 finally는
무조건 수행할 문장을 적어줍니다

5999
06:36:18,280 --> 06:36:25,877
즉 어떠한 try 안에 뭘 수행하더라도
결국에는 file. Close는 해줘야 이제 파일이

6000
06:36:25,901 --> 06:36:32,260
닫히니까 이렇게 쓰는 경우 finally는 무조건
무조건 실행되는 거를 finally에 써줍니다.

6001
06:36:32,380 --> 06:36:35,420
Zero division error 적어도
대문자 소문자를 구분합니다

6002
06:36:35,680 --> 06:36:37,580
이 zero division error도 클래스예요

6003
06:36:37,700 --> 06:36:39,660
이렇게 마우스 올려놓으면 클래스라고 나오죠

6004
06:36:39,720 --> 06:36:45,920
앞에 대문자이기도 하고 그래서 이걸 들어가보면
여기 에러를 상속받아서 지금 만든 클래스입니다

6005
06:36:46,440 --> 06:36:54,440
그래서 이 unpathetic error를 들어가보면 이것도
exception이라는 걸 상속받았고 exception을 보면 또 base

6006
06:36:55,261 --> 06:37:00,040
exception을 상속받아서 결국에 이 base
exception을 기반으로 만든 클래스입니다

6007
06:37:00,180 --> 06:37:03,340
그 에러 종류 중에 하나를 클래스로 만든 거고요

6008
06:37:03,420 --> 06:37:05,400
그래서 당연히 대소문자가 중요합니다

6009
06:37:05,700 --> 06:37:08,600
그다음에 여러 개 오류를 처리할 수도 있습니다

6010
06:37:08,760 --> 06:37:09,600
예를 들어 이런 거죠

6011
06:37:09,740 --> 06:37:10,137
네

6012
06:37:10,161 --> 06:37:17,800
이렇게 여러 가지 오류가 날 수 있는 구문을 안에 넣어놓고 zero
division error가 나올 때는 0으로 나눌 수 없습니다를 출력해주고

6013
06:37:18,330 --> 06:37:23,680
index error가 나올 때는 indexing할 수
없습니다라고 처리해준다면 이렇게 되겠죠

6014
06:37:23,760 --> 06:37:29,240
지금 먼저 발생하는 게 indexing이
안 됐기 때문에 오류가 났겠죠

6015
06:37:29,380 --> 06:37:34,500
여기서 3번째 index는 없으니까 그래서
지금 indexing할 수 없습니다가 출력이 됩니다

6016
06:37:35,550 --> 06:37:43,550
근데 만약에 이 구문이 없더라도 구문이 없더라도
그러면 이제 여기 있는 에러가 발생을 하겠죠

6017
06:37:44,540 --> 06:37:47,180
0으로 나눌 수 없습니다가 이제 출력이 됩니다

6018
06:37:47,380 --> 06:37:53,280
왜냐면 얘네가 먼저 오류 발생을 안 했기
때문에 즉 if-else 구분이랑 거의 비슷한 거 같아요

6019
06:37:53,600 --> 06:38:01,600
그래서 오류가 발생할 수 있는 상황들을 쭉 이렇게 작성해 놓고 여기서 뭔가
오류가 빵 발생하면 그에 맞추어서 여기서 발생한 오류에 맞게 이렇게 갑니다

6020
06:38:04,520 --> 06:38:06,280
이렇게 오류에 맞게 가게 되는 거죠

6021
06:38:06,420 --> 06:38:08,377
이 구조 크게 이해되시나요?

6022
06:38:08,401 --> 06:38:16,401
즉 try 안에 오류가 발생할 수 있는 구문을 넣으면 except에
맞춰서 그 오류가 발생한 구역으로 찾아가서 처리를 하게 됩니다

6023
06:38:18,030 --> 06:38:22,640
그래서 이런 식으로 오류 메세지를
as-e로 받아서 볼 수도 있어요

6024
06:38:23,040 --> 06:38:26,060
아니면은 이런 식으로도 쓸 수가 있습니다

6025
06:38:26,220 --> 06:38:31,660
두 개 이상을 그냥 한 번에 except로 이렇게
tuple로 묶어서 이렇게 처리할 수도 있습니다

6026
06:38:31,880 --> 06:38:35,060
그러면 이제 알아서 받아서 이렇게 처리를 하게 됩니다

6027
06:38:35,320 --> 06:38:41,040
그래서 이거를 주석하면은... 얘는
이제 제로 디비전 에러가 나오게 되겠죠

6028
06:38:41,380 --> 06:38:42,640
이렇게 쓸 수도 있습니다

6029
06:38:43,300 --> 06:38:44,340
그 다음에 try else.

6030
06:38:44,560 --> 06:38:46,480
Else가 뭔지 보도록 하겠습니다.

6031
06:38:46,800 --> 06:38:50,040
Else는 오류가 없을 경우에 수행되는 문장입니다

6032
06:38:50,400 --> 06:38:51,540
그래서 이런 게 있겠죠

6033
06:38:52,040 --> 06:38:53,300
그래서 이런 게 있죠

6034
06:38:53,560 --> 06:38:57,540
그 나이를 입력하세요라고 했는데 이걸 실행해 보겠습니다

6035
06:38:58,040 --> 06:39:01,540
그 int로 변환할 수 없는 거를 막 만들어 볼게요

6036
06:39:01,640 --> 06:39:06,180
뭐 조코딩 이런 거 입력하면
입력이 정확하지 않습니다라고 나오죠

6037
06:39:06,540 --> 06:39:14,540
왜냐하면 이제 오류가 발생하면은 엑셉트라고 바로 이렇게 가게
돼서 이게 출력이 됐는데 그러면 나이를 정확하게 한번 입력을 해 볼게요

6038
06:39:14,620 --> 06:39:16,120
그러면 뭐 20

6039
06:39:16,320 --> 06:39:19,360
이렇게 입력을 하게 되면 이게 오류가 발생을 안 했잖아요

6040
06:39:19,620 --> 06:39:22,080
그렇기 때문에 이제 else로 가는 겁니다.

6041
06:39:22,260 --> 06:39:25,480
Else는 오류가 발생을 안 했을 때 실행하는 구문입니다

6042
06:39:25,640 --> 06:39:31,980
그래서 이게 통과가 됐기 때문에 else의
age를 20인 경우 이제 환영합니다가 뜨겠죠

6043
06:39:32,080 --> 06:39:32,360
이렇게

6044
06:39:32,740 --> 06:39:34,840
근데 18보다 아래면 어떻게 될까요?

6045
06:39:34,940 --> 06:39:36,857
18보다 아래인 뭐 15 이렇게 쓰면

6046
06:39:36,881 --> 06:39:44,060
이렇게 미성년자는 출입금지입니다가 뜨는 이유가 여기서
오류 발생이 안 됐기 때문에 else 쪽으로 가서 수행이 된 겁니다

6047
06:39:44,320 --> 06:39:48,280
그래서 거의 if else랑 구조가
비슷하다는 것을 알 수가 있죠

6048
06:39:48,420 --> 06:39:55,580
그리고 추가로 여기 except 안에는 무슨 에러인지를 안
썼기 때문에 어떤 에러가 발생해도 여기로 가게 됩니다

6049
06:39:56,160 --> 06:40:00,800
그래서 이렇게 try except else
그리고 finally까지도 살펴보았습니다

6050
06:40:01,560 --> 06:40:03,000
그런 경우도 있어요

6051
06:40:03,140 --> 06:40:10,380
이것도 가끔 쓸 일이 좀 있는데 없는 파일을 실행하든
뭐하든 오류가 발생되면 일단 프로그램이 꺼지잖아요

6052
06:40:10,500 --> 06:40:17,361
그런데 프로그램 자체를 꺼지지 않고 계속
굴러가기 위해서는 어떤 오류가 발생해도 그냥 패스로

6053
06:40:17,385 --> 06:40:23,560
지나가게 한다면 이렇게 되면 없는 파일을
열어서 오류가 발생했는데 그냥 지나갈 수도 있습니다

6054
06:40:23,980 --> 06:40:31,980
그래서 오류가 발생한 게 그냥 지나가서 아래쪽에 안녕 이런 중요한
코드를 실행해야 될 게 있다면 이렇게 지나가서 그냥 수행할 수가 있습니다

6055
06:40:32,841 --> 06:40:38,760
그래서 그냥 오류를 처리할 때 패스를 넣어주게
되면 오류가 발생해도 그냥 지나가 버립니다

6056
06:40:38,860 --> 06:40:44,360
그래서 이렇게 회피하도록 작성할 수도
있고 일부러 오류를 발생시킬 수도 있습니다

6057
06:40:44,700 --> 06:40:45,580
이거는 뭐냐?

6058
06:40:45,640 --> 06:40:47,280
자, bird라는 클래스를 만들었어요

6059
06:40:47,600 --> 06:40:55,600
그리고 fly라는 함수를 부모가 가지고 있는데 eagle은 이제 bird를
상속받았으니까 이 bird를 안에 있는 이걸 쓸 수가 있게 된 거예요

6060
06:40:56,760 --> 06:41:02,460
그런데 여기에 fly 아래쪽에는 not
implement 에러를 발생시키고 있습니다.

6061
06:41:02,840 --> 06:41:06,080
Raise라는 걸 통해서 어떤 에러를 발생시킬 수 있는데요

6062
06:41:06,240 --> 06:41:10,420
이거를 수행해 보면 실제로 이 not
implemented 에러가 발생합니다.

6063
06:41:10,700 --> 06:41:18,700
Bird에 fly를 상속받아서 eagle이라는 건 fly를 쓸 수 있는데 이
fly를 쓰게 되면 이런 오류가 나와서 어떻게 보면 강제로 이 eagle

6064
06:41:21,441 --> 06:41:28,440
안에 메서드 오버라이딩을 통해서 fly를 한 번 더
굳이 강제로 정의를 해야 되게끔 강제를 하는 겁니다

6065
06:41:28,780 --> 06:41:36,780
이렇게 적성하게 되면은 이제 부모의 이렇게 클래스가 정해져
있어도 fly를 이용해서 덮어 쓰게 되면 얘를 덮어 쓸 수가 있겠죠

6066
06:41:38,560 --> 06:41:45,640
그래서 이렇게 꼭 덮어 쓰지 않으면 안 되게 이렇게
강제를 하기 위해서 일부러 에러가 발생되게 할 수도 있습니다

6067
06:41:46,420 --> 06:41:49,480
그래서 이거를 실행해 보면 펄럭펄럭이 나오게 되죠

6068
06:41:49,960 --> 06:41:55,440
그래서 이렇게 강제를 해야 될 때 안 하면은
오류를 일부러 이렇게 발생시킬 수도 있습니다

6069
06:41:55,720 --> 06:41:58,060
그래서 이렇게 써주는 거 배워봤습니다

6070
06:41:58,240 --> 06:42:00,620
이거는 사실 예외 만들 일이 잘 없죠

6071
06:42:00,720 --> 06:42:08,480
그래서 예외는 이미 이미 정해진 걸 많이 위주로 쓸
텐데 예외를 굳이 만들어 보자면 예외도 클래스입니다

6072
06:42:08,640 --> 06:42:15,720
그래서 클래스 예외를 만들려면 이렇게
exception이라는 부모를 상속 받으면 이게 에러가 됩니다

6073
06:42:16,380 --> 06:42:21,120
그래서 myException에서 myError에서
이제 나만의 에러를 만들 수 있겠죠

6074
06:42:21,780 --> 06:42:24,840
그래서 이런 거를 한번 만들어 봐서 써보도록 하겠습니다

6075
06:42:25,060 --> 06:42:31,597
네, myError를 만들었는데 이거는 exception이라는 걸
상속 받았기 때문에 에러의 기본적인 속성들을 가지고 있습니다

6076
06:42:31,621 --> 06:42:35,280
그래서 이렇게 쓰면은 기본적인 에러가 발생을 합니다

6077
06:42:35,420 --> 06:42:40,420
그래서 sayNic이라는 거는 바보를
쓰면은 myError가 발생하도록 해놨죠

6078
06:42:40,500 --> 06:42:48,500
그러면 한번 써보면 여기에 함수를 호출할 때 바보를
넣어서 호출하게 되면 이렇게 myError라는 게 에러가 났습니다.

6079
06:42:51,380 --> 06:42:52,800
MyError가 발생을 했죠

6080
06:42:52,960 --> 06:42:55,040
그래서 이렇게 할 수가 있겠습니다

6081
06:42:55,600 --> 06:42:58,760
네, 그래서 이렇게 바보를 쓰면
에러가 발생하는 거를 볼 수가 있죠

6082
06:42:58,920 --> 06:43:01,457
그래서 예외 처리도 이런 식으로 self

6083
06:43:01,481 --> 06:43:02,481
셀프로 할 수가 있습니다

6084
06:43:02,940 --> 06:43:10,940
셀프로 예외 처리를 하게 되면 myError라는 걸
잡아서 이렇게 출력하게 만들면 에러를 잡아서 출력...

6085
06:43:11,381 --> 06:43:17,960
이렇게 지금 ee가 없기 때문에 이렇게 아무 메시지도
안 뜨는 건데 이 에러 메시지를 추가해 줄 수도 있습니다

6086
06:43:18,550 --> 06:43:21,880
추가해 주려면 이 에러 클래스에 이렇게 추가하면 됩니다

6087
06:43:22,420 --> 06:43:30,420
그래서 지금은 클래스를 그대로 상속받았기 때문에 사실 exception이랑
다를 게 없는데 이렇게 허용되지 않는 별명입니다라는 구문을 이 스트링...

6088
06:43:32,540 --> 06:43:38,633
언더바 언더바는 이게 지정된 것 중에
하나인데 여기 안에 오버라이딩으로 허용되지

6089
06:43:38,657 --> 06:43:43,876
않는 별명입니다를 추가해 주면 이제는
그 에러가 발생했을 때 메시지가 나옵니다

6090
06:43:43,900 --> 06:43:51,900
실행을 하면 이 천사는 그대로 출력이 됐고 바보를 출력할 때 에러가
발생이 돼서 exception을 타고 프린트를 하면 이렇게 출력이 됩니다

6091
06:43:54,100 --> 06:43:57,880
이렇게 출력된 이유는 여기에 추가를 해줬기 때문입니다

6092
06:43:58,380 --> 06:44:02,980
이렇게 에러를 만드는 것까지 봤는데
사실 이렇게 에러를 만들 일은 잘 없습니다

6093
06:44:03,400 --> 06:44:07,340
그래서 이것도 지적 허용심 용으로 배워봤습니다

6094
06:44:07,540 --> 06:44:09,780
그래서 이렇게 해서 예외 처리까지 봤고요

6095
06:44:09,880 --> 06:44:17,880
그다음에 내장함수 표준 라이브러리 외부 라이브러리는 키 막
엄청 중요한 개념은 아니기 때문에 빠르게 좀 볼 수는 있을 것 같습니다

6096
06:44:18,420 --> 06:44:21,340
중요한 개념이 아니라는 거는 그냥 너무 많아요

6097
06:44:21,380 --> 06:44:24,960
너무 많다... 너무 많아서 각각 사용법이 다 다릅니다

6098
06:44:25,100 --> 06:44:31,730
그래서 이거를 배우는 거는 딱히 의미는 없고 그냥
자주 사용되는 거 위주로 아 이게 이런 함수구나를

6099
06:44:31,754 --> 06:44:37,480
좀 익혀 놓으신 다음에 필요한 게 있을 때 그거를
찾아서 쓰는 거지 그걸 다 외우실 필요는 없습니다

6100
06:44:37,680 --> 06:44:39,360
그러면 하나씩 보도록 하겠습니다

6101
06:44:39,580 --> 06:44:45,140
먼저 내장함수를 보자면 파이썬에서는
기본적으로 내장된 함수들이 있습니다

6102
06:44:45,720 --> 06:44:49,840
뭐 예를 들어 프린트, 인풋 이런
함수들은 내장되어 있는 게 있죠

6103
06:44:50,020 --> 06:44:54,440
그래서 내장함수가 어마어마하게
많은데 주요한 것부터 보도록 하겠습니다

6104
06:44:54,700 --> 06:45:02,700
일단 가장 기본 개념은 파이썬을 이미 내장함수가 있는데
여기가 있으면 예를 들어 print라는 함수 잘 만들어 놨잖아요

6105
06:45:03,040 --> 06:45:07,780
근데 굳이 print라는 함수를 처음부터
설계해 가지고 만들 필요가 없겠죠

6106
06:45:07,920 --> 06:45:13,305
그래서 기본적으로 있는 함수를 잘
갖다가 쓰는 게 이제 이런 내장함수 표준

6107
06:45:13,329 --> 06:45:18,480
라이브러리, 외부 라이브러리를 설치해
쓰거나 이런 개념이 갖다 쓰는 개념입니다

6108
06:45:18,660 --> 06:45:21,900
그래서 여기 Don't reinvent the wheel

6109
06:45:22,060 --> 06:45:23,876
바퀴를 다시 만들지 마라

6110
06:45:23,900 --> 06:45:30,760
라는 말이 굉장히 유명한데 이미 있는 것이
있으면 다시 만드느니 그냥 가져다 쓰라는 개념입니다

6111
06:45:30,880 --> 06:45:38,800
그래서 내장함수, 표준함수, 외부함수 다 그냥 가져다가
쓸 수 있는 것들이 어떤 게 있는지 그냥 보는 시간입니다

6112
06:45:39,380 --> 06:45:47,320
그래서 print, deal, type 이런 것들이 다 지정된
이미 내장된 파이썬 안에 있는 이미 있는 함수죠

6113
06:45:47,400 --> 06:45:50,600
그런 것들을 쓰면 되는데 종류가 굉장히 많습니다

6114
06:45:51,000 --> 06:45:58,820
그래서 이거를 다 아시는 것보다는 그냥 주요한
것들 위주로 한번 학습을 해 보시는 것을 추천드리고요

6115
06:45:58,860 --> 06:46:00,820
셀프 학습도 이거는 충분히 가능합니다

6116
06:46:01,160 --> 06:46:09,160
그냥 하나만 보고 이게 이런 식으로 돌아가고 나머지도 각각 그
함수들의 기능이 이렇구나 라는 걸 이제 이해를 해 볼 수 있겠습니다

6117
06:46:10,840 --> 06:46:12,700
예를 들어 이거 하나만 보도록 하겠습니다

6118
06:46:13,480 --> 06:46:16,100
Abs라는 함수가 내장함수로 있습니다

6119
06:46:16,460 --> 06:46:20,940
그래서 이거를 보면 그 숫자의 절대값을 리턴하는 함수이다

6120
06:46:21,040 --> 06:46:29,040
그렇다는 거는 이렇게 abs3이라는 걸 하면 3이
나오게 되고 얘가 마이너스 3이 들어가도 3이 나오게 된다

6121
06:46:29,120 --> 06:46:34,280
이게 절대값은 마이너스를 빼버리는 게 절대값인 거죠

6122
06:46:34,650 --> 06:46:37,400
그래서 이런 함수들이 어마어마하게 많습니다

6123
06:46:37,900 --> 06:46:41,660
그래서 여기 보면 이게 다 그 내장 함수들입니다

6124
06:46:41,900 --> 06:46:45,440
그래서 그 함수들이 하는 기능들이 다 다릅니다

6125
06:46:46,030 --> 06:46:50,476
그래서 얘네는 한 번씩 쭉
실습을 해 보시는 걸 추천드리고요

6126
06:46:50,500 --> 06:46:52,840
이거를 막 다 외울 필요가 없습니다

6127
06:46:53,540 --> 06:46:56,877
그냥 이런 기능이 있지 않을까 라고 생각하면 있습니다

6128
06:46:56,901 --> 06:47:00,037
그래서 그런 기능들이 여기 모여진 거니까요

6129
06:47:00,061 --> 06:47:04,300
쭉 보면 예를 들어 절대값을 나타내는 함수 당연히 있겠죠

6130
06:47:04,440 --> 06:47:05,440
누가 만들어 놨습니다

6131
06:47:05,540 --> 06:47:13,540
그리고 all이라는 것도 뭐 여러 가지 값들이 있는데 true면 모두 참이면
true, 거짓이 하나라도 있으면 false를 리턴하는 이런 함수도 있습니다

6132
06:47:16,440 --> 06:47:24,440
그래서 all이라는 거 안에 1, 2, 3 다 true이니까 true가 나오고
하나라도 거짓, 0이라는 거는 거짓인 속성을 나타내는 자료형이죠

6133
06:47:25,560 --> 06:47:26,876
그래서 false입니다.

6134
06:47:26,900 --> 06:47:28,580
False가 나오고 이런 것들이 엄청 많습니다

6135
06:47:28,680 --> 06:47:29,080
맞아요

6136
06:47:29,280 --> 06:47:33,540
대표적으로 int형, string형, 형
변환하는 거 이런 거 내장 함수죠

6137
06:47:33,640 --> 06:47:39,191
이런 내장 함수가 너무 많기 때문에
그냥 쭉 한번 보시면서 각각 기능이 다

6138
06:47:39,215 --> 06:47:44,140
다르니까 이런 기능이 이렇구나라고 한
번씩 실습을 해 보시면 좋을 것 같습니다

6139
06:47:44,340 --> 06:47:46,960
그래서 많이 쓰는 걸 보면은 이런 거 있죠

6140
06:47:47,060 --> 06:47:54,720
뭐 이거는 많이 쓸지는 모르겠는데 뭐 목과 나머지 이런 거 하나씩
구할 수도 있는데 두 개 한 번에 구하려면 뭐 div모드 이런 걸 쓰면 되고,

6141
06:47:54,840 --> 06:47:59,400
enumerate 이런 거는, 리스트를
마치 딕셔너리처럼 쓰게 하는 겁니다

6142
06:47:59,540 --> 06:48:07,540
이런 리스트가 있으면 각각의 enumerate를 통해서 인덱스와 그 밸류를
각각 뽑아내서 0, body, 1, who 이런 식으로 인덱스와 밸류를 각각

6143
06:48:10,301 --> 06:48:18,301
뽑아내는 뭐 이런 것도 있고 이런 거는 너무 많기 때문에 그냥 쭉
보시면서 아 이렇게 사용하는구나를 한 번씩 실습을 해 보시면 좋을 것 같습니다

6144
06:48:19,840 --> 06:48:23,020
ID 이런 거는 이전에 메모리 배우면서 좀 배웠었죠

6145
06:48:23,100 --> 06:48:24,100
써봤었죠

6146
06:48:24,880 --> 06:48:29,140
그래서 이런 것들을 다 한 번씩 사용을 해 보시기 바랍니다

6147
06:48:29,280 --> 06:48:33,600
그래서 이거는 그냥 실습을 하실
수 있게 그 열어 놓도록 하겠습니다

6148
06:48:33,860 --> 06:48:36,340
그래서 이걸 다 다룬다는 건 좀 의미가 없을 것 같고요

6149
06:48:36,420 --> 06:48:39,400
왜냐하면 그냥 진짜 그 함수의 사용법입니다

6150
06:48:39,940 --> 06:48:41,620
그래서 함수의 사용법은 다 다릅니다

6151
06:48:42,080 --> 06:48:44,620
그래서 쭉 한 번 써보시면은 좋을 것 같습니다

6152
06:48:44,920 --> 06:48:47,800
그 다음에 표준 라이브러리는 어떤 거냐

6153
06:48:48,000 --> 06:48:53,117
내장된 게 아니고 임포트해서 쓰는
거를 이제 표준 라이브러리라고 부릅니다

6154
06:48:53,141 --> 06:49:01,141
근데 임포트해서 쓰되 따로 막 설치를 해서 쓰는 게 아니라
임포트라는 명령어와 함께 쓰는 것을 표준 라이브러리라고 부릅니다

6155
06:49:01,980 --> 06:49:03,500
그래서 이것도 하나만 보겠습니다

6156
06:49:04,260 --> 06:49:08,260
데이트 타임 이런 거 많이 쓰는데
이런 거를 보도록 하겠습니다

6157
06:49:08,660 --> 06:49:10,280
임포트의 개념 배웠었죠

6158
06:49:10,360 --> 06:49:18,360
그래서 가져와서 쓰는 건데 데이트 타임이라는 걸 쓰면은 이런 날짜를
다루기에 굉장히 좋은 데이트 타임을 가져와서 데이트를 지정을 해 줍니다

6159
06:49:20,020 --> 06:49:22,117
그러면 211214

6160
06:49:22,141 --> 06:49:29,940
이런 걸 지정해 줘서 데이 1을 만들고 데이 2를 만든
다음에 이걸 한 번 출력을 해 보면 프린트 데이 1을 해 볼게요

6161
06:49:30,840 --> 06:49:32,040
이렇게 생겼습니다

6162
06:49:32,480 --> 06:49:37,740
그냥 되게 날짜 텍스트가 나오는데
이렇게 해서 간단하게 만들어 줄 수가 있고요

6163
06:49:37,940 --> 06:49:45,540
그리고 이게 좋은 점이 타입을 찍어 보면 데이트
타임에 데이트라는 클래스 안에 있는 그 객체입니다

6164
06:49:45,660 --> 06:49:48,560
그래서 이걸 여러 가지 기능들이 들어 있어요

6165
06:49:49,060 --> 06:49:51,280
그래서 여러 가지 메소드들을 사용할 수 있는데

6166
06:49:52,140 --> 06:49:53,140
그러면 날짜 연산이 됩니다

6167
06:49:53,300 --> 06:50:01,100
그래서 이거 날짜 연산을 해서 한 번 보면은 데이 2에서
데이 1을 빼면 2023년에서 21년을 빼면 며칠일까 궁금하잖아요

6168
06:50:01,240 --> 06:50:05,060
그래서 diff라는 거로 날짜간의 차이를 볼 수가 있고

6169
06:50:05,180 --> 06:50:08,000
그 날짜 간의 차이를 출력을 해 볼 수가 있습니다

6170
06:50:08,200 --> 06:50:16,200
Diff. Days를 출력을 해 보면 이렇게 477이
나오면은 이 날짜간의 차이가 477일이다

6171
06:50:16,360 --> 06:50:18,000
라는 것도 알 수도 있겠습니다

6172
06:50:18,320 --> 06:50:20,460
그래서 굉장히 다양한 활용법들이 있어요

6173
06:50:20,600 --> 06:50:22,116
어떤 데이의 week, day, time

6174
06:50:22,140 --> 06:50:29,540
1대1을 하면은 뭐 무슨 요일일까 이런 것도 뭐 이른
화요일, 이른 수요일 이런 걸로 요일을 찍어볼 수도 있겠고요

6175
06:50:29,900 --> 06:50:33,620
뭐 등등 표준 라이브러리들이 굉장히 유용한 게 많습니다

6176
06:50:33,880 --> 06:50:38,240
그래서 데이트 타임도 있을 것이며
시간 계산할 때 타임도 굉장히 많이 씁니다

6177
06:50:38,360 --> 06:50:43,380
타임 관련된 함수 중에 이런 것들 되게
많이 쓰기 때문에 알아두시면 좋습니다

6178
06:50:43,920 --> 06:50:45,660
예를 들어 이런 거 많이 쓰죠

6179
06:50:45,920 --> 06:50:50,917
A를 찍고 함수 걸린 시간 측정할 일이 가끔 있거든요

6180
06:50:50,941 --> 06:50:58,494
예를 들어 이때 시간이랑 이때 시간을 둘
다 찍어서 A때 시간을 저장하고 그리고 어떤

6181
06:50:58,518 --> 06:51:05,480
걸 수행한 다음에 B때 시간을 저장해서
그러면 B-A를 하면 걸린 시간이 나오겠죠

6182
06:51:05,700 --> 06:51:09,500
그래서 이런 식으로 할 때 이런
타임이라는 표준 라이브러리를 씁니다

6183
06:51:09,840 --> 06:51:13,120
그래서 이거를 실행해보면 출력이 됐습니다

6184
06:51:13,260 --> 06:51:18,540
그래서 이걸 수행하는데
0.08초가 걸렸다는 걸 알 수가 있죠

6185
06:51:18,660 --> 06:51:24,000
그래서 이런 함수... 이걸 수행하는데 걸리는
시간, 걸리는 시간을 측정해 볼 수가 있겠습니다

6186
06:51:24,160 --> 06:51:28,360
근데 이게 그냥 찍어보면 타임 점
타임을 하면 막 이상한 숫자가 나와요

6187
06:51:28,420 --> 06:51:35,066
뭐 1, 6, 9, 0, 6, 3 뭐 이런 게
나오는데 이게 뭐냐면 굉장히 놀랍게도

6188
06:51:35,090 --> 06:51:41,700
1970년 1월 1일 0시 0분 0초를 기준을
잡고 여기서부터 흘러간 초수를 의미합니다

6189
06:51:42,200 --> 06:51:49,757
즉, 1970년부터 1, 2하고 쭉
초를 셌다면 지금 시점에서 몇 시야?

6190
06:51:49,781 --> 06:51:57,260
1, 10, 100, 1000, 10000, 10만, 100만,
1000만, 억, 10억, 16억 초가 지난 겁니다, 요즘

6191
06:51:57,460 --> 06:52:04,860
그러니까 1970년대부터 숫자를 계속 세고
있었다면 지금 16억 초 뒤에는 지금이 되는 겁니다

6192
06:52:05,340 --> 06:52:06,340
이런 구조입니다

6193
06:52:06,380 --> 06:52:09,880
그래서 이거의 차이를 구하면
걸린 초수의 차이를 구할 수가 있겠죠

6194
06:52:10,060 --> 06:52:16,521
그래서 이런 것들을 쓸 수 있는데 뭐 로컬
타임 이런 것도 있어서 그냥 현재 시간이나

6195
06:52:16,545 --> 06:52:21,961
여러 가지 이런 요일부터 다양한 것들을
계산할 수 있는 게 이제 표준 라이브러리입니다

6196
06:52:22,040 --> 06:52:29,040
그래서 이런 거에 사용법을 안다면 파이썬을 이용해서 뭐
날짜를 계산하거나 날짜를 빼거나 이런 것들을 해볼 수가 있겠죠

6197
06:52:29,380 --> 06:52:37,380
그래서 이런 주요 함수들 뭐 타임점 슬립을 쓰면은 이렇게 코드가 빡
빨리 실행될 텐데 타임점 슬립을 걸어서 천천히 실행할 수도 있습니다

6198
06:52:39,440 --> 06:52:41,440
이것까지도 하나 보면은 이런 거 있죠

6199
06:52:41,540 --> 06:52:49,460
이거를 실행을 해보면 타임점 슬립이 있기
때문에 0, 1, 2 이렇게 1초에 하나씩 출력이 됩니다

6200
06:52:49,780 --> 06:52:50,180
왜냐?

6201
06:52:50,240 --> 06:52:58,140
타임점 슬립 1을 걸어놨기 때문에 기다렸다가 실행하고,
기다렸다가 실행하고 하는 거를 할 때 타임점 슬립을 많이 씁니다

6202
06:52:58,280 --> 06:53:02,540
그래서 이렇게 1초에 하나씩
출력하게 하는 거 이런 것도 쓰게 되고요

6203
06:53:02,640 --> 06:53:07,700
즉 이런 표준 라이브러리들을 많이 알고
있으면 이런 다양한 스킬들을 구사하기가 좋습니다

6204
06:53:08,260 --> 06:53:16,260
그래서 이런 거 쓰는 방법 배웠고 이거는 거의 안 쓰는데 뭐 최소공약수,
최소공배수 이런 것도 편하게 구할 수 있는 표준 라이브러리들이 많습니다

6205
06:53:18,461 --> 06:53:23,020
뭐 조합, 순열과 조합 이런 거
구하는 수학적 라이브러리도 많고요

6206
06:53:23,080 --> 06:53:27,360
근데 이거를 다 다루는 건 너무
길기 때문에 그냥 아 이런 게 있구나

6207
06:53:27,480 --> 06:53:30,060
그리고 심지어 이런 건 자주 사용되지도 않습니다

6208
06:53:30,540 --> 06:53:34,180
그래서 자주 사용되는 거 위주로 쓰면서 배우는 게 최고고요

6209
06:53:34,300 --> 06:53:40,480
그래서 그냥 아 이런 거는 불러와서 쓰는
표준 라이브러리이구나만 이해하시면 됩니다

6210
06:53:40,780 --> 06:53:46,700
그래서 이거는 쭉 한번 실습을 해보시길
권장드리고 막 엄청나게 알 필요는 없습니다

6211
06:53:46,940 --> 06:53:52,380
그냥 이런 외장 라이브러리, 사용법들은
각각 다르기 때문에 각각 배우는 개념입니다

6212
06:53:52,520 --> 06:53:55,460
그래서 이거는 한번 쭉 실습을 해보실 수가 있겠습니다

6213
06:53:55,940 --> 06:53:58,700
그 다음에 외부 라이브러리를 보도록 하겠습니다

6214
06:53:59,000 --> 06:54:02,100
누가 만들어 놓고 그걸 인터넷에 막 공개를 해놨어요

6215
06:54:02,180 --> 06:54:05,620
그럼 그걸 다운받아서 설치해서 쓰는 경우도 있겠죠

6216
06:54:05,760 --> 06:54:08,200
그거를 이제 외부 라이브러리라고 부릅니다

6217
06:54:08,260 --> 06:54:12,000
그리고 pip라는 도구를 이용하여 설치를 하게 되는데요

6218
06:54:12,160 --> 06:54:15,260
이거를 보자면은 뭐 pip를 보도록 하겠습니다.

6219
06:54:15,600 --> 06:54:16,637
Pip가 뭐냐?

6220
06:54:16,661 --> 06:54:22,580
파이썬 모듈이나 패키지를 쉽게
설치할 수 있도록 도와주는 도구입니다

6221
06:54:22,740 --> 06:54:29,460
그래서 pip를 이용해서 파이썬에 있는 외부
라이브러리를 가져와서 내 파이썬에 설치를 할 수가 있습니다

6222
06:54:29,960 --> 06:54:37,520
그래서 사용법을 좀 알아보자면 pypi 안에 파이썬
패키지들이 어떤 게 있는지를 볼 수가 있는데요

6223
06:54:37,720 --> 06:54:39,180
이거를 보도록 하겠습니다

6224
06:54:39,900 --> 06:54:40,980
네, 이런 곳입니다

6225
06:54:41,220 --> 06:54:45,937
그래서 여기에서 파이썬을 이용해서
만든 패키지들을 사람들이 올려놓습니다

6226
06:54:45,961 --> 06:54:51,820
그래서 뭐 대표적으로 판다스 이런 거
검색해보면 사람들이 이렇게 만들어서 올려놨어요

6227
06:54:52,020 --> 06:54:56,760
그래서 이런 게 설치하려면 이
명령을 이용해서 설치할 수 있다

6228
06:54:56,860 --> 06:54:57,880
뭐 이런 것도 있고요

6229
06:54:58,480 --> 06:54:59,300
어, 짱화공님

6230
06:54:59,360 --> 06:55:04,900
필요한 외부 함수는 비주얼 스튜디오 코드에서
확장하는 거랑 pip 인스톨이랑 무슨 차이가 있나요?

6231
06:55:05,020 --> 06:55:13,020
아, 그거는 비슷한 개념인데 vs 코드 안에서 쓸 수
있는 도구는 그 익스텐션으로 설치를 하게 되고요

6232
06:55:13,180 --> 06:55:15,917
예를 들어 뭐 라이브 서버 이런 거

6233
06:55:15,941 --> 06:55:16,220
이런 거 있죠

6234
06:55:16,340 --> 06:55:23,700
이런 거는 그냥 vs 코드에서 서버를 띄울 때 쓰는
거지 파이썬 안에서 뭔가 실행할 때 쓰는 건 아니에요

6235
06:55:23,900 --> 06:55:27,280
그래서 이 익스텐션은 그냥 vs 코드

6236
06:55:27,340 --> 06:55:30,320
즉, 어떻게 보면 예를 들어 이 메모장이 있어요

6237
06:55:30,500 --> 06:55:31,800
근데 글씨가 막 심심해요

6238
06:55:31,900 --> 06:55:33,780
아, 이거 까만색이 좀 심심한데?

6239
06:55:33,860 --> 06:55:36,680
하고 여기에 막 무지개 형광빛 글씨를 넣는다

6240
06:55:36,760 --> 06:55:41,580
이런 게 이제 에디터 차원에서의 그 익스텐션이고요

6241
06:55:42,340 --> 06:55:47,940
파이썬 프로그램 차원에서의 익스텐션은 pip
뭐 이렇게 해서 설치하는 거라고 보시면 됩니다

6242
06:55:48,140 --> 06:55:55,585
그다음에 그러면은 pip install로 설치를
할 수 있고 pip install 어떤 패키지 이름

6243
06:55:55,609 --> 06:56:03,360
혹은 pip uninstall 어떤 패키지 이름으로
설치와 삭제를 명령으로 진행을 할 수가 있습니다

6244
06:56:03,780 --> 06:56:05,660
뭐 특정 버전이 필요할 수도 있겠죠

6245
06:56:05,800 --> 06:56:13,657
그러려면 그 패키지 이름 뒤에 등호를 쓰고 패키지
버전을 적으면 그 버전의 패키지가 설치가 됩니다

6246
06:56:13,681 --> 06:56:20,260
그리고 최신 버전을 설치하려면 그냥 패키지
이름만 쓰면 자동으로 최신 버전에 설치가 됩니다

6247
06:56:20,840 --> 06:56:28,840
그리고 업그레이드 하려면 그 마이너스 마이너스 업그레이드를 쓰게
되면 패키지 이름 쓰기 전에 그러면 최신 버전으로 업그레이드가 됩니다

6248
06:56:30,820 --> 06:56:32,640
그러면 일단 궁금할 수 있잖아요

6249
06:56:32,820 --> 06:56:39,540
내 파이썬에는 어떤 패키지들이 지금 설치되어
있는가를 보려면 pip list라는 명령어로 볼 수가 있습니다

6250
06:56:39,680 --> 06:56:41,377
내 파이썬에 어떤 게 설치되어 있나

6251
06:56:41,401 --> 06:56:43,580
이거는 이 명령어 창에서 쓰시면 됩니다

6252
06:56:43,740 --> 06:56:51,740
Pip list라고 쓰면은 내가 지금 설치된 그 외부
라이브러리들이 어떤 게 있는지 이렇게 볼 수가 있습니다

6253
06:56:53,000 --> 06:56:57,020
그래서 이런 것들이 지금 내 파이썬에
설치가 되어 있다라고 알 수가 있고요

6254
06:56:57,520 --> 06:57:01,140
한번 그러면 외부 라이브러리를
설치해서 사용하는 것을 해보겠습니다

6255
06:57:01,500 --> 06:57:05,200
이 사용법은 다 각각 라이브러리마다 다 다르긴 합니다

6256
06:57:05,540 --> 06:57:11,197
근데 하나씩 보면은 그 faker라는
걸 한번 설치해서 써보겠습니다

6257
06:57:11,221 --> 06:57:12,740
이게 어떤 거냐

6258
06:57:12,800 --> 06:57:16,740
설치할 때는 pip install faker를
이용해서 설치할 수 있습니다.

6259
06:57:16,960 --> 06:57:22,935
Pip install faker를 하면은 이거는
faker라는 외장 라이브러리를

6260
06:57:22,959 --> 06:57:29,000
설치하겠다인 거고 여기에 엔터를 누르면
faker의 최신 버전이 자동으로 설치가 됩니다

6261
06:57:29,880 --> 06:57:30,200
네

6262
06:57:30,260 --> 06:57:33,180
그러면 이제 successfully 설치를 잘 끝냈고요

6263
06:57:33,460 --> 06:57:41,460
그러면은 설치한 다음에는 import faker를 통해서
할 수 있는데 여기 사용법은 여기 이런 사용법 있죠

6264
06:57:43,100 --> 06:57:45,860
사용법은 당연히 처음부터 알 수가 없죠

6265
06:57:46,080 --> 06:57:48,360
검색을 하면은 나옵니다

6266
06:57:48,460 --> 06:57:55,300
그래서 여기 pypi 여기 안에서 보면은
faker 어떻게 쓰는지 여기에 홈페이지도 있고요

6267
06:57:56,250 --> 06:58:02,665
그래서 이 github 이 패키지를 누가
만들었나 이런 것도 확인을 할 수가 있고 그리고

6268
06:58:02,689 --> 06:58:07,537
뭐 소스 코드 여기 볼 수 있고
documentation 문서도 연결이 되어 있습니다

6269
06:58:07,561 --> 06:58:13,300
그래서 이 faker라는 걸 어떻게
쓰는지를 각각 만든 사람만 알겠죠

6270
06:58:13,400 --> 06:58:13,776
당연히

6271
06:58:13,800 --> 06:58:16,920
그래서 이거를 처음 만든 사람이 아닌 이상 모르잖아요

6272
06:58:16,960 --> 06:58:19,280
그렇기 때문에 다 이런 문서가 있습니다

6273
06:58:19,720 --> 06:58:27,720
아니면은 뭐 구글 검색으로 faker python 사용법
이런 거 검색하면은 막 사용법 다 어마무시하게 나오죠

6274
06:58:27,900 --> 06:58:33,220
그렇기 때문에 이런 외부 라이브러리는
처음부터 이걸 사용하는 방법을 알 수가 없습니다

6275
06:58:33,400 --> 06:58:33,560
일단

6276
06:58:33,660 --> 06:58:35,440
왜냐하면 다른 사람이 만든 거기 때문에

6277
06:58:35,580 --> 06:58:37,477
그래서 그냥 이런 문서를 보면서

6278
06:58:37,501 --> 06:58:42,200
아 이거 이렇게 사용하는구나를
각각 그 라이브러리 별로 익히면 됩니다

6279
06:58:42,400 --> 06:58:49,180
그래서 이 faker라는 거에 사용법을 보면 이렇게
documentation 공식 문서에 나온 게 가장 정확하겠죠

6280
06:58:49,300 --> 06:58:52,640
이런 거를 설치하는 방법부터 다 나와 있습니다

6281
06:58:52,880 --> 06:58:57,140
그래서 이렇게 하면 된다라고 나와
있는데 하나씩 따라해 보도록 하겠습니다

6282
06:58:57,380 --> 06:59:00,260
이거를 불러와서 네 이렇게 쓰면 된다고 합니다

6283
06:59:00,440 --> 06:59:03,200
이 faker가 그 클래스인 것 같아요

6284
06:59:03,300 --> 06:59:04,537
그래서 인스턴스를 만들고

6285
06:59:04,561 --> 06:59:10,020
이 faker에 각각 name, address,
text라는 게 가짜로 들어가는 것입니다

6286
06:59:10,180 --> 06:59:18,020
그래서 print 각각 한번 찍어보면 name이랑 address랑
print를 찍어보면 실행을 해봤을 때 네 이렇게 나오죠

6287
06:59:18,100 --> 06:59:19,040
이게 뭐냐

6288
06:59:19,100 --> 06:59:24,360
그 각각 faker의 name, address,
text를 이렇게 다 출력을 해놨습니다

6289
06:59:24,480 --> 06:59:28,860
그래서 이름이 April lane이라는
가짜 이름이 여기 들어가 있고요

6290
06:59:29,060 --> 06:59:31,740
그리고 address 주소가 이렇게 나오죠

6291
06:59:31,780 --> 06:59:33,377
그리고 text는 그냥 뭐

6292
06:59:33,401 --> 06:59:35,460
그냥 아무 텍스트나 이렇게 들어있는 것 같아요

6293
06:59:35,540 --> 06:59:41,580
즉 이 faker라는 모듈은 그냥 가짜로 어떤 유저
정보들을 가짜로 만들어낼 때 그때 사용하는 모듈입니다

6294
06:59:41,740 --> 06:59:43,560
그래서 이걸 다시 실행해보면 또 바뀌어요

6295
06:59:43,640 --> 06:59:44,760
보면은 이름이 바뀌었죠

6296
06:59:44,800 --> 06:59:50,240
이미 이름이 ritazbruns라는 걸로 바뀌었고
주소도 바뀌었고 뭐 딴 것도 바뀌었죠

6297
06:59:50,280 --> 06:59:54,080
그래서 이거의 사용법은 각각 모듈마다 다릅니다

6298
06:59:54,280 --> 06:59:56,220
그래서 각각 라이브러리마다 달라요

6299
06:59:56,260 --> 06:59:56,740
어 맞아요

6300
06:59:56,880 --> 07:00:02,237
코딩하는 이진범님이 좋은 거 말씀해 주셨는데
컨트롤 클릭하면 이게 어떻게 생겼는지 볼 수가 있어요

6301
07:00:02,261 --> 07:00:04,040
얘도 누군가 만들었을 거잖아요

6302
07:00:04,160 --> 07:00:07,860
이 faker라는 클래스가 어떻게 생겼는지
이렇게 파악을 해볼 수가 있습니다

6303
07:00:08,080 --> 07:00:09,800
네 오늘 배운 생성자가 여기 있죠

6304
07:00:09,900 --> 07:00:12,260
어떻게 생겼나도 살펴볼 수가 있습니다

6305
07:00:12,520 --> 07:00:18,520
네 그래서 가짜 이름 뭐 주소 이런 거 생성할 때
쓰는 라이브러리인데 이런 것들이 엄청나게 많습니다

6306
07:00:18,660 --> 07:00:22,980
뭐 대표적으로 데이터 분석할 때는
뭐 pandas, numpy 이런 거 많이 쓰죠

6307
07:00:23,040 --> 07:00:31,040
아니면 인공지능 할 때는 tensorflow, pytorch를 막 쓰는데 그런
것들의 사용법 다 그냥 파이썬 기초만 알면 그 공식 문서를 보고

6308
07:00:32,260 --> 07:00:37,560
아 이 외장 라이브러리는 이렇게 쓰는구나
라는 걸 익혀서 사용하면 되는 개념입니다

6309
07:00:37,680 --> 07:00:39,260
처음부터 아는 건 말이 안 되고요

6310
07:00:39,340 --> 07:00:45,257
그냥 그거를 하나씩 공부해 나가면서
외장 아 이 사람이 만든 이 tensorflow란

6311
07:00:45,281 --> 07:00:49,300
라이브러리는 이렇게 쓰는구나 라고
사용법을 익히시면 되는 개념입니다

6312
07:00:49,400 --> 07:00:52,960
그래서 당연히 이거의 사용법을 처음부터 알 필요가 없습니다

6313
07:00:53,400 --> 07:00:54,980
그래서 하나씩 배워나가는 겁니다

6314
07:00:55,440 --> 07:00:57,000
그래서 이런 것도 된다고 합니다

6315
07:00:57,140 --> 07:01:00,877
Faker에 한글 이렇게 바꾸면
한글 이름으로 바뀐다고 해요

6316
07:01:00,901 --> 07:01:03,760
실행을 하면 오 김승현 씨로 바뀌었습니다

6317
07:01:03,860 --> 07:01:09,960
Faker name이 그리고 address 주소도 한국
주소가 나오고 텍스트는 근데 영어로 나오네요

6318
07:01:10,140 --> 07:01:15,621
아무튼 뭐 이런 식으로 쓸 수 있는 게 이
만든 사람이 다 각각 다르게 만들었으니까

6319
07:01:15,645 --> 07:01:20,981
이런 거를 각각 그 라이브러리 활용법들을
공부해서 사용하실 수가 있겠습니다

6320
07:01:21,180 --> 07:01:29,180
그렇게 해서 이제 외부 라이브러리들 사용법들을 쭉 봤는데 이거는 다
외울 필요가 없고 공식 문서 혹은 구글링 혹은 채찍 PT를 통해서 다 알 수가

6321
07:01:31,841 --> 07:01:37,940
있는 정보이기 때문에 사용법은 각각 그것만
따로따로 필요할 때만 찾아서 공부하시면 됩니다

6322
07:01:38,420 --> 07:01:45,040
그래서 이렇게 사용법들을 쭉 외부 라이브러리들
예시로 사용하는 것들이 쭉 나와 있습니다

6323
07:01:45,380 --> 07:01:49,020
그래서 저는 이 sim파이라는 걸 써본 적이 없거든요

6324
07:01:49,320 --> 07:01:53,560
근데 이런 식으로 안 써본
라이브러리도 다 공식 문서가 있습니다

6325
07:01:53,860 --> 07:01:58,700
그래서 검색해보면 이런 pip에 검색해보면 나옵니다

6326
07:01:58,780 --> 07:02:00,536
그래서 여기에 홈페이지도 있고

6327
07:02:00,560 --> 07:02:02,060
소스 코드도 있고

6328
07:02:02,600 --> 07:02:06,540
사용법도 sim파의 사용법 하면 다 나옵니다

6329
07:02:06,660 --> 07:02:14,660
그래서 이거를 외울 필요 없고 이런 식으로 각각 라이브러리마다
찾아서 그때마다 사용법 방법을 익혀서 쓰시면 됩니다

6330
07:02:15,520 --> 07:02:19,900
그래서 이거 다 외워야 되나라는
생각은 절대 안 하셔도 됩니다

6331
07:02:20,320 --> 07:02:24,340
이렇게 해서 이제 외부 라이브러리
사용법까지 다 살펴봤습니다

6332
07:02:24,560 --> 07:02:30,536
Jump to python 6장 python 프로그래밍 어떻게
시작해야 할까 단원을 나가보도록 하겠습니다

6333
07:02:30,560 --> 07:02:38,560
6장에서는 파이썬 기초 문법은 이전 장들에서 배웠으니 여기서는
실제 문제들을 해결해보는 것을 함께 연습을 해보도록 하겠습니다

6334
07:02:40,260 --> 07:02:44,760
6-1 내가 프로그램을 만들 수
있을까를 나가보도록 하겠습니다

6335
07:02:45,140 --> 07:02:53,140
여기서는 프로그래밍 문법을 아는 상태에서 문제들을 맞닥뜨렸을 때 어떤
식으로 사고하고 코드를 작성해 나가야 되는지 그 흐름들을 배울 수가 있습니다

6336
07:02:54,721 --> 07:03:00,660
그래서 프로그램을 만들려면 가장 먼저
입력과 출력을 생각하면 좋다고 합니다

6337
07:03:00,780 --> 07:03:07,822
그래서 여기서는 99단 프로그램 중 2단에
대해서 출력을 해주는 그런 프로그램을

6338
07:03:07,846 --> 07:03:14,081
만들려면 어떻게 만들어야 되는지 그 예시를
통해서 사고하는 흐름을 배울 수가 있는데요

6339
07:03:14,180 --> 07:03:22,180
사실 요즘에는 AI가 워낙 발달했다 보니까 이런 식으로 프로그램을
어떻게 만들어야지 갈피를 잡지 못하는 경우는 거의 없을 것 같아요

6340
07:03:23,660 --> 07:03:31,080
왜냐하면 그냥... 이런 걸 만들고 싶어 하고 채찍 PT한테 물어보면
알려주니까 그래서 요즘에는 그렇게 시작하는 게 더 좋을 것 같고요

6341
07:03:31,140 --> 07:03:38,860
이거는 이제 채찍 PT를 못 쓰는 상황이 됐을 때 그냥 혼자서
생각을 해야 된다 라고 하면 이런 거를 적용해봐도 좋을 것 같습니다

6342
07:03:39,360 --> 07:03:45,760
그러면 기본적으로 프로그램을 만들
때는 입력과 출력을 생각하면 좋은데요

6343
07:03:45,860 --> 07:03:52,057
99단 2단을 만드는 과정을 생각해봤을 때
우선은 이런 질문들을 하면 좋을 것 같습니다

6344
07:03:52,081 --> 07:03:59,140
함수 이름은 뭘로 지을지 생각을 해서 일단은
99단이니까 99로 짓자 라고 정할 수 있을 것 같고요

6345
07:03:59,200 --> 07:04:04,300
입력받는 값, 입력과 출력을
생각하라고 했으니까 입력받는 값은 2죠

6346
07:04:04,400 --> 07:04:11,917
2단을 입력받아서 출력하는 값은 99단
2단을 쭉 출력해줘야 되기 때문에 2468부터 해서

6347
07:04:11,941 --> 07:04:18,920
18까지 이렇게 출력을 한다 라고 입력 출력
위주로 생각을 하게 되면 좀 더 구성하기가 편합니다

6348
07:04:19,120 --> 07:04:21,297
그리고 결과를 어떻게 저장하지?

6349
07:04:21,321 --> 07:04:27,740
를 좀 생각을 해보면 연속된 자료형이기
때문에 리스트에 담으면 좋겠죠

6350
07:04:27,860 --> 07:04:29,940
그래서 이렇게 담아보도록 하겠습니다

6351
07:04:30,220 --> 07:04:32,660
그러면 이 순서를 한번 따라가 보도록 하겠습니다

6352
07:04:33,200 --> 07:04:40,560
먼저 에디터를 열고 99라는 함수에 2 입력 값을
줘서 result라는 변수에 넣는 것을 만들어 보겠습니다

6353
07:04:41,200 --> 07:04:46,300
에디터를 열어서 6-1에
result는 99라고 만들어 줬고요

6354
07:04:46,440 --> 07:04:49,980
이렇게 되면 일단 함수 정의가 안
돼 있으니까 당연히 오류가 나겠죠

6355
07:04:51,320 --> 07:04:55,980
이제 결과 값을 어떤 형태로 받을
것인지 고민을 해보면 좋다고 합니다

6356
07:04:56,140 --> 07:05:03,640
그래서 이런 리스트 자료형으로 받아야겠다 라는 이런
생각을 한 다음에 그러면 이제 함수를 정의를 해 줘야겠죠

6357
07:05:03,800 --> 07:05:07,760
그래서 이렇게 일단 함수의 기본
틀부터 만들어 보도록 하겠습니다

6358
07:05:08,000 --> 07:05:11,740
얘를 복사해서 넣으면 99라는 함수를 이제 정의를 했죠

6359
07:05:11,820 --> 07:05:19,820
그래서 이제 입력 값으로 몇 단을 받을 건지 숫자를 받고 이거를 이제
결과를 리스트로 출력해 줄 건데 우선은 이렇게 프린트로 작성을 해 놨습니다

6360
07:05:21,320 --> 07:05:29,320
그 다음에 결국 result를 list, 2단이 이렇게 리스트로 담겨서 출력할
것을 생각하고 있기 때문에 result는 빈 리스트를 만들어 줄 거고요

6361
07:05:31,860 --> 07:05:39,860
그리고 일단은 생각을 해 보면 뭐 그냥 무식한 방법으로 여기에 99단,
2단을 하나씩 추가해 주는 걸 생각해 보면 99단이라는 게 몇 곱하기 1부터

6362
07:05:42,181 --> 07:05:48,620
몇 곱하기 2, 몇 곱하기 3해서 몇 곱하기
9까지 이렇게 쭉 곱한 것을 추가해 주면 되잖아요

6363
07:05:48,760 --> 07:05:50,480
그래서 이렇게 할 수도 있겠습니다

6364
07:05:51,320 --> 07:05:58,933
가장 단순한 형태로는 이렇게 n을 받아서
result에 곱하기 1부터 9까지 해서 최종 result를

6365
07:05:58,957 --> 07:06:05,600
돌려주게 되면 이거를 출력해 봤을 때 이렇게
99단, 2단이 잘 출력이 된 것을 확인할 수가 있습니다

6366
07:06:06,080 --> 07:06:08,560
그런데 이렇게 하면 좀 너무 지저분하죠

6367
07:06:08,700 --> 07:06:11,040
이렇게 여러 줄을 써 줄 필요는 없으니까

6368
07:06:11,220 --> 07:06:17,520
그러면 어떻게 하면 좋을까를 생각해 보면 이
숫자가 순차적으로 올라가게만 만들어주면 되겠죠

6369
07:06:17,980 --> 07:06:21,296
그러면 반복문을 사용하면 좋겠다라는 생각을 해봅니다

6370
07:06:21,320 --> 07:06:28,531
그래서 반복문을 사용하는 코드로 변경을 해 보면
기본적으로 while문을 이용해서 1부터 9까지 이렇게

6371
07:06:28,555 --> 07:06:36,160
출력을 할 수 있는지 코드를 써보고 실행을 해
보면 1부터 9까지 반복문을 이용해서 표현할 수가 있죠

6372
07:06:36,320 --> 07:06:43,520
그러면 이 while문을 적용해서 다시 99함수를
재구성해 보면 이런 식으로 구성을 해 볼 수가 있겠습니다.

6373
07:06:43,740 --> 07:06:51,740
Result라는 빈 리스트를 만들고 여기에 1부터 시작해서 반복문을 통해서
result. Append의 i, 를 이용해서 이게 1부터 9까지 이렇게

6374
07:06:54,261 --> 07:07:02,261
출력이 되도록 하면 n을 집어넣었을 때 99단 몇 단이 이렇게 한
줄씩 다 일일이 써주지 않아도 반복문을 통해서 표현이 될 수 있겠죠

6375
07:07:02,620 --> 07:07:09,580
그러면 실제로 print 99단 2단을 출력을 해
보면 이렇게 똑같이 잘 나오는 걸 볼 수가 있습니다

6376
07:07:10,060 --> 07:07:18,060
그래서 이렇게 99단 2단을 만드는 기초적인 과정을 생각해 보면서 프로그래밍
접근 방법을 입력과 출력으로 생각해 보면 좋다 라는 것을 배울 수 있는

6377
07:07:21,320 --> 07:07:21,800
시간이었습니다

6378
07:07:21,900 --> 07:07:27,000
다음으로 6-2, 3과 5의 배수를
모두 더하기를 나가보도록 하겠습니다

6379
07:07:27,280 --> 07:07:30,900
다음 문제는 어떻게 풀 수 있을지
생각을 해 보면 좋을 것 같습니다

6380
07:07:31,380 --> 07:07:36,480
10 미만의 자연수에서 3과
5의 배수를 구하면 3, 5, 6, 9이죠

6381
07:07:36,640 --> 07:07:39,120
그리고 2를 총합하면 23입니다

6382
07:07:39,620 --> 07:07:47,620
이런 식으로 1000 미만의 자연수에서 3의
배수와 5의 배수의 총합을 구하면 되는 문제입니다

6383
07:07:48,100 --> 07:07:51,277
그러면 이런 문제가 주어졌을
때 어떤 식으로 풀 수 있을까요?

6384
07:07:51,301 --> 07:07:54,040
프로그래밍적으로 사고하면 좋을지 생각을 해 보겠습니다

6385
07:07:54,220 --> 07:07:58,820
그러면 이전 시간에 배운 것처럼
입력과 출력을 먼저 생각을 해 보면 좋겠죠

6386
07:07:59,000 --> 07:08:05,644
그래서 입력 받는 값은 1부터 999까지,
즉 1000 미만의 자연수를 입력을

6387
07:08:05,668 --> 07:08:11,440
받아서 출력하는 값은 3의 배수와 5의
배수의 총합을 출력을 해 주면 되겠죠

6388
07:08:11,620 --> 07:08:13,600
네, 그래서 이렇게 정해 놓고요

6389
07:08:13,760 --> 07:08:19,364
그다음에 생각해 볼 거리를 생각해 보면 3의
배수, 5의 배수를 어떻게 찾을지 생각해 보면 좋을

6390
07:08:19,388 --> 07:08:24,820
것 같고, 3의 배수와 5의 배수가 겹칠 때는
어떻게 할지 이 부분들을 생각해 보면 좋겠죠

6391
07:08:24,960 --> 07:08:27,700
그러면 이제 차근차근 진행을 해 보도록 하겠습니다

6392
07:08:28,180 --> 07:08:35,940
네, 먼저 일단 1000 미만의 자연수를 입력을 받아야 되기
때문에 1000 미만의 자연수를 뽑는 그 코드를 생각을 해 보겠습니다

6393
07:08:36,160 --> 07:08:43,960
그러면 일단 이전 거와 마찬가지로 반복문을 통해서
하나씩 늘려가면 1000 미만의 자연수를 쉽게 구할 수가 있겠죠

6394
07:08:44,120 --> 07:08:46,100
그래서 while문을 써도 되고요

6395
07:08:46,220 --> 07:08:49,200
아니면 for문이 좀 더 단순하게 나올 수가 있겠죠

6396
07:08:49,780 --> 07:08:57,780
네, 그래서 이 for문을 간단하게 출력을 해 보면 이렇게 1부터 시작해서
1000 미만, 즉 999까지 쭉 잘 출력이 된 것을 확인할 수가 있습니다

6397
07:09:00,100 --> 07:09:03,020
네, 그러면 이렇게 해서 이제 입력 값은 다 만들었죠

6398
07:09:03,100 --> 07:09:07,716
그리고 이제 3과 5의 배수를 구하는
방법을 생각해 보면 좋을 것 같은데요

6399
07:09:07,740 --> 07:09:12,240
먼저 1000 미만의 자연수 중 3의
배수는 이런 식으로 증가를 하겠죠

6400
07:09:12,360 --> 07:09:13,840
3, 6, 9, 12

6401
07:09:13,960 --> 07:09:16,940
네, 이런 식으로 쭉 가서 999까지 나올 텐데요

6402
07:09:16,980 --> 07:09:19,756
이거를 어떻게 구할지를 생각해 보세요

6403
07:09:19,780 --> 07:09:25,760
생각해 보면 3의 배수라는 거는 3으로
나누었을 때 나머지가 0인 숫자들이죠

6404
07:09:25,860 --> 07:09:33,860
그래서 그거를 고려했을 때는 %연산자를 이용하게
되면 %3을 하면 3으로 나누었을 때 나머지를 구할 수 있는데

6405
07:09:35,708 --> 07:09:43,708
그게 if문을 사용해서 0과 같은지를 검사하게 되면
3으로 나눴을 때 나머지가 0인 것들은 3의 배수이겠죠

6406
07:09:44,060 --> 07:09:46,337
그래서 이렇게 출력을 해 볼 수가 있겠습니다

6407
07:09:46,361 --> 07:09:54,361
코드로 보면 이렇게 쓰고 실행을 해 보면 이제는
쭉 다 3의 배수로만 출력이 된 거를 볼 수가 있죠

6408
07:09:54,680 --> 07:09:59,460
그래서 %연산자를 사용하면
어떤 것의 배수를 찾을 때 좋습니다

6409
07:09:59,680 --> 07:10:06,120
그렇다면 이제 5의 배수는 마찬가지로
%연산자로 5로 나누었을 때 나머지가 0이어야 되겠죠

6410
07:10:06,260 --> 07:10:11,080
그래서 이렇게 or를 이용해서
최종 풀이를 해 볼 수가 있겠습니다

6411
07:10:11,520 --> 07:10:16,317
네, 코드를 보면 일단 for문을
이용해서 1부터 999까지 나오죠

6412
07:10:16,341 --> 07:10:24,172
그리고 if문을 통해서 3으로 나눴을 때
나머지가 0이거나 5로 나눴을 때 나머지가 0이라면

6413
07:10:24,196 --> 07:10:29,880
3의 배수 또는 5의 배수가 n으로 나와서
이거를 result에 계속 더해 줄 수가 있겠죠

6414
07:10:30,020 --> 07:10:38,020
그러면 얘를 출력을 해 보면 이렇게 3의 배수, 5의 배수를 뽑아서 계속
합산을 해 준 다음에 합산을 출력하는 이런 코드를 만들 수가 있겠습니다

6415
07:10:40,600 --> 07:10:45,597
실수할 수 있는 케이스를 좀 보자면
이렇게 3으로 나눴을 때 나머지 0

6416
07:10:45,621 --> 07:10:53,621
5로 나눴을 때 나머지 0을 if문 두 개로 분리를 하게 되면 어떤
오류가 있냐면 이제 15와 같은 공배수가 나왔을 때 여기로 들어가서도 15가

6417
07:10:55,921 --> 07:11:03,320
더해지고 또 그 아랫줄도 실행이 되기 때문에 여기서도
15가 여기에 해당돼서 또 더해져서 중복으로 더해지게 됩니다

6418
07:11:03,460 --> 07:11:07,140
그래서 이거를 피하기 위해서 이렇게 하면 숫자가 달라지죠

6419
07:11:07,200 --> 07:11:14,975
그래서 이거를 if문 하나로 하고 or를 통해서 연결하게
되면 이렇게 둘 중 하나가 걸리면은 그거를 반복문

6420
07:11:14,999 --> 07:11:22,600
한 번 사이클 내에서 처리를 하기 때문에 딱 한
번씩만 더해줘서 이렇게 해야 정답이 나올 수가 있겠죠

6421
07:11:22,740 --> 07:11:26,300
이렇게 6-2, 3과 5의 배수 모두 하기를 해봤습니다

6422
07:11:26,500 --> 07:11:30,180
6-3 게시판 페이징하기를 나가보도록 하겠습니다

6423
07:11:30,480 --> 07:11:38,480
먼저 게시판 페이징이 뭔지 소개를 드리면 이런 식으로 어떤 게시판이 있을
때 여기에 페이지별로 눌렀을 때 이렇게 페이지가 넘어가는 이런 형태 있죠

6424
07:11:40,720 --> 07:11:44,360
그래서 이렇게 페이지가 나오는
것을 게시판 페이징이라고 합니다

6425
07:11:44,440 --> 07:11:52,440
그러면 이 게시판 하나마다 몇 개를 보여줄 건지 여기서는 이렇게
20개의 글이 들어가 있는데 20개의 글씩 페이지별로 나눠줘야겠죠

6426
07:11:53,760 --> 07:11:56,120
이거를 구현하는 거를 해보도록 하겠습니다

6427
07:11:56,560 --> 07:12:02,984
이거를 만들려면 게시물의 총 개수와 한
페이지에 보여줄 게시물 수 이거를 입력으로

6428
07:12:03,008 --> 07:12:08,360
주었을 때 총 페이지 수를 출력하는
그런 프로그램을 만들어보도록 하겠습니다

6429
07:12:08,620 --> 07:12:14,416
그러면 함수 이름은 페이지를 보여주는 거니까
getTotalPage 이런 식으로 정해보도록 하겠습니다

6430
07:12:14,440 --> 07:12:17,520
그리고 입력 받는 값은 2개가 있겠습니다

6431
07:12:17,720 --> 07:12:25,140
게시물의 총 개수 그리고 한 페이지에 보여줄
게시물 개수에서 m과 n으로 받아보도록 하겠습니다

6432
07:12:25,480 --> 07:12:29,300
그다음에 출력하는 값은 총 페이지 수인 거죠

6433
07:12:29,480 --> 07:12:36,420
예를 들어서 게시물의 총 개수가 5개 밖에
없을 때는 페이지당 보여줄 게시물 최대 수를

6434
07:12:36,444 --> 07:12:41,880
10개로 잡으면 게시물 총 개수가 더 적으니까
그냥 한 페이지 내에 다 보여줄 수가 있겠죠

6435
07:12:42,040 --> 07:12:50,040
그런데 15개가 되면 이때는 한 페이지당 10개씩 보여주니까
총 2페이지가 필요해서 총 페이지 수는 2가 나오겠습니다

6436
07:12:50,740 --> 07:12:55,180
이런 식으로 총 게시물이 25개면 3페이지가 필요하겠죠

6437
07:12:55,300 --> 07:13:00,860
그리고 딱 30개가 있으면 10개씩
3페이지로 깔끔하게 딱 떨어질 수가 있겠습니다

6438
07:13:01,220 --> 07:13:09,220
그래서 이런 식으로 입력 값이 어떨 때 총 출력이 어떻게 될지
이거를 생각을 해본 다음에 하나씩 구현을 해보도록 하겠습니다

6439
07:13:09,960 --> 07:13:12,100
그러면 공식을 만들어볼 수가 있겠습니다

6440
07:13:12,360 --> 07:13:20,360
이 패턴을 보자면 총 게시물의 개수에서 페이지당 보여줄 게시물을
나누면 여기서는 일단 0이 나오니까 한 페이지 안에는 보여줘야 되잖아요

6441
07:13:22,120 --> 07:13:26,680
그래서 이걸 나눈 다음에 더하기 1을
해주는 구조로 생각해볼 수가 있겠습니다

6442
07:13:27,120 --> 07:13:34,320
15개의 게시물이면 10으로 나누어가지고 몫이
1이 나오니까 여기에 1을 더해줘서 총 페이지 수는 2

6443
07:13:34,440 --> 07:13:38,800
이런 식으로 이 규칙성을 기반으로
수식을 세워볼 수가 있겠습니다

6444
07:13:39,020 --> 07:13:43,200
그러면 이런 식으로 했을 때 페이지
수가 잘 나오는지 확인을 해보겠습니다

6445
07:13:43,500 --> 07:13:51,500
파이썬 코드로 m과 n 총 페이지 수 한 페이지당 보여줄 페이지
이렇게 입력을 받고 출력을 해보면 결과를 봤을 때 위에 3개는 일치합니다

6446
07:13:54,560 --> 07:13:59,520
그런데 마지막 30페이지를 출력할 때는 4가 출력이 됩니다

6447
07:13:59,720 --> 07:14:05,320
원래 3페이지만 있으면 딱 10개씩 3페이지
넘기면 30개의 게시물을 다 볼 수가 있잖아요

6448
07:14:05,540 --> 07:14:10,080
그런데 여기서는 이 플러스 1을
해줘 버리니까 이게 넘어가 버립니다

6449
07:14:10,180 --> 07:14:11,660
원래 원하는 페이지에서

6450
07:14:11,780 --> 07:14:13,457
실패 케이스는 총 페이지 수는 10개

6451
07:14:13,481 --> 07:14:20,600
총 게시물 수와 한 페이지에 보여줄 게시물을 나눈
값이 0이 될 때 그럴 때 실패 케이스가 발생하게 됩니다

6452
07:14:20,820 --> 07:14:23,620
그래서 이거를 따로 처리를 해줘야 됩니다

6453
07:14:23,900 --> 07:14:31,900
그러면 이런 식으로 아까에서 나누었을 때 0이 되는
거를 따로 if문을 통해서 이렇게 걸러주는 처리를 했습니다

6454
07:14:33,420 --> 07:14:41,377
그러면 게시물 수에서 페이지당 보여줄 게시물 수를
나누었을 때 나머지가 0일 때 이때는 딱 나누어 떨어질 때겠죠

6455
07:14:41,401 --> 07:14:47,760
그러면 그때는 더하기 1을 빼서 그냥 m을
n으로 나눈 목 이거 슬래시 두 개면 몫이죠

6456
07:14:47,880 --> 07:14:55,769
그래서 몫을 구해주고 아니면 아까처럼 그냥
몫에다가 더하기 1을 해준 거를 구해주면 이렇게

6457
07:14:55,793 --> 07:15:01,200
출력을 해보면 정상적으로 1233 이
정답과 같이 나오는 걸 확인할 수가 있습니다

6458
07:15:01,760 --> 07:15:05,320
다음으로 6-4 간단한 메모장 만들기를 해보겠습니다

6459
07:15:05,660 --> 07:15:07,520
메모장을 구현을 할 건데요

6460
07:15:07,560 --> 07:15:11,257
필요한 기능을 생각해보면 먼저 메모를 추가하는 기능

6461
07:15:11,281 --> 07:15:14,820
그리고 메모를 조회하는 기능 이
두 개를 만들어 보도록 하겠습니다

6462
07:15:15,000 --> 07:15:23,000
그러면 입력 받는 값은 메모 내용 그리고 프로그램 실행 옵션 즉 메모를
추가할 건지 아니면 조회를 할 건지 그 두 가지 중에 입력을 받을 수가 있겠죠

6463
07:15:25,900 --> 07:15:30,620
그리고 출력하는 값은 메모.txt를 출력을 해주겠습니다

6464
07:15:31,100 --> 07:15:38,171
그러면 일단은 이렇게 파이썬 명령어를
날려가지고 메모를 입력할 수 있는 그런 프로그램을

6465
07:15:38,195 --> 07:15:43,360
만들 거기 때문에 이 구조를 한번 살펴보면
일단 주석으로 입력을 이렇게 했는데요

6466
07:15:43,460 --> 07:15:46,920
여기 파이썬 하고 메모.py 이렇게 실행을 할 겁니다

6467
07:15:47,200 --> 07:15:54,380
그러려면 이제 파일 만들기를 통해서
메모.py 라는 파일을 만들어 주도록 하겠습니다

6468
07:15:54,640 --> 07:15:57,920
그리고 이 뒤에 있는 게 이제 옵션입니다

6469
07:15:58,100 --> 07:16:06,100
그래서 조회를 할 건지 아니면 수정을 할 건지 이런 옵션을 주고
그다음에 입력할 텍스트를 주고 이런 형식으로 만들어 보도록 하겠습니다

6470
07:16:07,040 --> 07:16:10,897
그러면은 우선 메모.py 안에
이런 식으로 조회를 할 것입니다

6471
07:16:10,921 --> 07:16:11,921
작성을 해볼 수 있겠습니다

6472
07:16:12,020 --> 07:16:17,405
그 sys하고 argv로 불러오게 되면
어떤 거를 가져오냐면 이게 argument

6473
07:16:17,429 --> 07:16:22,001
value인데 print sys argument
value를 해서 한번 찍어보겠습니다

6474
07:16:22,420 --> 07:16:30,420
그러면 이런 식으로 python memo. Py 이거를 실행하는데 마이너스
a를 주고 life is too short이라고 입력하고 엔터를 입력하면

6475
07:16:32,741 --> 07:16:39,297
print sys argument value를 통해서 이런
값이 출력된 거를 확인할 수가 있습니다

6476
07:16:39,321 --> 07:16:45,800
이게 뭐냐면 입력받은 것들을 리스트로
만들어서 이거를 출력을 해준 거죠

6477
07:16:46,210 --> 07:16:54,210
즉 리스트인데 이 인덱스 0번은 memo. Py 파일
이름이고 인덱스 1번은 옵션 다음에 들어간 이거죠

6478
07:16:55,500 --> 07:17:01,540
이게 들어갔고 인덱스 2번은 life is too short
그 다음께 이렇게 들어간 걸 볼 수가 있습니다

6479
07:17:01,720 --> 07:17:09,720
즉 sys. Argv 이거를 이용하게 되면 입력받은 이 파라미터라고도
하는데 이거를 가져오고 가져올 수 있는 메소드입니다

6480
07:17:10,740 --> 07:17:17,500
그러면 기존 코드로 돌아와서 sys.
Argv의 1번 인덱스 1번 인덱스면은 이거죠

6481
07:17:17,580 --> 07:17:20,620
그래서 이거를 옵션이라는 변수에 넣을 거고요

6482
07:17:20,800 --> 07:17:23,800
그 다음에 2번은 입력받은 문장이죠

6483
07:17:23,960 --> 07:17:26,400
그래서 이거는 memo라는 변수에 저장을 해보겠습니다

6484
07:17:26,900 --> 07:17:33,489
그래서 잘 저장됐는지를 출력을 해보면 다시
이걸 입력해서 엔터를 쳐보면 이렇게 마이너스

6485
07:17:33,513 --> 07:17:39,296
a 그리고 life is too short이 각각
옵션과 메모에 저장된 거를 확인합니다

6486
07:17:39,320 --> 07:17:40,320
확인할 수 있습니다

6487
07:17:40,560 --> 07:17:43,020
그 다음에 이제 기능을 구현을 할 건데요

6488
07:17:43,220 --> 07:17:48,940
옵션이 마이너스 a일 때 그 뒤에 있는
텍스트를 입력받게 만들어 보도록 하겠습니다

6489
07:17:49,180 --> 07:17:51,820
그러려면 이렇게 추가를 해주면 되는데요

6490
07:17:52,220 --> 07:18:00,220
1번 인덱스에 있는 옵션을 저장해놓고 if문을
통해서 옵션이 마이너스 a라고 입력이 되면 이러면

6491
07:18:00,460 --> 07:18:08,460
입력을 받을 거기 때문에 그때 메모를 저장하고
이거를 memo. Txt를 열어서 쓰기 모드로 열어줍니다

6492
07:18:09,320 --> 07:18:15,809
그래서 f.write를 이용해서 메모를
write을 해주고 그리고 줄바꿈 문자를 통해서

6493
07:18:15,833 --> 07:18:21,640
다음에 입력받으면 바로 다음 줄로 입력받을
수 있게 이렇게 줄바꿈 문자도 넣어줬습니다

6494
07:18:21,740 --> 07:18:25,720
그 다음에 close를 해주면
어떻게 되는지 실행을 해보겠습니다

6495
07:18:26,220 --> 07:18:31,420
이렇게 입력하고 엔터를
누르면 memo. Txt가 생겼습니다

6496
07:18:31,640 --> 07:18:38,737
그래서 이렇게 life is too short이 잘 써졌고 그리고
줄바꿈 문자도 들어가서 2번 라인부터 시작하는 걸 볼 수가 있죠

6497
07:18:38,761 --> 07:18:41,280
그리고 다른 한 줄을 더 추가해보겠습니다

6498
07:18:41,560 --> 07:18:48,111
Unit python이라고 뒤에 문장만 바꾸고
옵션은 그대로 마이너스 a에서 쓰기 모드로 한

6499
07:18:48,135 --> 07:18:53,540
번 더 입력을 해주면 memo. Txt의 다음
줄이 이렇게 추가된 것을 확인할 수가 있습니다

6500
07:18:53,820 --> 07:18:57,120
그리고 줄바꿈 문자를 통해 세
번째 줄로 바꿔진 걸 볼 수가 있죠

6501
07:18:57,440 --> 07:19:03,080
그렇게 vs 코드로 열어서 볼 수도 있는데
이렇게 type.memo.txt 이걸로 볼 수도 있습니다

6502
07:19:03,300 --> 07:19:08,540
실행을 해보면 이렇게 터미널 창 안에서
이 텍스트를 그대로 확인할 수도 있습니다

6503
07:19:08,760 --> 07:19:13,060
그 다음에 프로그래밍적으로 볼 수
있는 처리도 만들어보도록 하겠습니다

6504
07:19:13,240 --> 07:19:18,620
옵션을 마이너스 a 말고 마이너스 v
옵션도 추가해서 그것도 구현을 해보겠습니다

6505
07:19:19,080 --> 07:19:27,080
메모 출력은 마이너스 v 옵션으로 한다고 하면 이런 식으로
메모.py 이 품은 아래쪽에 옵션이 마이너스 v일 때를 추가해주면 되겠죠

6506
07:19:27,780 --> 07:19:35,780
옵션이 마이너스 v일 때는 읽기 모드니까 파일을 열어서 f.read를 통해서
메모에 저장하고 그리고 파일 닫아주고 이 메모를 프린트 출력을 해주면 되겠죠

6507
07:19:40,800 --> 07:19:48,800
코드를 저장해 주신 다음에 이제 마이너스 v 옵션도 추가가 됐으니
이렇게 파이썬 메모.py 마이너스 v라는 옵션을 주게 되면 이렇게 메모.

6508
07:19:51,840 --> 07:19:55,580
Txt 안에 있는 내용이 출력되는 것도 만들어봤습니다

6509
07:19:56,040 --> 07:19:58,700
이렇게 해서 메모장 만들기를 완성했습니다

6510
07:19:59,080 --> 07:20:04,420
다음으로 6-5 텝 문자를 공백 문자
4개로 바꾸기를 해보도록 하겠습니다

6511
07:20:04,980 --> 07:20:07,697
텝 문자라면 이 키보드 텝을 의미합니다

6512
07:20:07,721 --> 07:20:13,240
키보드 텝을 스페이스 4개로 바꿔주는
것을 프로그램으로 구현을 해보겠습니다

6513
07:20:13,420 --> 07:20:20,039
어떤 식으로 구현할지 생각을 해보면 먼저
문서 파일을 읽어드려서 여기서 텝 문자가

6514
07:20:20,063 --> 07:20:26,280
있다면 그거를 변경을 통해서 문자열
변경하기로 공백 문자 4개로 바꿔주려고 하고요

6515
07:20:26,320 --> 07:20:34,320
그러면 입력받는 값은 텝을 포함한 문서 파일을 입력받아서
출력하는 값은 텝이 공백으로 전환된 그런 파일을 뱉어주면 되겠죠

6516
07:20:36,800 --> 07:20:38,740
그러면 공백 문자 4개로 바꿔주는
것을 이런 구조가 되겠습니다

6517
07:20:38,940 --> 07:20:46,018
이거를 좀 예시로 살펴보면 텝2.4라는
파이썬 파일을 만들고 a.txt를 입력받아서

6518
07:20:46,042 --> 07:20:52,560
여기에 텝들을 싹 공백 문자 4개로
교체한 다음에 그거를 b .txt로 저장한다

6519
07:20:52,640 --> 07:20:54,560
이런 구조로 만들어보도록 하겠습니다

6520
07:20:55,020 --> 07:20:58,380
그러면 텝2.4.파일을 우선 생성을 해주겠습니다

6521
07:20:58,900 --> 07:21:01,780
이렇게 텝2.4.파일을 만들어줬고요

6522
07:21:01,880 --> 07:21:09,120
여기에 이전 시간과 마찬가지로 이렇게 sys
외장 함수를 임포트해서 발교멘트들을 찍어줍니다

6523
07:21:09,220 --> 07:21:17,220
그러면 이런 식으로 파이썬 텝2.4.파이 a.txt,
b.txt 입력을 해주면 이렇게 1번 인덱스가 이거죠

6524
07:21:18,340 --> 07:21:24,840
2번 인덱스가 이거고 그래서 이것들을
불러와서 잘 출력을 해주는 것을 볼 수가 있습니다

6525
07:21:25,440 --> 07:21:26,800
이렇게 준비는 다 됐고요

6526
07:21:26,920 --> 07:21:29,980
그러면 이제 입력받을 텍스트 파일을 만들어주겠습니다

6527
07:21:30,200 --> 07:21:35,360
A.txt를 만들어주고 여기에 예제를 입력해주겠습니다

6528
07:21:35,620 --> 07:21:37,560
여기서 이거는 탭이 들어갑니다

6529
07:21:37,700 --> 07:21:45,700
그래서 혹시나 잘 모르겠는 분들은 일단 공백을 다 제거하고
여기에 키보드 탭 키를 이용해서 탭, 탭, 탭을 넣어줍니다

6530
07:21:47,100 --> 07:21:50,740
여기도 탭, 탭 이렇게 넣어주도록 하겠습니다

6531
07:21:51,140 --> 07:21:53,020
그러면 얘는 이제 탭이 들어가 있는데요

6532
07:21:53,240 --> 07:21:56,320
얘를 공백 문자 4개로 바꿔보도록 하겠습니다

6533
07:21:56,800 --> 07:21:58,560
이렇게 변경을 해줬습니다

6534
07:21:58,720 --> 07:22:06,720
먼저 이 src 바꿀 파일을 불러와서
오픈을 해서 파일의 리드를 통해서 탭 컨텐츠

6535
07:22:07,700 --> 07:22:09,180
뒤에 쓰여진 텍스트를 불러옵니다

6536
07:22:09,260 --> 07:22:11,480
그리고 가져온 파일을 닫아주고요

6537
07:22:11,640 --> 07:22:19,640
그다음에 이 컨텐츠, 가져온 컨텐츠에서 .replace를 이용하게
되면 이 앞에 있는 거를 뒤에 있는 걸로 바꿔주는 그런 메소드죠

6538
07:22:21,860 --> 07:22:27,920
그래서 앞에 있는 거는 슬래시 t라고 돼
있는데 이게 탭을 나타내는 문자입니다

6539
07:22:28,160 --> 07:22:33,080
그래서 비슷한 걸로 백 슬래시 n을
쓰게 되면 이게 줄 바꾼 문자잖아요

6540
07:22:33,280 --> 07:22:35,780
얘는 백 슬래시 t는 탭을 의미합니다

6541
07:22:35,980 --> 07:22:40,520
그래서 탭을 찾아서 이거를 얘는
빈 문자열을 한 칸 띄어쓰기 한 거죠

6542
07:22:40,660 --> 07:22:47,655
즉, 잠시 키보드로 입력을 해보면 이렇게 빈
문자열을 만들고 그리고 여기에 스페이스를 입력해서

6543
07:22:47,679 --> 07:22:53,580
이렇게 띄어쓰기를 해주고 여기에 곱하기 4를
하면 이 문자열 곱하기를 하면 이게 이어주는 거죠

6544
07:22:53,740 --> 07:22:57,180
그래서 공백을 4개를 이어준다를 만들어줬습니다

6545
07:22:57,280 --> 07:23:05,280
즉, 탭 문자열을 찾아서 그거를 문자열 띄어쓰기
4개로 교체를 해주는 이런 함수를 작성을 해줬습니다

6546
07:23:05,541 --> 07:23:12,840
그다음에 이제 스페이스 컨텐츠로 저장을 하고 그
스페이스 컨텐츠를 출력을 해보면 이전 그대로 a, b 그대로

6547
07:23:12,864 --> 07:23:20,864
입력받고 엔터를 누르면 이렇게 a .txt의 내용을
불러와서 이 탭이 공백 문자 4개로 변경이 됐습니다

6548
07:23:21,560 --> 07:23:29,560
이거는 아마 탭이랑 공백이랑 크게 눈으로 봤을 땐 차이는 없어서
모르는데 이렇게 드래그를 해보면 이렇게 공백으로 바뀐 거를 볼 수가 있습니다

6549
07:23:30,320 --> 07:23:33,980
그다음에 b.txt로 이 바꾼 걸 저장을 시켜줘야겠죠

6550
07:23:34,100 --> 07:23:36,300
그러면 그거를 좀... 추가해 주도록 하겠습니다

6551
07:23:36,540 --> 07:23:44,540
그러려면 출력하는 거는 지우고 이 밑에다가 w, write 모드를 이용해서
이 dst가 argument 두 번째 즉, 이거 b.txt를 받은 거죠

6552
07:23:47,200 --> 07:23:53,423
그래서 얘를 이제 출력하는 텍스트로
받아서 이거를 파일을 오픈해주고 쓰기 모드로

6553
07:23:53,447 --> 07:23:58,400
스페이스 컨텐츠 이렇게 탭을 공백
문자로 바꾼 걸로 write를 해줍니다

6554
07:23:58,560 --> 07:24:03,280
그다음에 close를 해주면 이렇게
공백 문자로 바꾼 거를 저장을 하겠죠

6555
07:24:03,440 --> 07:24:04,960
그럼 이대로 다시 실행을 해보겠습니다

6556
07:24:05,520 --> 07:24:11,300
지금은 a.txt밖에 없는데 이걸 다시
실행하면 네, 이렇게 b.txt가 나오게 되고요

6557
07:24:11,420 --> 07:24:16,460
얘를 열어봤을 때 이제 탭이 아닌 공백
4개로 구성이 된 거를 볼 수가 있습니다

6558
07:24:16,660 --> 07:24:21,260
A.txt랑 비교해보면 네, 얘도 이렇게
나오지만 얘는 탭으로 아까 입력을 했었죠

6559
07:24:21,320 --> 07:24:24,020
이렇게 탭을 누르면 네, 똑같이 이렇게 나옵니다

6560
07:24:24,140 --> 07:24:28,800
근데 이거를 b.txt에서는 다 공백으로 바뀌게 됐습니다

6561
07:24:28,980 --> 07:24:33,020
다음으로 6-6 하위 디렉터리 검색하기를 나가보겠습니다

6562
07:24:33,340 --> 07:24:41,340
특정 디렉터리부터 시작해서 그 하위 디렉터리의 모든 파일 중
파이썬 파일만 찾아서 출력하는 그런 프로그램을 만들어보도록 하겠습니다

6563
07:24:42,720 --> 07:24:48,940
이게 무슨 말이냐면 이렇게 특정 파일 디렉터리
여기서는 C드라이브의 파이썬 폴더 안쪽이죠

6564
07:24:49,020 --> 07:24:52,220
파이썬 폴더 안쪽에 또 폴더들이 쫙 있는데요

6565
07:24:52,480 --> 07:24:54,400
요게 하위 디렉터리라고 부릅니다

6566
07:24:54,520 --> 07:25:01,900
즉, 폴더 안에 있는 폴더 이거를 하위 디렉터리라고
부르는데 여기에 들어가서 여기서도 파이썬 파일들이 쫙 있죠?

6567
07:25:02,040 --> 07:25:05,840
그래서 이 파이썬 파일들을 찾아주는
것을 이것을 만들어보도록 하겠습니다

6568
07:25:06,040 --> 07:25:10,080
즉, 파일 탐색기, 하위 디렉터를
검색해주는 탐색기를 만들 예정입니다

6569
07:25:10,240 --> 07:25:14,740
먼저 필요한 기능은 파이썬 파일만
찾아서 출력하는 게 필요하고요

6570
07:25:14,840 --> 07:25:22,840
입력받는 값은 검색을 시작할 그 디렉터리를 입력을 해주고
출력하는 값은 파이썬 파일명을 출력해보도록 하겠습니다

6571
07:25:24,500 --> 07:25:26,980
그러면 먼저 파이썬 파일을 만들어주겠습니다

6572
07:25:27,480 --> 07:25:33,397
파일 새로 만들기를 통해서 subdirectorysearch.
Py라는 파이썬 파일을 만들어줍니다

6573
07:25:33,421 --> 07:25:36,740
그리고 먼저 이렇게 기초 뼈대를 잡아보겠습니다

6574
07:25:36,960 --> 07:25:44,960
Search라는 함수를 통해서 디렉터리 네임을 입력받고 일단은 바로 출력해주는
걸 구현해보면 실행을 했을 때 그냥 디렉터리가 일단 기본적으로 나오죠

6575
07:25:46,940 --> 07:25:50,940
그리고 이제 디렉터리에 있는
파일을 검색할 수 있도록 해보겠습니다

6576
07:25:51,380 --> 07:25:54,040
그러려면 이제 외장 모듈이 필요한데요

6577
07:25:54,080 --> 07:26:02,080
Import os를 통해서 os라는 모듈을 가져와서
이거에 listdir이라는 메소드를 활용해보도록 하겠습니다.

6578
07:26:02,641 --> 07:26:08,520
Iistdir을 사용하면 해당 디렉터리에
있는 파일의 리스트를 구할 수가 있습니다

6579
07:26:08,660 --> 07:26:16,660
그래서 이렇게 코드를 변경하게 되면 이제 osdir을 통해서
특정 디렉터리에 있는 파일 이름들을 싹 가져올 수 있습니다

6580
07:26:18,000 --> 07:26:24,655
그런데 파일 이름만 출력해주면 경로가
제거가 된 상태로 출력이 되기 때문에 여기에

6581
07:26:24,679 --> 07:26:31,457
os.path.join이라는 걸 통해서 디렉터리
이름과 파일 이름을 합쳐서 출력을 해주겠습니다

6582
07:26:31,481 --> 07:26:39,481
그럼 이걸 합쳐서 full name으로 뽑은 다음에 이걸 출력해주게
되면 이렇게 c드라이브에 있는 파일과 폴더들이 쭉 출력이 됩니다

6583
07:26:42,180 --> 07:26:47,600
그 다음에 확장자가 .py인 python
파일만 출력하도록 변경을 해보겠습니다

6584
07:26:47,980 --> 07:26:53,700
그러면 확장자를 분리해서 그 확장자가
.py인지를 확인하는 조건문을 추가하면 되겠죠

6585
07:26:53,820 --> 07:27:00,617
그래서 사용한 것이
os.path.splittext라는 메소드를 써줬습니다

6586
07:27:00,641 --> 07:27:05,000
이것은 확장자랑 분리를 해주는 그런 메소드인데요

6587
07:27:05,160 --> 07:27:06,300
여기 설명 나오죠

6588
07:27:06,360 --> 07:27:13,340
Returns root, extension 즉 확장자를
tuple의 마지막 인자로 뱉어주게 됩니다

6589
07:27:13,580 --> 07:27:20,840
리스트나 tuple에서 마지막 거를 뽑을 때는 마이너스
1이라는 인덱스를 쓰게 되면 가장 마지막 거를 뽑을 수가 있겠죠

6590
07:27:21,040 --> 07:27:23,740
그래서 이렇게 확장자를 뽑아줬고요

6591
07:27:23,880 --> 07:27:30,616
그래서 그 확장자가 .py인지 조건문을 통해서
검사를 해서 이게 일치한다면 파일명을 출력합니다

6592
07:27:30,640 --> 07:27:31,640
출력하도록 해보겠습니다

6593
07:27:31,800 --> 07:27:37,560
그러면 출력을 해봤을 때 지금은
아무것도 안 뜨는 게 파이썬 파일이 없는 거죠

6594
07:27:37,700 --> 07:27:45,238
그래서 파이썬 파일이 있는 경로로 바꿔주면
파이썬이라는 폴더 안쪽으로 바꿔주게 되면 다시 출력을

6595
07:27:45,262 --> 07:27:51,280
했을 때 이렇게 파이썬 폴더 안에 있는 파이썬
파일들이 잘 출력이 된 것을 확인할 수가 있습니다

6596
07:27:51,840 --> 07:27:57,055
그런데 이제 우리의 처음 목적은 그 폴더에
있는 파이썬 파일만 가져오는 게 아니라

6597
07:27:57,079 --> 07:28:01,920
하위 디렉토리, 그 디렉토리 안쪽에 하위
폴더 안에서도 파이썬 파일을 탐색하는 거죠

6598
07:28:02,040 --> 07:28:05,280
그러려면 이런 식으로 코드를 변경을 해줬습니다

6599
07:28:05,400 --> 07:28:13,400
어떻게 변경이 됐냐 설명해드리면 os의 패스에 isdir이라는
메소드를 활용하게 되면 이게 디렉토리인지를 확인하게 됩니다

6600
07:28:15,140 --> 07:28:22,680
그래서 여기서 true, false가 나오게 되는데 if문을
통해서 이게 디렉토리라면은 한 번 더 안쪽으로 들어가야겠죠

6601
07:28:22,820 --> 07:28:27,360
그렇기 때문에 디렉토리인지
검사해서 다시 한 번 설치를 써줍니다

6602
07:28:27,540 --> 07:28:34,260
이거 생소하신 분들 많을 텐데 이렇게 설치를
정의했는데 그 안에서 한 번 더 쓸 수가 있습니다

6603
07:28:34,480 --> 07:28:42,480
그래서 이걸 제기 함수라고 하는데 이 안쪽에서 다시 이렇게 full
파일 네임이 인수가 돼서 들어가서 이 함수가 다시 실행되는 겁니다

6604
07:28:44,580 --> 07:28:52,400
즉 디렉토리일 때는 이 정의한 함수를 한 번 더 쓰게 돼서
안쪽으로 들어가서 거기에 있는 파이썬 파일들을 찾을 수가 있고요

6605
07:28:52,760 --> 07:28:59,256
디렉토리가 아닐 경우에는 아까와 마찬가지로
확장자가 파이썬인지 확인을 해서 .python을 적용합니다

6606
07:28:59,280 --> 07:29:02,760
파일하면은 파일명을 출력한다라는 코드로 작성이 되었습니다

6607
07:29:02,980 --> 07:29:09,035
여기서 try, except로 나눈 거는 파일
탐색할 때 접근 권한이 막힐 수 있기

6608
07:29:09,135 --> 07:29:13,700
때문에 접근 권한이 막히면은 패스하라고
이렇게 try, except를 적어준 겁니다

6609
07:29:14,000 --> 07:29:21,539
그러면 아까처럼 파이썬 파일들이 있는 파이썬
경로를 적어주고 실행을 해주게 되면 이번에는 이제

6610
07:29:21,563 --> 07:29:27,817
각 하위 폴더들도 쭉 돌면서 안쪽에 있는
파이썬 파일들을 잘 찾아준 것을 볼 수가 있습니다

6611
07:29:27,841 --> 07:29:30,240
추가로 굉장히 코드가 복잡하잖아요

6612
07:29:30,380 --> 07:29:32,800
그래서 이거를 도와주는 메소드도 있습니다

6613
07:29:33,020 --> 07:29:41,020
Os의 work라는 메소드를 쓰면 되는데 기존 코드보다 훨씬 단순하게 이렇게
써주게 되면 os work를 통해서 여기에 path, directory,

6614
07:29:43,140 --> 07:29:44,740
파일명 이거를 뽑을 수가 있고요

6615
07:29:45,020 --> 07:29:50,680
그래서 이렇게만 써주게 되면 아까랑 동일한
기능을 훨씬 간단하게 써줄 수가 있습니다

6616
07:29:50,980 --> 07:29:54,380
7장, 파이썬 날아오르기를 나가보도록 하겠습니다

6617
07:29:54,660 --> 07:30:02,120
7장에 나오는 내용들은 굉장히 심화적인 내용인데 그래서
이거가 이해가 안 된다고 해도 전혀 문제가 될 게 없어요

6618
07:30:02,260 --> 07:30:08,801
파이썬 일반적인 프로그래밍을 할 때는
거의 이거를 다 몰라도 웬만하면 다 수행을 할

6619
07:30:08,825 --> 07:30:13,740
수 있는데 그래도 좀 지적 허용심을
채운다라는 측면에서 봐주시면 좋을 것 같습니다

6620
07:30:13,960 --> 07:30:18,980
그래서 이게 이해가 안 되더라도 너무
좌절하지 마시고 편하게 따라오시면 되겠습니다

6621
07:30:19,340 --> 07:30:23,440
7-1, 파이썬과 유니코드를 나가보도록 하겠습니다

6622
07:30:23,760 --> 07:30:27,816
우선 컴퓨터는 0과 1이라는 값만 인식하고 있습니다

6623
07:30:27,840 --> 07:30:29,200
그 값만 인식할 수 있는 기계 장치입니다

6624
07:30:29,320 --> 07:30:37,320
그래서 문자를 입력하더라도 사실은 숫자로 변형되고 그 숫자가
0과 1로 쫙 표현이 돼가지고 컴퓨터가 인식하고 연산을 하는 겁니다

6625
07:30:38,760 --> 07:30:45,040
그래서 최초로 이제 문자를 숫자로 변환할
때 그때 사용된 것이 ASCII 코드인데요

6626
07:30:45,200 --> 07:30:51,540
ASCII 코드는 미국에서 먼저 만들어져서
American Standard Code for Information.

6627
07:30:51,564 --> 07:30:57,797
Interchange라는 거에 약자인데 이렇게 어떤
알파벳이나 기호나 이런 거를 숫자로 변환하는 것입니다

6628
07:30:57,821 --> 07:31:02,280
숫자로 결국 변환한 다음에 컴퓨터에 넣어야
됐기 때문에 그 표준을 처음으로 만들었습니다

6629
07:31:02,440 --> 07:31:10,346
그래서 예를 들어서 숫자 65는 A, 66은 B
이런 식으로 특정 숫자랑 문자랑 대응을 시켜서

6630
07:31:10,370 --> 07:31:16,340
문자를 컴퓨터에서 처리할 때 이렇게 숫자로
변환한 다음에 처리할 수 있게 표준을 만든 겁니다

6631
07:31:16,560 --> 07:31:24,560
그런데 영어권 국가뿐만 아니라 다른 국가에서도 컴퓨터를 사용하게
되면서 ASCII만으로는 다국어를 다 잘 표현하지 못하게 되었습니다

6632
07:31:25,901 --> 07:31:33,901
그래서 여러 가지 표준들이 등장하게 됐는데 이렇게 각자
다양한 표준들이 있다 보니까 이거를 통합하려는 시도가 있었는데요

6633
07:31:34,380 --> 07:31:39,260
그래서 이렇게 통합하려고 나온
것이 바로 유닛코드라는 겁니다

6634
07:31:39,480 --> 07:31:47,480
그래서 유닛코드는 모든 나라의 문자를 모두 포함하도록
넉넉하게 설계되어서 세계 표준으로 자리 잡게 되었다고 합니다

6635
07:31:47,800 --> 07:31:53,100
그래서 유닛코드를 사용하게 되면
다국어들을 다 포함해서 사용할 수가 있겠습니다

6636
07:31:53,380 --> 07:31:55,876
그러면 유닛코드로 문자열을 다루는 방법입니다

6637
07:31:55,900 --> 07:31:56,900
이 방법을 알아보겠습니다

6638
07:31:57,060 --> 07:32:04,440
우선 기본적으로 파이썬은 버전 3부터는
모든 문자열을 유닛코드로 처리를 한다고 합니다

6639
07:32:04,600 --> 07:32:07,400
먼저 인코딩하기를 나가보겠습니다

6640
07:32:07,740 --> 07:32:13,160
인코딩이 뭐냐면 이 문자열을 바이트 표현으로 바꾸는 겁니다

6641
07:32:13,360 --> 07:32:16,420
왜냐하면 이 문자열은 컴퓨터가 읽을 수가 없죠

6642
07:32:16,460 --> 07:32:18,920
왜냐하면 컴퓨터는 숫자만 처리할 수 있기 때문에

6643
07:32:19,060 --> 07:32:23,617
그래서 문자를 한 번 로우 레벨로 변환하는 그런 과정입니다

6644
07:32:23,641 --> 07:32:31,641
그래서 인코딩을 하는 방법을 알아보면 이렇게 a라는 변수에 life is
too short이라는 문자열을 넣고 이것을 .incode라는 함수를 통해서

6645
07:32:35,321 --> 07:32:41,360
여기 utf-8이라고 되어 있는 게 유닛코드
트랜스포메이션 포맷의 약자입니다

6646
07:32:41,500 --> 07:32:47,820
그래서 유닛코드 트랜스포메이션 포맷
8을 이용해서 인코딩을 하면 어떻게 나오냐?

6647
07:32:47,900 --> 07:32:52,477
이렇게 b라고 붙고 life is too
short이라는 문자열이 나오게 됩니다

6648
07:32:52,501 --> 07:33:00,501
이것은 이제 byte 코드로 인코딩이 된 건데 여기서 type을
찍어보면 이렇게 클래스가 bytes로 변환된 것을 볼 수가 있죠

6649
07:33:02,200 --> 07:33:06,820
그래서 이 텍스트를 인코딩을
통해서 bytes로 변환을 한 겁니다

6650
07:33:07,100 --> 07:33:13,433
그러면 이런 경우에 어떻게 되는지
한번 테스트를 해보면 이렇게 a라는 변수에

6651
07:33:13,457 --> 07:33:19,300
한글이라는 한글 문자열을 넣고 인코드를
asci 방식으로 인코딩을 하면 어떻게 될까요?

6652
07:33:19,400 --> 07:33:21,697
이러면 이렇게 에러가 납니다

6653
07:33:21,721 --> 07:33:29,721
왜 에러가 나냐면 아까 처음에 설명드렸다시피 asci는
아메리칸 표준, 즉 한글은 포함되어 있지 않은 인코딩 방식이죠

6654
07:33:30,720 --> 07:33:35,020
그래서 asci로 표현하게 되면
한글을 표현할 수가 없습니다

6655
07:33:35,380 --> 07:33:37,660
그래서 이렇게 에러가 발생하게 되는데요

6656
07:33:38,140 --> 07:33:46,060
이것을 인코딩 방식인 euckr로 하게 되면
이때는 이렇게 byte로 잘 인코딩이 됩니다.

6657
07:33:46,280 --> 07:33:51,417
Euckr이 뭐냐면 extended unix
code for korean의 약자인데요

6658
07:33:51,441 --> 07:33:53,560
즉 한글 인코딩 방식입니다

6659
07:33:53,700 --> 07:34:00,640
그래서 이런 한글도 byte 코드로 컴퓨터가 알아들을 수 있는
기계어에 가까운 형태로 이렇게 인코딩을 할 수가 있는 겁니다

6660
07:34:00,840 --> 07:34:08,840
혹은 utf-8 방식을 이용해서도 똑같이 이렇게
한글도 인코딩이 잘 된 것을 확인할 수가 있습니다

6661
07:34:09,180 --> 07:34:11,340
다음으로 decoding하기를 해보겠습니다.

6662
07:34:11,820 --> 07:34:14,360
Decoding은 인코딩의 반대 과정인데요.

6663
07:34:14,540 --> 07:34:20,257
Byte 문자열로 변경된 그 자료를 다시
원래 문자열로 변경하는 그런 과정입니다

6664
07:34:20,281 --> 07:34:22,380
이때 주의해야 될 사항이 있는데요

6665
07:34:22,560 --> 07:34:29,402
이렇게 한글을 euckr이라는 방식으로
인코딩을 해서 b에 저장한 다음에 이것을 다시

6666
07:34:29,426 --> 07:34:34,001
decode할 때는 인코딩을 했던 것과
같은 방식으로 decoding을 해야 됩니다

6667
07:34:34,060 --> 07:34:34,560
당연하겠죠

6668
07:34:34,660 --> 07:34:40,960
왜냐하면 특정 byte로 변환을 해놨는데 다른 방식으로
이것을 찾아서 해석을 하게 되면 해석이 안 될 수가 있겠죠

6669
07:34:41,120 --> 07:34:47,900
그래서 euckr 같은 방식으로 decode를 한 다음에
decode는 이렇게 .decode라는 메소드가 있습니다

6670
07:34:48,140 --> 07:34:54,660
그래서 이렇게 출력을 해보면 한글이라는 게 다시
decoding돼서 원래 텍스트로 나오게 된 걸 볼 수가 있습니다

6671
07:34:54,760 --> 07:35:00,440
그런데 여기서 이 방식을 utf-8
방식으로 하게 되면 이렇게 에러가 납니다

6672
07:35:00,580 --> 07:35:07,160
왜냐하면 이 인코딩을 통해서 만든 이 byte 문자는
euckr 방식이기 때문에 이걸로 해석이 안 되는 거죠

6673
07:35:07,300 --> 07:35:11,620
그래서 같은 인코딩 방식으로 decode를
해줘야 된다라는 것을 설명드렸습니다

6674
07:35:11,800 --> 07:35:15,840
그래서 입출력과 인코딩 이걸
보면 실제로 이런 케이스가 많습니다

6675
07:35:16,000 --> 07:35:21,900
아까 설명드린 것처럼 인코딩된 방식으로
다시 decoding을 해야 되기 때문에 어떤

6676
07:35:21,924 --> 07:35:27,221
텍스트 파일을 불러올 때 그때 이 텍스트
파일의 인코딩 방식대로 불러와야 됩니다

6677
07:35:27,280 --> 07:35:33,160
그래서 이렇게 파이썬의 파일 오픈하는
함수에 인코딩이라는 값을 줄 수가 있는데요

6678
07:35:33,360 --> 07:35:37,680
이 텍스트 파일에 맞는 인코딩으로 읽어오겠다라는 겁니다

6679
07:35:37,880 --> 07:35:45,880
그래서 항상 이런 파일을 오픈할 때나 저장할 때나 이럴 때
인코딩 방식은 맞춰줘야 된다는 점 기억해 두시기 바랍니다

6680
07:35:46,841 --> 07:35:54,320
물론 이렇게 인코딩 방식을 지정하지 않을 수도
있는데 그렇게 되면 기본 값으로 utf-8이 지정이 됩니다

6681
07:35:54,500 --> 07:36:02,500
다음으로 소스 코드의 인코딩을 보면 작성된 소스
코드가 어떤 방식으로 인코딩이 됐는지를 써주는 건데요

6682
07:36:02,800 --> 07:36:10,800
파이썬 코드의 경우 소스 코드의 인코딩을 명시하고자
소스 코드 가장 위에 이런 문장을 넣어야 된다고 합니다

6683
07:36:11,000 --> 07:36:19,000
그런데 사실 파이썬 3.0부터는 utf-8이 기본 값이라서
utf-8로 인코딩한 소스라면 이거를 굳이 안 넣어줘도 됩니다

6684
07:36:20,940 --> 07:36:28,940
그래서 이게 3.0 이하거나 이걸 넣어주고 싶다고 한다면
이렇게 파이썬 파일 위에 이렇게 추가를 해 줄 수가 있겠죠

6685
07:36:29,140 --> 07:36:33,960
그러면 euckr 방식이라면 이렇게
euckr로 지정을 해 주면 되겠습니다

6686
07:36:34,200 --> 07:36:40,120
마찬가지로 이게 소스 코드는 euckr로
인코딩했는데 파일 위에 utf-8로 명시했다

6687
07:36:40,240 --> 07:36:41,660
그러면 이게 해석이 안 맞잖아요

6688
07:36:41,840 --> 07:36:45,477
그래서 오류가 날 수 있으니까 이런
거는 주의해 주시면 될 것 같습니다

6689
07:36:45,501 --> 07:36:49,800
다음으로 7-2 클로저와 데코레이터를 배워보겠습니다

6690
07:36:50,060 --> 07:36:55,780
우선 데코레이터를 이해하려면 클로저에 대해서
알아야 되기 때문에 클로저부터 알아보겠습니다

6691
07:36:56,260 --> 07:37:04,260
클로저는 간단히 말해서 함수 안에 내부 함수를
구현하고 그 내부 함수를 리턴하는 함수를 의미합니다

6692
07:37:04,840 --> 07:37:08,140
이렇게 들으면 굉장히 복잡해
보이지만 사실 굉장히 간단합니다

6693
07:37:08,300 --> 07:37:09,560
함수 안에 함수인 겁니다

6694
07:37:09,960 --> 07:37:14,237
이거를 이해하기 위해서 좀 단계별로 알아보면
이게 왜 필요한지 알아보도록 하겠습니다

6695
07:37:14,261 --> 07:37:20,400
처음에 어떤 수에 항상 3을 곱해 리턴한
함수를 만든다고 생각을 해보겠습니다

6696
07:37:20,620 --> 07:37:26,426
그러면 이렇게 멀3이라고 만들고 인수
n을 입력받아서 항상 3을 곱해서 이렇게

6697
07:37:26,450 --> 07:37:31,300
리턴하는 이런 함수를 만든다고 생각을
해보면 이렇게 간단하게 구현할 수 있죠

6698
07:37:31,420 --> 07:37:38,850
그리고 다음으로 이번에는 항상 5를 곱하여
리턴하는 함수를 만든다고 하면 이렇게 멀5라는 함수를

6699
07:37:38,874 --> 07:37:45,080
만들고 마찬가지로 n을 입력받아서 뭘 넣든
5를 곱해서 리턴하도록 이렇게 만들어줄 수가 있죠

6700
07:37:45,220 --> 07:37:53,220
그런데 3, 5 뿐만 아니라 6, 7, 8 이렇게 쭉 함수를 만들고 싶다고
하면 이거를 매번 def하고 정의하고 정의하고 정의하고 하면 너무 번거롭겠죠

6701
07:37:56,020 --> 07:38:00,020
그래서 이거를 효율적으로
만들려고 클래스라는 개념이 있습니다

6702
07:38:00,220 --> 07:38:07,201
그래서 클래스, 이전에 배운 클래스를 이용하게
되면 이런 식으로 멀이라는 클래스를 만들면

6703
07:38:07,225 --> 07:38:12,917
생성자를 통해서 항상 몇을 곱하는 함수에
해당하는 클래스의 인스턴스를 만들 수가 있잖아요

6704
07:38:12,941 --> 07:38:19,684
그래서 init으로 특정 숫자를 입력받고
그다음에 이 클래스의 메소드로 멀이라는 메소드를

6705
07:38:19,708 --> 07:38:26,740
구현해놓으면 어떤 값을 입력받아서 처음에
지정된 값이랑 곱하게 이렇게 만들면 좀 더 간단하겠죠

6706
07:38:26,880 --> 07:38:34,380
그래서 예를 들어서 멀3하고 인스턴스를 찍어내면
이 멀3은 항상 3을 곱하는 함수랑 똑같은 거죠

6707
07:38:34,520 --> 07:38:40,080
그래서 멀3에 멀이라는 메소드를 이용하면
10에다가 3을 곱해서 30이 출력됩니다

6708
07:38:40,200 --> 07:38:48,200
그리고 멀5라고 입력해서 클래스를 만들어서 클래스의 인스턴스를
만들면 이때 나온 멀5는 항상 5를 곱하는 그런 인스턴스가 되겠죠

6709
07:38:49,820 --> 07:38:54,240
그래서 여기에서 멀을 이용해서
10을 넣으면 이번에 50이 출력이 됩니다

6710
07:38:54,520 --> 07:38:57,720
이렇게 한번 실행을 해보면 잘 나오는 걸 볼 수가 있죠

6711
07:38:57,880 --> 07:39:03,700
이런 식으로 함수를 매번 만들어주기보다 클래스로
지정해주면 이렇게 간편하게 찍어낼 수가 있겠죠

6712
07:39:03,900 --> 07:39:08,480
여기서 조금 더 간단하게 하려면
curl이라는 메소드를 이용하면 됩니다

6713
07:39:09,020 --> 07:39:17,020
아까 멀이라는 메소드를 만든 대신에 언더바 언더바 콜 언더바
언더바 이런 걸 넣는데 이 언더바 언더바 들어간 거는 좀 특별한 겁니다

6714
07:39:19,780 --> 07:39:23,780
그래서 이닛처럼 이닛도 생성자
역할을 하는 그런 메소드잖아요

6715
07:39:23,960 --> 07:39:26,120
그래서 컬도 어떤 기능을 하냐

6716
07:39:26,160 --> 07:39:32,658
그냥 그 클래스로 인스턴스를 만든 다음에
그 인스턴스에서 바로 특정 메소드를 안

6717
07:39:32,682 --> 07:39:38,200
쓰고도 이렇게 괄호 열고 입력하고 괄호
닫고 하면 이게 그대로 컬로 들어가게 됩니다

6718
07:39:38,400 --> 07:39:42,196
즉 이렇게 입력된 것이 바로 그냥 콜이 시작됩니다

6719
07:39:42,220 --> 07:39:44,000
이런 구조로 되어 있습니다

6720
07:39:44,160 --> 07:39:46,960
그래서 메소드 이름을 항상 적어주지 않아도 되겠죠

6721
07:39:47,040 --> 07:39:52,580
이러면 그래서 이런 식으로 만들면 아까랑
똑같지만 좀 더 단순한 형태로 나오게 됩니다

6722
07:39:52,800 --> 07:39:56,820
그런데 이렇게 만들 수도 있는데
이제 여기서 클로저가 등장합니다

6723
07:39:56,960 --> 07:40:01,600
좀 더 단순하게 만들 수는 없을까를
생각해보면 이런 식으로 만들 수가 있습니다

6724
07:40:01,840 --> 07:40:05,040
함수를 만들고 이 안에 함수를 한 번 더 넣어줍니다

6725
07:40:05,160 --> 07:40:10,120
그리고 바깥 함수에서는 안쪽
함수를 리턴해 주게 되면 어떻게 되냐

6726
07:40:10,160 --> 07:40:11,880
아까랑 같은 구조를 만들 수 있습니다

6727
07:40:12,220 --> 07:40:19,469
함수인데 그냥 멀 3이라는 이 함수를 만들면 아까
클래스에서 인스턴스 찍어낸 것처럼 멀 3이 들어가서

6728
07:40:19,493 --> 07:40:26,540
m에 3이 들어간 wrapper 함수인데 3이 여기
고정된 이런 함수 자체가 리턴이 돼 버리겠죠

6729
07:40:26,660 --> 07:40:29,120
그래서 이 함수가 여기에 저장이 되게 됩니다

6730
07:40:29,320 --> 07:40:37,320
그래서 마치 클래스로 인스턴스를 찍어낸 것처럼 함수인데
함수를 리턴해서 그 특정 값을 지정한 함수를 만들 수가 있는 겁니다

6731
07:40:38,200 --> 07:40:39,060
그렇게 어렵진 않죠

6732
07:40:39,140 --> 07:40:47,140
그래서 마찬가지로 이 멀 5라고 하면 이것도 함수를 호출한 건데 리턴
값이 함수이기 때문에 이 함수가 리턴이 되는데 여기에 m에 5가 들어가게 되죠

6733
07:40:49,180 --> 07:40:51,440
그래서 이 5가 이렇게 들어가게 됩니다

6734
07:40:51,680 --> 07:40:57,360
그래서 아까랑 같은 원리로 이거를
출력하면 이렇게 30, 50은 똑같이 나옵니다

6735
07:40:57,480 --> 07:41:04,360
그래서 이렇게 함수 안에 함수가 있고 그 함수를
리턴해주는 거를 파이썬에서는 클로저라고 부릅니다

6736
07:41:04,480 --> 07:41:07,937
다음으로 데코레이터란 무엇인지 알아보겠습니다

6737
07:41:07,961 --> 07:41:15,820
어떤 함수, 이렇게 my function이 있고 함수가 실행됩니다라는
이런 예제 함수가 있을 때 이 함수의 실행 시간이 궁금할 수 있잖아요

6738
07:41:16,000 --> 07:41:20,080
그래서 이 실행 시간을 알아보려면
이런 식으로 구현을 할 수가 있습니다

6739
07:41:20,520 --> 07:41:24,820
Time이라는 모듈을 가져와서 time.
Time 하면 현재 시간이 찍힙니다

6740
07:41:24,880 --> 07:41:32,880
그래서 스타트에 저장을 해놓고 그리고 어떤 함수의 기능을 수행한 다음에
끝난 다음에 이제 다음 시간을 찍어보면 시작 시간 그리고 끝난 시간 이렇게 두

6741
07:41:34,261 --> 07:41:40,260
개가 나오기 때문에 이 둘의 차이를 구하면 이렇게 빼기를
하고 이렇게 빼기를 하게 되면 몇 초가 걸렸다 알 수가 있겠죠

6742
07:41:40,400 --> 07:41:48,400
이거를 실제로 실행을 해보면 이렇게 너무 빨라서 000으로 나오는데
좀 오래 걸린 함수가 있다면 이 시간 차이가 발생을 할 수가 있겠죠

6743
07:41:49,700 --> 07:41:51,480
이런 식으로 구할 수가 있습니다

6744
07:41:51,700 --> 07:41:59,640
그런데 실행 시간을 측정해야 되는 함수가 굉장히 많다면
이거를 항상 뭐 스타트 엔드를 모든 함수마다 넣어주면 너무 많겠죠

6745
07:41:59,820 --> 07:42:05,340
그래서 이때 앞에서 배운 클로저를
이용하면 좀 더 효율적으로 만들 수가 있습니다

6746
07:42:05,520 --> 07:42:07,740
클로저를 이렇게 만들어 놨는데요

6747
07:42:07,960 --> 07:42:13,500
여기서 elapsed 경과라는 함수를
만들고 그 안에 wrapper를 넣어놨습니다

6748
07:42:13,580 --> 07:42:21,580
그래서 이 안에다가 start end를 넣어놓고 그다음에
여기는 original function 즉 이 함수를 인수로 받아서 이 함수를

6749
07:42:22,561 --> 07:42:29,040
여기다 넣게 되면 어떤 함수든 시작 끝을
측정해가지고 함수 수행 시간이 나오게 되겠죠

6750
07:42:29,160 --> 07:42:32,020
즉 함수 시간 측정을 위한 템플릿을 만든 겁니다

6751
07:42:32,240 --> 07:42:40,240
그래서 여기에 my function 이거를 넣게 되면 이런 식으로
elapsed 안에 my function이 들어가서 이 decorated

6752
07:42:40,361 --> 07:42:48,361
my function을 통해서 얘는 함수를 넣었기 때문에 이 템플릿을 나와서
결국에 이 함수만 실행시켜도 이 wrapper 안에 지금 이 함수 대신에

6753
07:42:51,261 --> 07:42:55,580
우리가 수행하고자 하는 함수가 들어간 거기
때문에 수행 시간이 자동으로 측정이 되겠죠

6754
07:42:55,660 --> 07:43:00,520
그래서 실행을 해보면 아까와 똑같이
함수 시간이 이렇게 측정된 상태로 나옵니다

6755
07:43:00,600 --> 07:43:08,600
그래서 이런 식으로 기존 함수를 바꾸지 않고 기능을
추가할 수 있게 만드는 클로저를 데코레이터라고 부릅니다

6756
07:43:08,840 --> 07:43:13,060
그래서 데코레이터는 이제 꾸미다,
장식하다라는 데코레이트에서 나온 거죠

6757
07:43:13,220 --> 07:43:18,080
그러면 이런 클로저의 경우에는 좀 더
간단하게 쓸 수 있는 방법이 있습니다

6758
07:43:18,360 --> 07:43:26,360
직접 이렇게 데코레이티드 펑션에 넣지 않고 그냥 단순하게
골뱅이하고 데코레이터 함수명 이렇게만 내가 데코레이터를

6759
07:43:27,939 --> 07:43:34,780
입히고자 하는 그 함수 위에다가 입력해주면 이
데코레이터 함수가 적용이 돼서 이 템플릿이 적용이 됩니다

6760
07:43:35,020 --> 07:43:37,076
그래서 이대로 my function을 시작합니다

6761
07:43:37,100 --> 07:43:44,790
실행하게 되면 아까처럼 함수 실행시간이 내가
정의한 이 함수가 별도로 변경하지 않고도 이 데코레이터에

6762
07:43:44,814 --> 07:43:50,440
들어가서 이 래퍼 안에 이렇게 함수로 받아줘서
이 템플릿이 적용된 것을 확인할 수가 있습니다

6763
07:43:50,680 --> 07:43:54,080
이렇게 하면 이제 데코레이터를 적용하기가 훨씬 편하겠죠

6764
07:43:54,240 --> 07:44:00,042
그리고 추가로 만약에 my function이 지금은
파라미터가 없는데 여기에 이렇게 메시지를

6765
07:44:00,066 --> 07:44:06,240
입력받고 그 메시지를 출력하는 이런 기능을
만든다고 하면 이때는 실행을 하면 이렇게 오류가 납니다

6766
07:44:06,380 --> 07:44:07,057
왜 오류가 납니다?

6767
07:44:07,081 --> 07:44:12,660
왜 오류가 났는지 생각을 해보면 이 my function이
데코레이터에 인수로 들어가서 이게 이리로 적용이 되는 거죠

6768
07:44:12,780 --> 07:44:19,340
근데 이 데코레이터 래퍼 안에 있는 이 함수
실행할 때는 이 메시지를 받는 곳이 없습니다

6769
07:44:19,540 --> 07:44:24,060
그래서 그 인수 개수가 안 맞아서
이런 오류가 발생을 하게 됩니다

6770
07:44:24,260 --> 07:44:25,440
그러면 어떻게 해야 되냐?

6771
07:44:25,480 --> 07:44:28,460
래퍼 함수를 이런 식으로 수정을 하면 됩니다

6772
07:44:28,660 --> 07:44:31,820
그리고 안에 있는 당연히 오리지널
펑션에도 이걸 추가해야 되는데요

6773
07:44:31,940 --> 07:44:36,900
이렇게 두 개를 추가를 해주면
되는데 이거는 별표 붙은 거는...

6774
07:44:37,080 --> 07:44:41,900
arguments들이, 인수들이 여러
개가 들어와도 다 받겠다라는 의미죠

6775
07:44:41,940 --> 07:44:47,220
그리고 별표 두 개면 키 밸류로
들어오는 것도 딕셔너리 형태로 다 받겠다

6776
07:44:47,360 --> 07:44:52,840
앞에서 배운 개념인데 이런 식으로 어떤 게
들어올지 모르니까 왜냐하면 얘는 데코레이터잖아요

6777
07:44:53,060 --> 07:45:00,740
그래서 데코레이터라면 기존 함수가 어떤 게 들어올지
모르니까 그걸 다 받아주기 위해서 이런 식으로 추가를 해줍니다

6778
07:45:00,860 --> 07:45:05,857
그러면 이렇게 전달받는 인수가
어떤 것이 됐든 다 해당할 수가 있겠죠

6779
07:45:05,881 --> 07:45:12,880
그래서 이렇게 변경을 하고 실행을 하게 되면
정상적으로 잘 출력이 된 것을 확인할 수가 있습니다

6780
07:45:14,180 --> 07:45:16,580
이터레이터와 제너레이터에 대해서 배워보겠습니다

6781
07:45:16,920 --> 07:45:23,130
먼저 이터레이터를 이해하기 위해서 우선
리스트를 보면 리스트를 이렇게 정리를 하고

6782
07:45:23,154 --> 07:45:29,500
for문으로 a에 뽑아서 이걸 하나씩 이렇게
출력하는 거 이거는 이전에 배워서 익숙하시죠

6783
07:45:29,620 --> 07:45:34,797
그래서 이런 경우에 뒤에 있는 이런
for문 뒤에서 하나씩 뽑아서 쓸 수 있는 거

6784
07:45:34,821 --> 07:45:40,620
이런 객체를 반복 가능한 객체,
즉 iterable 객체라고 부릅니다

6785
07:45:40,700 --> 07:45:48,700
그러면 이터레이터란 어떤 거냐면 next라는 함수를
호출해서 다음 값을 하나씩 리턴해주는 그런 객체입니다

6786
07:45:50,740 --> 07:45:54,800
앞에서 이제 반복 가능하다라는 것의 의미를 알아봤는데요

6787
07:45:54,960 --> 07:45:57,120
이 두 개가 동일한 의미는 아닙니다

6788
07:45:57,180 --> 07:46:04,796
예를 들어서 그러면 리스트가 이제 반복 가능하니까
이것도 이터레이터냐 라고 하면 이게 이터레이터 이름입니다

6789
07:46:04,820 --> 07:46:07,880
그러면 next를 호출했을 때 이게 실행이 돼야겠죠

6790
07:46:08,040 --> 07:46:10,860
그런데 이거를 실행해보면 오류가 납니다

6791
07:46:11,000 --> 07:46:11,540
왜냐?

6792
07:46:11,620 --> 07:46:17,460
이 a에 들어간 건 리스트인데 list
object is not an iterator 라고 하죠

6793
07:46:17,520 --> 07:46:22,440
즉 이렇게 오류가 발생을 했는데
iterable 하다고 해서 이터레이터는 아닙니다

6794
07:46:22,520 --> 07:46:26,900
이렇게 next 함수를 쓸 수 있어야
그거를 이터레이터라고 부릅니다

6795
07:46:27,040 --> 07:46:33,660
그러면 이렇게 iterable한 반복 가능한 리스트를
이터레이터로 바꾸는 방법은 어떻게 되냐?

6796
07:46:33,700 --> 07:46:34,700
이렇게 하면 됩니다

6797
07:46:34,820 --> 07:46:42,820
Iist를 a에 담고 iter라는 함수로 감싸게 되면 이
a가 자료형 변환이 돼서 이터레이터로 변형이 됩니다

6798
07:46:45,520 --> 07:46:51,220
이거를 프린트를 해보면 이렇게 list
iterator라고 타입이 변환돼서 출력이 됐고요

6799
07:46:51,320 --> 07:46:58,020
그러면 이제는 print next를 하게 되면
이렇게 잘 출력이 된 것을 확인할 수가 있습니다

6800
07:46:58,360 --> 07:47:04,800
그러면 이제 한 번 출력했을 때는 1이 나오고
그러면 두 번 출력하게 되면 1, 2가 나오죠

6801
07:47:05,110 --> 07:47:08,640
그럼 세 번 출력하면 1, 2, 3까지 나옵니다

6802
07:47:08,700 --> 07:47:13,320
즉 이렇게 하나씩 빼가지고 next를
할 때마다 다음 게 출력이 되는 거죠

6803
07:47:13,460 --> 07:47:14,820
그럼 하나 더 하면 어떻게 될까요?

6804
07:47:14,980 --> 07:47:22,980
네 번 하게 되면 얘는 3개인데 네 번 하게 되면 1, 2, 3까지 잘
나오다가 네 번째에서는 next가 없기 때문에 이런 에러가 납니다.

6805
07:47:23,900 --> 07:47:27,560
Stop, stop iteration이라고
에러가 나오게 되죠

6806
07:47:27,640 --> 07:47:31,400
그래서 이렇게 stop iteration
예외가 발생하게 됩니다

6807
07:47:31,660 --> 07:47:36,740
그래서 이런 예외를 안 만들려면
이런 식으로 for문을 사용해주면 됩니다.

6808
07:47:36,880 --> 07:47:44,880
For문을 사용하게 되면 이 iterator 안에 있는 거를 하나씩
뽑아가지고 출력을 하고 다 뽑았으면 이제 종료가 되기 때문에 별도로 이제

6809
07:47:45,961 --> 07:47:53,040
언제 next가 끝나냐에 대해서 신경 쓸 필요 없이
자동으로 반복문을 통해서 next를 호출해주게 됩니다

6810
07:47:53,240 --> 07:47:57,920
그러면 이제 오류 없이 이렇게 1, 2,
3까지 출력되고 종료된 거를 볼 수가 있죠

6811
07:47:58,060 --> 07:48:04,777
그리고 iterator의 특징을 보면 이 for문을
끝나고 나서 한 번 더 이렇게 실행을 해주게 됩니다

6812
07:48:04,801 --> 07:48:11,360
그러면 처음에 여기서 1, 2, 3이 출력되고 그다음
for문에서는 아무것도 출력이 안 된 걸 볼 수가 있습니다

6813
07:48:11,500 --> 07:48:17,980
왜냐하면 iterator라는 거는 next, next, next를
통해서 하나씩 출력하고 나면 이제 끝나기 때문이죠

6814
07:48:18,080 --> 07:48:23,029
그래서 다음 for문에서는 다음
iterator가 나올 게 없기 때문에 즉 next를

6815
07:48:23,053 --> 07:48:28,480
호출해봤자 나올 게 없기 때문에 이제 더 이상
안 나오고 위에 for문만 나오고 끝나는 겁니다

6816
07:48:28,700 --> 07:48:34,500
즉 for문이나 next로 그 값을 한 번 읽으면
그 값을 다시 읽을 수 없다는 그런 특징인데요

6817
07:48:34,800 --> 07:48:42,800
이렇게 iter 함수를 통해서 리스트를 iterator로 바꿀 수
있는데 여기서 직접 iterator를 만드는 것도 해보도록 하겠습니다

6818
07:48:44,620 --> 07:48:48,300
그래서 iterator 만들기를 해보면
클래스로 구현을 할 수가 있는데요

6819
07:48:48,540 --> 07:48:50,780
이런 식으로 구현을 할 수가 있겠습니다

6820
07:48:51,120 --> 07:48:59,120
생성자를 이용해서는 iterable한 리스트 같은 데이터를
받아서 넣고 그리고 포지션은 처음에 0으로 설정을 합니다

6821
07:48:59,520 --> 07:49:07,520
그리고 iter랑 next라는 메소드를 추가해줬는데 이 언더바
언더바가 들어간 거는 항상 파이썬에서는 좀 특별한 의미를 가집니다

6822
07:49:08,110 --> 07:49:13,310
클래스에 iter라는 메소드를 구현하면
이 클래스는 반복 가능한 객체가 됩니다

6823
07:49:13,530 --> 07:49:19,210
그리고 이 iter 메소드를 구현할
경우 반드시 next 함수를 구현해야겠죠.

6824
07:49:19,390 --> 07:49:20,270
Iterator니까

6825
07:49:20,410 --> 07:49:22,490
그래서 next 함수를 구현해줘야 됩니다

6826
07:49:22,710 --> 07:49:29,430
그래서 next 메소드 안에는 반복 가능한 객체의
값을 하나씩 반환하는 그런 역할을 넣어주면 됩니다

6827
07:49:29,630 --> 07:49:32,230
그리고 리턴할 값이 없을 때 stop iteration

6828
07:49:32,770 --> 07:49:35,190
대외를 발생시키도록 만들면 되겠습니다

6829
07:49:35,370 --> 07:49:43,370
코드를 보면 iterator 이렇게 iter라는 메소드를 추가해줬고
그러면 next도 추가를 해줘야 되는데 여기서는 데이터의 총 개수,

6830
07:49:45,170 --> 07:49:53,170
랭을 통해서 구하고 포지션이랑 비교를 해서 이 포지션
0부터 인덱스를 하나씩 뽑아서 리졸트를 리턴해주게 됩니다

6831
07:49:53,990 --> 07:49:58,010
그리고 포지션에 1씩 더해가면서 인덱스를 하나씩 늘려가죠

6832
07:49:58,130 --> 07:50:05,790
그래서 이 인덱스가 총 개수를 넘어서게 되면 stop
iteration 예외 처리를 발생을 시켜서 오류를 띄워주게 됩니다

6833
07:50:05,950 --> 07:50:13,210
그러면 my iterator로 이렇게 아까와 마찬가지로 1,
2, 3이라는 리스트를 넣으면 이 i는 iterator가 되고요

6834
07:50:13,330 --> 07:50:20,390
그래서 이 iterator에서 아이템을 하나씩 뽑아서 for문으로
출력을 해주면 아까와 똑같이 1, 2, 3이라고 출력이 됩니다

6835
07:50:20,610 --> 07:50:23,430
그래서 iterator를 직접 만드는 방법을 알아봤습니다

6836
07:50:23,610 --> 07:50:27,070
이걸 조금 응용하면 이제 역으로
출력하는 것도 만들 수가 있습니다

6837
07:50:27,350 --> 07:50:31,507
이런 식으로 reverse iterator라는 클래스를 만들고 이런 식으로
reverse iterator라는 클래스를 만들고 이제 rtl의 입력도 끝에

6838
07:50:31,531 --> 07:50:39,531
있는 것처럼 이렇게 1과 20까지 만들어 준 다음 이제 next에 이번에는
반대로 인덱스에 끝부터 하나씩 줄어들면서 출력해 주도록 만들면 이렇게 처음에

6839
07:50:39,651 --> 07:50:47,651
포지션도 0이 아니라 전체 길이에서 1을 뺀 거 즉, 뒤의 인덱스 맨
끝에 인덱스 부터 하나씩 줄어들게 만들려고 이렇게 포지션을 잡아 줬고요

6840
07:50:47,850 --> 07:50:55,850
그리고 포지션에서 마이너스 1씩 해 가면서 맨 끝에서부터 출력을 한
다음에 그다음에 포지션이 0보다 작아지면, 즉 처음 인덱스, 인덱스 0번까지

6841
07:50:58,071 --> 07:51:04,030
출력하고 난 후에는 raise, stop iteration을
통해서 예외 처리를 하게 되면 어떻게 되냐?

6842
07:51:04,110 --> 07:51:09,150
똑같이 했을 때 이번에는 3, 2, 1
이렇게 역으로 출력이 되게 됩니다

6843
07:51:09,430 --> 07:51:11,510
이렇게 iterator를 알아봤고요

6844
07:51:11,670 --> 07:51:19,027
그다음에 generator에 대해서 소개를 드리면
generator는 iterator를 생성해 준 함수입니다

6845
07:51:19,051 --> 07:51:27,051
즉, generator로 생성한 객체는 iterator와 마찬가지로
next 함수를 호출하면 그 값을 차례대로 얻을 수 있습니다

6846
07:51:27,990 --> 07:51:35,990
예시를 보면 이렇게 함수를 정의해 주는데 여기
안에 yield라는 키워드로 a, b, c 이렇게 넣어줬습니다

6847
07:51:37,290 --> 07:51:40,010
그러면 이 함수는 generator인데요

6848
07:51:40,250 --> 07:51:43,970
그래서 type을 찍어보면 이렇게
generator라고 나오게 되고요

6849
07:51:44,170 --> 07:51:52,170
마찬가지로 이렇게 nextg라고 해서 이 generator에 next를
적용해보면 이렇게 a, 즉 순서대로 next를 쓸 때마다 얘는 a,

6850
07:51:54,810 --> 07:52:02,530
b, 3개를 쓰면 a, b, c 이런 식으로 iterator처럼
yield로 작성해 준 이 뒤에 값들이 하나씩 출력이 됩니다

6851
07:52:02,730 --> 07:52:10,050
이것도 마찬가지로 4개를 쓰게 되면 stop iteration이
뜨면서 여기서 정해준 값 이상으로는 뽑을 수가 없죠

6852
07:52:10,110 --> 07:52:13,250
다음으로 generator 표현식에 대해서 배워보겠습니다

6853
07:52:13,570 --> 07:52:16,330
이런 generator가 있다고 생각을 해보겠습니다.

6854
07:52:16,890 --> 07:52:17,726
Generator를...

6855
07:52:17,750 --> 07:52:24,978
예를 들어 만들어줬는데 1부터 1000 미만까지
제곱을 해서 그거를 하나씩 뱉어주는 이런

6856
07:52:25,002 --> 07:52:31,390
generator를 만들었다고 했을 때 이렇게 1의
제곱, 2의 제곱, 3의 제곱 이렇게 출력이 되겠죠

6857
07:52:31,510 --> 07:52:35,210
그런데 이런 generator를 좀 더
간편하게 만드는 방법이 있습니다

6858
07:52:35,410 --> 07:52:43,410
이렇게 함수를 정의하는 대신에 이렇게 한 줄로 간단하게 표현을 하게
되면 튜플처럼 보이는데 이 튜플 안에 리스트 표현식처럼 리스트도 좀 간편하게

6859
07:52:45,831 --> 07:52:53,130
만들기 위해서 대괄호 사이에 이런 식으로 적어주게 되면
리스트가 이 안에서 쫙 풀리면서 좀 간편하게 만들 수 있었잖아요

6860
07:52:53,210 --> 07:52:58,670
이 리스트 대신에 이 대괄호를 소괄호로
바꾸게 되면 이거는 이제 generator가 됩니다

6861
07:52:58,870 --> 07:53:05,663
그래서 이 안에 있는 리스트 표현식처럼
마찬가지로 1부터 1000 미만의 i를 가져와서

6862
07:53:05,687 --> 07:53:10,390
i 제곱을 해준 거 이거를 그대로
generator로 바로 만들 수가 있습니다

6863
07:53:10,610 --> 07:53:13,450
그래서 출력을 해보면 똑같이 나옵니다

6864
07:53:13,530 --> 07:53:16,650
그래서 generator를 쉽게 만드는 방법도 알아봤습니다

6865
07:53:16,790 --> 07:53:20,770
그래서 이런 방법으로는 generator
표현식을 generator 표현식이라고 부릅니다

6866
07:53:20,870 --> 07:53:25,670
그러면 generator와 iterator를 보면
사실 거의 비슷하다는 거를 볼 수가 있어요

6867
07:53:25,810 --> 07:53:28,470
그래서 좀 더 유리한 거를 선택하면 되는데요

6868
07:53:28,610 --> 07:53:33,899
예를 들어 이렇게 generator 표현식을
이용해서 만들 수 있는 이거를 만약에

6869
07:53:33,923 --> 07:53:38,450
class iterator로 구현을 한다 라고
하면 이렇게 길게 구현을 해야 됩니다

6870
07:53:38,690 --> 07:53:43,030
그래서 이럴 때는 이렇게 한 줄로
generator 표현식으로 만들면 좀 더 간편하겠죠

6871
07:53:43,190 --> 07:53:49,010
그리고 이게 이제 generator와 iterator의 가장 큰
차이인데 generator를 활용하기를 보도록 하겠습니다

6872
07:53:49,170 --> 07:53:50,990
이런 코드가 있다고 해보겠습니다

6873
07:53:51,290 --> 07:53:59,290
그러면 함수 중에 long time job이라는 오래 걸리는 함수가
있고 여기에 job start라고 하고 1초 지연을 일부러 줬습니다

6874
07:54:00,810 --> 07:54:06,490
그리고 끝나면 done이라고 나온다고
하면은 이 함수가 실행되는데 1초가 걸립니다

6875
07:54:06,610 --> 07:54:12,252
그러면 이제 list job을 만들어서
리스트 안에서 이 함수를 다섯 번

6876
07:54:12,276 --> 07:54:17,507
list job 안에 넣어준다고 하면은
그중에서 0번째 즉 첫 함수만 가져옵니다

6877
07:54:17,531 --> 07:54:21,110
이래 온다고 해도 이 list job을
만드는 데 5초가 걸리게 됩니다

6878
07:54:21,270 --> 07:54:29,270
실제로 실행을 해보면 job start start start start
start 이렇게 다섯 번이 출력이 되고 그 다음에 함수가 이렇게 다섯 개를

6879
07:54:30,991 --> 07:54:36,602
모두 다 정의한 상태로 0번 인덱스를 가져와서
실행했기 때문에 이제 return이 done이어서 이렇게 한

6880
07:54:36,626 --> 07:54:44,050
번 return이 나오는데 하나만 필요한데 나머지를
다 실행을 다 해놓고 불러와서 기다릴 필요는 없겠죠

6881
07:54:44,230 --> 07:54:46,870
그래서 이럴 때 generator를 사용합니다.

6882
07:54:47,530 --> 07:54:53,670
Iist를 이렇게 tuple처럼 소괄호로 바꿔서
이렇게 만들게 되면 generator라고 말씀을 드렸죠.

6883
07:54:54,130 --> 07:55:02,130
Generator를 쓰게 되면 이터레이터랑 가장 큰 차이점이
이터레이터는 데이터를 메모리에 쫙 다 올려놓고 실행을 하게 되는데요.

6884
07:55:02,510 --> 07:55:07,344
Generator의 경우 필요할 때마다
하나씩 생성을 하게 돼서 좀 메모리 사용을

6885
07:55:07,368 --> 07:55:11,530
효율적으로 할 수 있고 이런 작업의 경우
좀 더 효율적으로 처리를 할 수 있게 됩니다

6886
07:55:11,770 --> 07:55:15,370
여기서도 long time job을
generator로 바꿔주면 어떻게 되냐.

6887
07:55:15,730 --> 07:55:22,430
Next를 이용해서 첫 번째를 실행을 했을 때
바로 job start 한 번만 나오고 done이 나왔습니다

6888
07:55:22,510 --> 07:55:30,510
즉 이 generator 중에 next를 실행하게 되면 값을 꺼내오면서
그때 이 long time job이 한번 실행이 되고 done이 나오는 겁니다

6889
07:55:32,310 --> 07:55:38,797
즉 이거를 list job을 만드는데 다섯
번을 미리 다 메모리에 올려 놓고 하는 게

6890
07:55:38,821 --> 07:55:44,531
아니라 그냥 실행할 때마다 next가
실행될 때마다 딱 그때 그때 실행을 하는 거죠

6891
07:55:44,610 --> 07:55:51,110
그래서 메모리 효율적으로 그리고 이런 오래 걸리는
함수의 경우 이런 시간 효율적으로 사용할 수도 있습니다

6892
07:55:51,330 --> 07:55:59,330
그래서 이렇게 함수가 호출될 때마다 이렇게 실행하는
방법을 느긋한 계산법, 레이지 이벨루에이션이라고 부릅니다

6893
07:56:00,130 --> 07:56:04,830
다음으로 7-4 파이썬 타입
어노테이션에 대해서 배워보겠습니다

6894
07:56:05,110 --> 07:56:12,487
파이썬 3.5 버전부터 변수와 함수의 타입을 지정할
수 있는 타입 어노테이션 기능이 추가가 됐는데요

6895
07:56:12,511 --> 07:56:18,830
이게 어떤 건지 이해하려면 우선 동적
언어와 정적 언어에 대해서 알아보겠습니다

6896
07:56:19,010 --> 07:56:22,250
먼저 파이썬은 기본적으로 동적 언어인데요

6897
07:56:22,410 --> 07:56:30,410
그게 어떤 건지 보여드리면 이렇게 a는 1이라는 숫자를 넣고
타입을 찍어보면 이렇게 인트, 정수형 자료형이 나오게 됩니다

6898
07:56:31,550 --> 07:56:39,550
그리고 그 바로 아래줄에 다시 a는 1이라고 문자열로 넣게 되면 변수에
이렇게 문자열을 넣게 되면 타입이 스트링, 문자열 자료형으로 나오게 됩니다

6899
07:56:42,510 --> 07:56:50,390
그래서 a 변수의 타입이 프로그램 실행 중에 바뀔 수
있는 거 이런 거를 동적 프로그래밍 언어라고 부릅니다

6900
07:56:50,490 --> 07:56:56,830
그래서 파이썬이 대표적으로 동적 프로그래밍
언어에서 타입을 막 바꿔도 크게 오류가 발생하지 않습니다

6901
07:56:57,010 --> 07:57:03,581
그런데 자바와 같은 정적 프로그래밍
언어에서는 이런 식으로 인트 a는 1 변수를

6902
07:57:03,605 --> 07:57:09,767
인트형으로 지정을 하게 되면 a에 문자열을
넣으려고 했을 때 컴파일 에러가 발생합니다

6903
07:57:09,791 --> 07:57:16,650
왜냐하면 얘는 지정한 타입 외에 다른 타입을 못
넣도록 막아놓은 정적 프로그래밍 언어이기 때문입니다

6904
07:57:16,750 --> 07:57:20,350
그래서 자바의 경우에는 정적
프로그래밍 언어라서 이게 안 됩니다

6905
07:57:20,610 --> 07:57:22,030
그럼 이제 장단점이 있겠죠

6906
07:57:22,190 --> 07:57:25,930
동적 언어의 장점을 보면 유연한 코딩이 가능합니다

6907
07:57:26,170 --> 07:57:31,370
그래서 타입을 막 바꾸면서 작업을 하더라도
오류가 발생하지 않는다라는 유연성이 있고요

6908
07:57:31,570 --> 07:57:36,850
그리고 타입 체크를 위한 코드가 없기
때문에 깔끔한 소스 코드를 만들 수가 있습니다

6909
07:57:37,090 --> 07:57:45,090
그런데 이제 프로젝트가 커지고, 또 특히 안정성을 선호하는 이런
금융권에서는 타입을 잘못 사용하게 되면 버그가 생길 수도 있겠죠

6910
07:57:46,190 --> 07:57:54,190
그래서 타입을 철저하게 보는 게 중요한 금융권 프로젝트 이런
경우에는 주로 정적 언어를 택해서 작업을 하는 경우가 많습니다

6911
07:57:55,510 --> 07:58:03,510
그래서 이런 단점을 좀 극복하기 위해서 파이썬에서도 타입
어노테이션을 통해서 타입에 대한 힌트를 알려주는 기능을 추가했는데요

6912
07:58:04,430 --> 07:58:12,430
예시를 보면 이런 식으로 어떤 변수 num이라는 변수에 콜론
인트라고 적어주면 인트 자료형이라고 타입 어노테이션을 할 수가 있고요

6913
07:58:14,770 --> 07:58:22,204
그리고 함수의 경우에도 각각 a 콜론 인트, b 콜론
인트라고 하면 이렇게 들어온 인수가 인트형 자료형이

6914
07:58:22,304 --> 07:58:30,304
들어와야 된다라고 자료형을 정해줄 수 있고, 이렇게
화살표를 하고 리턴 값도 자료형을 지정해 줄 수가 있습니다

6915
07:58:31,250 --> 07:58:37,630
그래서 이렇게 어노테이션을 지정할 수 있는데 이게
어노테이션, 즉 힌트를 알려주는 정도의 기능입니다

6916
07:58:37,850 --> 07:58:44,490
이게 무슨 말이냐면, 이런 식으로 인트라고 지정해
놓고 다시 스트링을 넣는다고 해도 오류가 나지 않습니다

6917
07:58:44,590 --> 07:58:51,330
즉, 이렇게 보조적으로 도움을 주는 정도의 기능이고
실제로 타입을 어겼을 때 오류가 발생하지는 않습니다

6918
07:58:51,490 --> 07:58:59,490
함수도 의도와 다르게 써보면 이렇게 의도와 다르게 인트형이
아니라 문자열을 넣게 되면 그래도 문제 없이 잘 실행이 됩니다

6919
07:59:00,290 --> 07:59:06,670
즉, 이렇게 어노테이션을 해주는 것은 그냥
힌트를 알려주는 정도의 기능으로서 작용을 합니다

6920
07:59:06,850 --> 07:59:14,850
그러면 이거를 좀 철저하게 지키고 싶다면, 이럴 때는
마이파이와 같은 라이브러리를 설치해서 활용할 수가 있겠습니다

6921
07:59:15,930 --> 07:59:20,330
마이파이는 일단 파이썬 표준 라이브러리는
아니라서 별도로 설치를 해야 되는데요

6922
07:59:20,470 --> 07:59:23,210
이렇게 pip install mypi로
설치할 수가 있습니다

6923
07:59:23,570 --> 07:59:28,690
직접 설치를 해보면 pip install
mypi 이렇게 설치를 해보겠습니다

6924
07:59:28,990 --> 07:59:36,990
그리고 설치를 하고 나서 마이파이라는 걸로 지금 이렇게 작성한
파이썬 파일을 실행하게 되면 이런 식으로 자료 타입이 맞지 않는다

6925
07:59:39,170 --> 07:59:40,870
라는 에러를 띄워주게 됩니다

6926
07:59:41,070 --> 07:59:49,070
그래서 타입에 맞게 다시 바꿔서 실행을 해보면 그때는
success가 떠서 오류가 나오지 않는 것을 확인할 수가 있습니다

6927
07:59:49,710 --> 07:59:52,570
8장 정규 표현식을 배워보도록 하겠습니다

6928
07:59:53,150 --> 07:59:56,730
8-1 정규 표현식 살펴보기를 배워보겠습니다

6929
07:59:57,090 --> 08:00:05,090
우선 정규 표현식 regular expressions는 복잡한 문자열을
처리할 때 사용하는 기법으로 파이썬만의 고유한 것이 아닙니다

6930
08:00:05,511 --> 08:00:10,210
그래서 문자를 처리하는 모든 곳에
사용되는 일종의 형식 언어인데요

6931
08:00:10,330 --> 08:00:16,390
그래서 정규 표현식을 배우는 것은, 파이썬을 배우는
것과는 또 다른 영역의 과제라고 할 수 있겠습니다

6932
08:00:16,690 --> 08:00:23,910
그래서 정규표현식은 줄여서 정규식이라고 말하기도
하고요, 정규 표현식은 왜 필요한가를 알아보도록 하겠습니다

6933
08:00:24,250 --> 08:00:26,230
이런 문제가 주어졌다고 해보겠습니다

6934
08:00:27,510 --> 08:00:35,390
주민등록번호를 포함하고 있는 텍스트가 있을 때 주민등록번호
뒷자리를 별표 문자로 변경해야 하는 이런 작업이 있다고 해보겠습니다

6935
08:00:35,510 --> 08:00:41,590
그래서 정규 표현식을 전혀 모른다 라고 했을 때는
어떻게 해야 되냐 이런 식으로 할 수가 있겠습니다

6936
08:00:41,730 --> 08:00:47,602
전체 텍스트를 일단 공백 기준으로 다
나누고 그 다음에 나뉜 단어 중에 주민번호

6937
08:00:47,626 --> 08:00:53,926
형식이 있는지 조사를 한 다음에 단어가
주민번호 형식이라면 뒷자리를 별표로 변환한다

6938
08:00:53,950 --> 08:00:55,730
나뉜 단어를 다시 조립한다

6939
08:00:55,830 --> 08:00:57,590
이런 순서로 구현할 수가 있겠습니다

6940
08:00:57,790 --> 08:01:00,927
코드를 보자면 이런 식으로 구현할 수가 있겠는데요

6941
08:01:00,951 --> 08:01:08,951
이렇게 데이터가 있다고 했을 때 데이터를 스플릿으로 각행을 잘라서 또 그
각행을 띄어쓰기 기준으로 자르고 그 단어가 있다고 했을 때 글자의 길이가

6942
08:01:10,851 --> 08:01:18,851
14글자인지 확인하고 6번 인덱스까지 숫자인지 즉 이렇게 숫자인지 그리고
그 이후 뒷자리가 또 숫자인지 확인한 다음에 앞에 6자리는 그대로 놔두고 뒤에

6943
08:01:22,791 --> 08:01:30,791
별표를 더해줘서 단어를 만들어서 이렇게 결과에 저장을 해주고 그리고
출력을 해주면 이런 식으로 별표 처리도 그런데 이 코드가 굉장히 복잡하죠?

6944
08:01:33,590 --> 08:01:40,290
그래서 이런 문자열을 처리할 때 이런 식으로 정규
표현식을 쓰게 되면 단 두 줄로 해결이 가능합니다

6945
08:01:40,390 --> 08:01:48,390
그래서 정규 표현식으로 패턴을 만들고 이렇게 변경을
해준다고 쓰면 실행을 했을 때 똑같은 결과가 나옵니다

6946
08:01:48,830 --> 08:01:51,070
그런데 단 두 줄이면 끝낼 수 있죠

6947
08:01:51,210 --> 08:01:57,490
그래서 이렇게 문자열에서 특정 패턴을 찾는데 정규
표현식이 사용된다고 이해해 주시면 좋을 것 같고요

6948
08:01:57,590 --> 08:02:00,830
그래서 이런 걸 해결하기 위해서 정규 표현식을 배운다

6949
08:02:00,910 --> 08:02:02,530
라고 이해하시면 좋을 것 같습니다

6950
08:02:02,690 --> 08:02:06,330
8-2 정규 표현식 시작하기를 배워보겠습니다

6951
08:02:06,630 --> 08:02:14,006
우선 정규 표현식은 앞에서 살펴본 것처럼
어떤 특정 패턴과 일치하는지를 검사를 하는 건데요

6952
08:02:14,030 --> 08:02:18,010
그래서 그 특정 패턴을 찾기 위한 문자들이 사용됩니다

6953
08:02:18,150 --> 08:02:26,030
그래서 정규 표현식을 이해하려면 기본적으로 메타 문자에 대한
이해가 필요한데 메타 문자가 뭔지를 먼저 살펴보도록 하겠습니다

6954
08:02:26,310 --> 08:02:32,690
우선 메타 문자의 뜻을 보면 그 문자가 가진
뜻이 아니라 특별한 의미를 가진 문자를 말합니다

6955
08:02:32,810 --> 08:02:40,810
그래서 이런 거, 아니면 이런 캐럿 표시, 달러 표시, 별표 이런 거는 원래
그 기호의 의미가 아니라 정규 표현식에서의 특별한 의미를 가지게 됩니다

6956
08:02:43,850 --> 08:02:50,470
그래서 각각 이런 기호들이 정규 표현식에서
어떤 의미를 갖는지 하나씩 살펴보도록 하겠습니다

6957
08:02:50,830 --> 08:02:50,967
네

6958
08:02:50,991 --> 08:02:52,846
첫 번째로 문자 클래스

6959
08:02:52,870 --> 08:02:57,810
이렇게 대괄호 사이에 있는 어떤 문자들이
있을 때 이거의 의미를 알아보도록 하겠습니다

6960
08:02:58,030 --> 08:03:04,010
이렇게 되어 있다면 이 대괄호 사이의
문자들과 매치가 되는지를 보는 것입니다

6961
08:03:04,170 --> 08:03:12,170
그래서 여기서 a는 정규식과 일치하는 문자인 a가
있으므로 이것과 a는 매치한다라고 볼 수가 있습니다

6962
08:03:13,090 --> 08:03:19,070
그러면 before라는 문자가 있다고
하면 여기서 b라는 문자가 있죠

6963
08:03:19,230 --> 08:03:20,870
여기도 b라는 문자가 있고요

6964
08:03:21,070 --> 08:03:24,490
그래서 이 두 개도 매치한다라고 할 수가 있습니다

6965
08:03:24,790 --> 08:03:32,790
그런데 이렇게 du, de 이런 문자열의 경우에는 정규식과
일치하는 문자인 a, b, c 이 중에 하나도 같은 게 없죠

6966
08:03:33,150 --> 08:03:37,630
그래서 이렇게 두 개를 매칭
하나를 보면 매치되지가 않습니다

6967
08:03:37,910 --> 08:03:42,970
그래서 이렇게 문자 클래스 안에 내용과
매치를 하는지를 볼 수가 있겠습니다

6968
08:03:43,330 --> 08:03:48,050
그리고 좀 더 응용을 해보자면 하이픈을
사용하여 from to 표현도 가능합니다

6969
08:03:48,190 --> 08:03:56,110
예를 들어 이렇게 a, b, c 다 쓰지 않고
대괄호하고 a-c라고 하면 a부터 c까지입니다

6970
08:03:56,290 --> 08:04:00,610
즉 a, b, c, d 이렇게 순서대로
가니까 a, b, c랑 같은 의미가 되겠죠

6971
08:04:00,730 --> 08:04:08,730
그래서 a-c는 a, b, c고 0-o는 0부터 5까지의 의미로
이렇게 대괄호 안에 0부터 1, 2, 3, 4, 5가 들어간 거랑 같은 겁니다

6972
08:04:14,470 --> 08:04:20,030
그래서 이렇게 쭉 이어지는 거를 작성할 때는
하이픈을 통해서 간편하게 적어줄 수가 있겠죠

6973
08:04:20,250 --> 08:04:22,390
그 다음에 .이 있습니다

6974
08:04:22,650 --> 08:04:27,167
예를 들어 a.b 이런 식으로 표현이 된다고 하면 줄바꿈!

6975
08:04:27,191 --> 08:04:29,150
백슬래시 n이 줄바꿈 문자잖아요

6976
08:04:29,290 --> 08:04:32,410
그래서 이거를 제외한 모든 문자와 매치가 됩니다

6977
08:04:32,650 --> 08:04:33,470
점이 들어가면

6978
08:04:33,530 --> 08:04:41,530
예를 들어서 a, a, b라는 문자열이 있으면 가운데 문자가
a가 모든 문자를 의미하는 점과 일치함으로 그래서 이거랑 a, a,

6979
08:04:43,270 --> 08:04:51,270
b랑 보면 이 가운데가 a랑 모든 문자를 의미하는 점이랑 이렇게
매치를 할 수 있으니까 이렇게는 매치가 된다고 할 수 있습니다

6980
08:04:52,550 --> 08:04:54,470
두 번째 a, 0, b

6981
08:04:54,630 --> 08:04:56,410
이것도 가운데 0이라는...

6982
08:04:57,190 --> 08:05:03,990
이것이 모든 문자를 의미하는 점과 일치함으로
이렇게 매치를 해보면 매치한다고 볼 수가 있겠습니다

6983
08:05:04,190 --> 08:05:06,670
그러면 a, b, c의 경우에는 어떨까요?

6984
08:05:06,790 --> 08:05:14,790
A, b, c와 이걸 비교해보면 이렇게 매치를 시도해보면 a와 b 사이에 이
점이 있다는 거는 뭔가 하나라도 있어야 되는데 이 사이에 어떤 것도 없죠

6985
08:05:16,810 --> 08:05:21,650
그렇기 때문에 일치하지 않으므로
매치되지 않는다고 표현할 수 있겠습니다

6986
08:05:21,890 --> 08:05:24,030
즉 이렇게는 매치되지가 않습니다

6987
08:05:24,230 --> 08:05:25,670
다음으로 반복!

6988
08:05:25,810 --> 08:05:26,987
별표시에 대해서

6989
08:05:27,011 --> 08:05:27,830
알아보겠습니다

6990
08:05:28,030 --> 08:05:31,390
C하고 a 별표 t 이렇게 돼 있죠

6991
08:05:31,510 --> 08:05:35,310
그러면 이 a가 몇 번 반복된다의 의미입니다

6992
08:05:35,450 --> 08:05:41,230
그래서 이런 c, t 같은 경우에 a가
0번 반복, 0번 반복도 포함입니다

6993
08:05:41,390 --> 08:05:49,390
그래서 0번 반복되어 매치된다고 하는데 이렇게 비교를 해보면 c와
t 사이에 a가 0번 반복도 포함이 돼서 매치가 된다고 할 수 있습니다

6994
08:05:51,390 --> 08:05:56,470
다음으로 c, a, t 이렇게 되는
경우에도 a가 한 번 반복되죠

6995
08:05:57,010 --> 08:06:00,690
그래서 0번 이상이 돼서 1번 반복으로 매치가 됩니다

6996
08:06:00,950 --> 08:06:06,990
C, a, a, a, t도 마찬가지로 0번 이상만
반복되면 되니까 3번 반복이 되고 있죠

6997
08:06:07,110 --> 08:06:08,930
그래서 이것도 매치를 합니다

6998
08:06:09,270 --> 08:06:12,670
다음으로 비슷하게 반복을 나타내는 플러스 기호도 있는데요

6999
08:06:13,250 --> 08:06:18,830
이것도 c, a, t 이렇게 돼 있으면
a가 한 번 이상 반복이 돼야 됩니다

7000
08:06:19,050 --> 08:06:24,650
그래서 c, t랑 매치하는지를 보면 0번
반복되기 때문에 매치하지가 않습니다

7001
08:06:24,810 --> 08:06:32,810
그런데 c, a, t는 1번 이상 반복되고 반복이 돼서 매칭이 되고
마찬가지로 CAAT도 세 번 반복이 됐기 때문에 이렇게 두 개는 매치가 됩니다

7002
08:06:35,830 --> 08:06:39,110
다음으로 반복의 중괄호를 이용한 방법이 있습니다

7003
08:06:39,310 --> 08:06:46,507
예를 들어 CA 중괄호 2라고 되어 있으면
이거는 몇 번이라고 지정을 해주는 건데요

7004
08:06:46,531 --> 08:06:54,531
그러면 A가 두 번 반복돼야 된다라는 표시인데 CAT는
A가 한 번밖에 반복이 되지 않으니까 매치되지가 않습니다

7005
08:06:55,491 --> 08:06:59,810
그런데 CAAT, 이거는 딱 정확하게 두 번 일치하죠

7006
08:06:59,950 --> 08:07:02,750
그래서 A가 두 번 반복되어 매치가 됩니다

7007
08:07:03,250 --> 08:07:11,170
좀 더 구체적으로 M과 N에 대해서 설명드리면
최소 N번, 최대 N번으로 지정할 수가 있습니다

7008
08:07:11,490 --> 08:07:16,750
추가로 물음표의 경우에는 0번 혹은 1번 반복을 의미합니다

7009
08:07:17,010 --> 08:07:24,610
다음으로 이렇게 숫자가 두 개 들어가는 경우
이때는 최소 2번, 최대 5번 반복의 의미입니다

7010
08:07:24,730 --> 08:07:30,866
예를 들어 예를 들어 CAT와 비교해보면 두 번에서
다섯 번이 아니기 때문에 한 번밖에 안 됐죠, 반복이

7011
08:07:30,890 --> 08:07:32,230
그래서 매치되지가 않고요

7012
08:07:32,670 --> 08:07:35,330
CAT는 A가 두 번 반복이 되죠

7013
08:07:35,390 --> 08:07:37,530
그래서 여기에 해당돼서 매치가 됩니다

7014
08:07:38,190 --> 08:07:44,210
CAAA, 이 다섯 번 되는 것도 다섯 번, 최대
다섯 번이니까 이게 만족이 돼서 매치가 됩니다

7015
08:07:44,690 --> 08:07:51,130
다음으로 물음표를 보면 물음표는
0번 혹은 1번 반복의 의미입니다

7016
08:07:51,270 --> 08:07:56,250
예를 들어 ABC의 경우 한 번
반복이 되기 때문에 매치가 되고요

7017
08:07:56,370 --> 08:08:03,290
그다음에 AC의 경우에도 이렇게 두 개가
B가 0번 반복되기 때문에 매치가 됩니다

7018
08:08:03,530 --> 08:08:10,510
그러면 이거를 물음표랑 최소 0번, 최대
1번 이렇게 표현하는 거랑 같은 표현입니다

7019
08:08:10,790 --> 08:08:14,446
그래서 이거를 쓰는 거랑 이 뒤에 물음표를 쓰는 거랑 같다

7020
08:08:14,470 --> 08:08:16,170
라고 알아주시면 좋을 것 같습니다

7021
08:08:16,490 --> 08:08:16,530
네

7022
08:08:16,590 --> 08:08:21,986
그다음에 이제 본격적으로 파이썬에서
정규 표현식을 사용하는 것을 알아볼 건데요

7023
08:08:22,010 --> 08:08:24,830
파이썬에서 정규 표현식을 사용할 때는 RE

7024
08:08:25,150 --> 08:08:26,570
라는 모듈을 사용합니다

7025
08:08:26,690 --> 08:08:34,690
RE는 Regular Expression의 약자인데 이렇게 Import RE를
통해서 정규 표현식 관련 기능들을 파이썬에서 사용할 수가 있습니다

7026
08:08:36,050 --> 08:08:36,147
네

7027
08:08:36,171 --> 08:08:37,387
한 번 써보면 네

7028
08:08:37,411 --> 08:08:43,390
이런 식으로 RE라는 모듈을
불러와서 RE.Compile하고 A, B, 별표

7029
08:08:43,470 --> 08:08:46,050
이게 0번 이상 반복의 의미였죠

7030
08:08:46,130 --> 08:08:50,770
그래서 이런 식으로 컴파일을 통해서
패턴 객체라는 거를 만들 수가 있습니다

7031
08:08:50,970 --> 08:08:53,947
그래서 이 패턴 객체가 뭔지는 이어서 설명드리겠습니다

7032
08:08:53,971 --> 08:09:01,350
이렇게 정규 표현식을 컴파일해서 나온 패턴 객체의
경우 이렇게 4가지 메서드를 사용할 수가 있는데요

7033
08:09:01,570 --> 08:09:03,270
하나씩 알아보도록 하겠습니다

7034
08:09:03,510 --> 08:09:05,030
먼저 Match 입니다.

7035
08:09:05,230 --> 08:09:11,930
Match 메서드는 문자열에 처음부터 정규식과
매치되는지 조사를 하는 그런 메서드인데요

7036
08:09:12,150 --> 08:09:14,110
예제를 통해서 알아보겠습니다

7037
08:09:14,610 --> 08:09:20,250
이런 식으로 RE 모듈을 불러와서
컴파일을 통해서 패턴 객체를 만들고요

7038
08:09:20,370 --> 08:09:23,927
이 패턴은 A부터 G 즉 소문자 ivory죠

7039
08:09:23,951 --> 08:09:28,010
에 대해서 플러스라는 것은 한 번 이상 반복이죠

7040
08:09:28,170 --> 08:09:33,410
그래서 정리해보면 소문자 알파벳들로
구성되어 있는지를 보는 패턴 객체가 있습니다

7041
08:09:33,710 --> 08:09:41,710
여기에 .match를 이용하게 되면 이 안에 들어가는 파이썬,
이 문자열에 대해서 이 패턴과 매치하는지를 보게 됩니다

7042
08:09:42,550 --> 08:09:47,270
그래서 실제로 테스트를 해보면
이렇게 객체가 나온 것을 볼 수가 있습니다

7043
08:09:47,490 --> 08:09:53,650
그래서 match python이라고도 나오는데
이렇게 매치가 성공하면 매치 객체가 나오게 되고요

7044
08:09:53,950 --> 08:09:56,310
그러면 매치 성공하지 않게 만들어 보겠습니다

7045
08:09:56,490 --> 08:10:01,650
숫자를 넣고 띄어쓰기 넣고 이렇게
넣으면 이제 이 패턴이랑 매치가 되지 않죠

7046
08:10:01,710 --> 08:10:05,290
이 안에 들어간 문자열이랑 이렇게
두 개가 매치되지 않으면 어떻게 되냐

7047
08:10:05,330 --> 08:10:08,130
실행을 해보면 이렇게 none이라는 게 나옵니다

7048
08:10:08,270 --> 08:10:11,610
그래서 패턴 객체의 매치 메소드를 알아봤고요

7049
08:10:11,770 --> 08:10:19,770
그 다음에 search 메소드를 알아보면 매치 대신에
search로 바꿔서 써보면 search는 뭐냐면 탐색을 하는 건데요

7050
08:10:20,370 --> 08:10:28,370
여기서 똑같이 실행을 해보면 탐색해서 동일한... 동일하게 매치 객체가
python일 때는 이렇게 두 개가 매칭이 돼서 나온 걸 볼 수가 있는데요

7051
08:10:29,270 --> 08:10:37,190
여기서 차이점은 이렇게 일부러 패턴을 틀리게 한 다음에
매치를 시켜보면 search일 때는 매치가 된 걸 볼 수가 있습니다

7052
08:10:37,390 --> 08:10:43,280
왜 그러냐면 매치 메소드일 때는
처음부터 이걸 검사하게 되는데 search는

7053
08:10:43,304 --> 08:10:48,670
처음부터가 아니더라도 뒤에서 매치하게
되면 이렇게 매치 객체를 돌려주게 됩니다

7054
08:10:48,910 --> 08:10:52,730
그래서 이게 매치와 search의
차이라고 보시면 되겠습니다

7055
08:10:52,970 --> 08:10:53,550
다음으로...

7056
08:10:53,950 --> 08:10:56,130
findAll 메소드를 알아보겠습니다

7057
08:10:56,330 --> 08:11:02,916
패턴 객체의 findAll 메소드를 쓰게
되면 여기 들어가는 문자열과 이 패턴을

7058
08:11:02,940 --> 08:11:08,310
보고 이렇게 일치하는 것들을 다 리스트
형태로 돌려주는 것을 볼 수가 있습니다

7059
08:11:08,530 --> 08:11:10,630
즉, life is too short

7060
08:11:10,730 --> 08:11:13,270
다 소문자로 구성된 반복되는 거죠

7061
08:11:13,430 --> 08:11:17,250
이렇게 매치하는 것들을 리스트
형태로 이렇게 리턴을 해주게 됩니다

7062
08:11:17,470 --> 08:11:22,650
그래서 findAll은 매치되는 모든 값을
찾아서 리스트로 리턴한다고 보시면 되겠습니다

7063
08:11:22,890 --> 08:11:26,310
그 다음에 findAll... findEter의
경우 어떻게 되는지 보겠습니다.

7064
08:11:26,850 --> 08:11:30,910
FindEter를 쓰게 되면 이렇게
아까와 다르게 객체가 리턴이 되는데요.

7065
08:11:31,410 --> 08:11:32,710
Iterator라고 써있죠

7066
08:11:32,790 --> 08:11:38,569
그러면 앞서 배운 대로 이제 iterator니까
for문을 통해서 이 리절트에 나온 걸

7067
08:11:38,593 --> 08:11:43,850
하나씩 뽑아서 출력을 하게 되면 이렇게 매치
객체가 하나씩 나오는 것을 확인할 수가 있습니다

7068
08:11:44,170 --> 08:11:49,640
그래서 findEter, findAll 거의 기능은
동일한데 이제 결과로 리턴하는 게

7069
08:11:49,664 --> 08:11:54,390
리스트냐 아니면 findEter의 경우 반복
가능한 객체이냐에 따라서 자기가 있습니다

7070
08:11:54,610 --> 08:11:59,470
그리고 반복 가능한 객체를
리턴할 때는 그 값이 매치 객체입니다

7071
08:11:59,570 --> 08:12:03,250
그래서 이렇게 매치 객체를 돌려주는 경우가 있는데요

7072
08:12:03,510 --> 08:12:06,690
요거가 어떤 건지 좀 더 자세히 알아보도록 하겠습니다

7073
08:12:06,930 --> 08:12:13,410
그래서 매치 객체에 대해서 이 매치 객체에서 쓸 수
있는 메서드가 뭐가 있는지 알아보도록 하겠습니다

7074
08:12:13,650 --> 08:12:21,650
그래서 패턴을 통해서 패턴의 메서드로 매치 객체를 돌려받았을
경우 그 매치 객체로 어떤 걸 할 수 있냐 이런 것들을 할 수가 있습니다

7075
08:12:22,510 --> 08:12:27,530
그래서 그룹, 스타트... 매치 객체에서
이런 것들을 이용할 수가 있는데요

7076
08:12:27,710 --> 08:12:29,010
하나씩 보도록 하겠습니다

7077
08:12:29,310 --> 08:12:35,827
아까 패턴 객체에서 매치 메서드를 통해서
이렇게 매치하고 매치 객체를 돌려받은 다음에

7078
08:12:35,851 --> 08:12:41,770
매치 객체를 리턴받아서 여기에 그룹,
스타트, 엔드, 스팬 각각을 출력을 해보겠습니다

7079
08:12:42,130 --> 08:12:47,767
이걸 실행해보면 매치 객체에서 각각 그룹을
하면 파이썬, 즉 매치된 문자열이 나오고요

7080
08:12:47,791 --> 08:12:54,330
그 다음에 스타트하면 시작되는 인덱스,
그리고 엔드는 끝 인덱스인데 미만입니다

7081
08:12:54,510 --> 08:13:01,510
즉 스팬하면 0 이상, 6 미만의 인덱스에서
매치를 했다라는 걸 알 수가 있는데요

7082
08:13:01,810 --> 08:13:06,450
이런 식으로 시작, 끝, 구간을 이렇게
튜플 형태로도 받을 수가 있습니다

7083
08:13:06,730 --> 08:13:10,506
정리하자면 그룹은 매치된 문자열을 리턴하고요

7084
08:13:10,530 --> 08:13:17,770
스타트는 매치된 문자열의 시작 위치를 리턴하고
엔드는 매치된 문자열의 끝 위치를 리턴하고요

7085
08:13:18,830 --> 08:13:24,910
스팬은 매치된 문자열의 시작과 끝에
해당하는 튜플을 리턴을 하게 됩니다

7086
08:13:25,070 --> 08:13:29,250
그러면 이거를 설치로 바꿔서
이런 식으로 바꿔보도록 하겠습니다

7087
08:13:29,550 --> 08:13:35,970
그러면 설치는 처음부터 매칭을 확인하지 않기 때문에
이렇게 중간에 나와도 매치 객체를 받을 수가 있고요

7088
08:13:36,190 --> 08:13:44,190
그리고 그룹을 하면 매치된 문자열인 파이썬, 그리고
스타트를 하게 되면 0, 1, 2, 두 번째 인덱스부터 시작되죠

7089
08:13:44,730 --> 08:13:47,766
그래서 2가 나오고, 엔드는 3, 4, 5입니다

7090
08:13:47,790 --> 08:13:53,050
5, 6, 7하고 8이 끝이고 8
미만까지가 이제 일치가 되어있죠

7091
08:13:53,110 --> 08:14:00,210
그래서 8이 나오고, 그래서 튜플로 매치된
스타트 엔드를 찍으면 2, 8 이렇게 나오게 되겠습니다

7092
08:14:00,490 --> 08:14:05,130
다음으로 정규식을 컴파일할 때 옵션을 줄 수가 있는데요

7093
08:14:05,350 --> 08:14:08,810
어떤 옵션을 줄 수 있는지 하나씩 알아보도록 하겠습니다

7094
08:14:09,070 --> 08:14:11,610
네, 이렇게 네 가지 옵션을 배워볼 건데요

7095
08:14:11,670 --> 08:14:19,670
Dot all 줄여서 s, ignore case 줄여서 i, multiline
줄여서 m, 줄여서 x, 이렇게 옵션을 지정할 수가 있습니다

7096
08:14:21,430 --> 08:14:24,070
각각을 실습하면서 배워보도록 하겠습니다

7097
08:14:24,350 --> 08:14:27,450
먼저 dot all, s부터 알아보도록 하겠습니다

7098
08:14:27,730 --> 08:14:35,730
처음에 배웠던 것처럼 점에 해당하는 메타 문자는 줄
바꾼 문자를 제외한 모든 문자와 매치되는 규칙이 있습니다

7099
08:14:36,050 --> 08:14:44,050
그런데 여기서 줄 바꾼 문자도 포함하여 매치하고 싶다면 dot
all 또는 줄여서 s 옵션을 적용해서 정규식을 컴파일하면 됩니다

7100
08:14:45,110 --> 08:14:51,093
실제로 코드를 보면은 이렇게 기본적으로
정규표현식에서 점은 실행을 해보면 이 줄 바꾼

7101
08:14:51,117 --> 08:14:56,231
문자가 제외이기 때문에 해당이 안 되고
매치가 안 돼서 none이 나오는 걸 볼 수가 있죠

7102
08:14:56,530 --> 08:14:59,910
그런데 여기서 컴파일 옵션을 적용할 수가 있습니다

7103
08:15:00,230 --> 08:15:08,230
이렇게 컴파일할 때 re. Dot all이라는 옵션을 여기에
적용하게 되면 이때는 줄 바꾼 문자도 포함이 됩니다

7104
08:15:09,090 --> 08:15:16,466
그래서 원래는 none으로 나왔다가 이 옵션을 적용하게
되면 이렇게 매치 객체를 얻은 것을 볼 수 있습니다

7105
08:15:16,490 --> 08:15:21,190
다음으로 ignore case i에 대해서 알아보겠습니다

7106
08:15:21,390 --> 08:15:26,610
이 옵션은 대소문자 구분 없이
매치를 수행할 때 사용하는 옵션인데요

7107
08:15:26,750 --> 08:15:28,150
코드를 보도록 하겠습니다

7108
08:15:28,570 --> 08:15:36,570
기본적으로 이렇게 소문자 a부터 z까지 한 번 이상
반복을 이용해서 매치를 해보게 되면 처음 거는 다 소문자이기

7109
08:15:36,739 --> 08:15:42,770
때문에 바로 매치가 되는데 대문자가 들어가게 되면
이렇게 매치가 안 돼서 none이 나오는 걸 볼 수가 있죠

7110
08:15:42,910 --> 08:15:46,466
그래서 이거를 대소문자 상관없이 매치를 시키고 싶습니다

7111
08:15:46,490 --> 08:15:52,705
그러면 re. Ignore case 혹은 이렇게 약자로
적어도 되는데 re. I 이거를 옵션으로 컴파일할

7112
08:15:52,729 --> 08:15:59,130
때 추가를 해주게 되면 이제는 실행을 해봤을 때
대소문자 구분 없이 매칭이 되는 것을 볼 수가 있습니다

7113
08:15:59,290 --> 08:16:07,290
다음으로 멀티라인 m 옵션을 보게 되면 이거는 이제
뒤에 나올 메타 문자인 캐럿과 달러 표시와 연관된 옵션인데요

7114
08:16:08,030 --> 08:16:12,766
우선 간단히 설명드리면 캐럿
문자는 문자열에 처음을 의미하고요

7115
08:16:12,790 --> 08:16:15,467
달러 표시는 문자열에 마지막을 의미합니다

7116
08:16:15,491 --> 08:16:22,709
예를 들어 정규식이 캐럿 파이썬인 경우에 문자열에
처음은 항상 파이썬으로 시작해야 매치가 되는 거고 만약

7117
08:16:22,733 --> 08:16:29,210
정규식이 파이썬하고 이 달러 표시가 있으면 문자열에
마지막이 파이썬으로 끝나야 매치된다는 의미입니다

7118
08:16:29,310 --> 08:16:35,960
그래서 원래 이런 의미가 있는데 이 옵션을 언제
쓰는지 보여드리면 이렇게 캐럿 표시를 통해서 파이썬으로

7119
08:16:35,984 --> 08:16:43,170
시작되는 거를 찾는다 라고 했을 때 find all을
하게 되면 파이썬 1 이렇게 하나밖에 안 나오게 됩니다

7120
08:16:43,330 --> 08:16:51,237
이렇게 여러 줄로 들어가 있을 때 시작 이 파이썬
이게 시작되는 게 이것도 있는데 세 번째 줄 다섯 번째

7121
08:16:51,261 --> 08:16:58,930
줄도 해당이 되지만 줄바꿈이 있기 때문에 이거는
처음을 의미하는 캐럿에 해당되지 않아서 안 나오게 되는데요

7122
08:16:59,050 --> 08:17:06,213
여기 컴파일할 때 멀티라인 옵션을 주게
되면 이제는 파이썬 1뿐만 아니라 세 번째 다섯

7123
08:17:06,237 --> 08:17:11,830
번째 줄에 해당하는 파이썬 2 파이썬
3까지도 다 매치가 된 것을 볼 수가 있습니다

7124
08:17:12,050 --> 08:17:19,976
즉 이런 줄바꿈 옵션이 추가됨으로써
그래서 정리하면 멀티라인 옵션은 시작, 끝을

7125
08:17:20,000 --> 08:17:26,990
의미하는 메타 문자와 함께 적용돼서
문자열에 각 줄마다 적용해주는 옵션입니다

7126
08:17:27,150 --> 08:17:33,870
다음으로 verbose, x 옵션에 대해서 알아보면
정규식은 좀 복잡하게 쓰게 되면 정말 복잡합니다

7127
08:17:34,010 --> 08:17:37,270
그래서 길어지게 되면 진짜 암호처럼 보이는데요

7128
08:17:37,470 --> 08:17:42,427
이런 정규식을 주석을 달거나 줄
단위로 구분할 수 있으면 좋겠죠

7129
08:17:42,451 --> 08:17:47,450
그래서 이런 경우에 이런 verbose
혹은 x 옵션을 사용하게 됩니다

7130
08:17:47,630 --> 08:17:52,150
그래서 예시를 보면 이런 정규식이
있다고 했을 때 굉장히 복잡하죠

7131
08:17:52,290 --> 08:17:57,963
그래서 한 번에 이해하기가 되게 어려운데 여기에
좀 주석을 추가해주고 싶다라고 한다면 이런 식으로

7132
08:17:57,987 --> 08:18:05,770
verbose라는 옵션을 주고 이 컴파일 안쪽에 주석을
작성해주게 되면 좀 더 이해하기가 좋게 쓸 수가 있겠죠

7133
08:18:05,910 --> 08:18:12,426
즉 이 verbose 옵션을 사용하면 문자열에 사용된
화이트 스페이스는 컴파일 단에서 제거가 됩니다

7134
08:18:12,450 --> 08:18:17,430
물론 이제 대괄호 안에 있는 거는
정규식에 포함될 수 있으니 이거는 제외되고요

7135
08:18:17,570 --> 08:18:20,950
다음으로 역슬래시 문제에 대해서 알아보겠습니다

7136
08:18:21,250 --> 08:18:28,070
이거는 이제 정규표현식을 사용할 때 파이썬에서 혼란을
줄 수 있는 요소가 있어서 이거는 짚어보도록 하겠습니다

7137
08:18:28,370 --> 08:18:36,370
역슬래시가 파이썬에서 어떻게 사용되는지 보면은 어떤 파일 안에
역슬래시 섹션이라는 문자열을 찾기 위한 정규식을 만든다고 생각해보겠습니다

7138
08:18:38,850 --> 08:18:42,270
그런데 이제 역슬래시가 좀 특별한 기능을 하잖아요

7139
08:18:42,450 --> 08:18:49,330
특히 이제 정규식에서 역슬래시 s라는 문자가
화이트 스페이스 즉 띄어쓰기랑 같은 의미가 됩니다

7140
08:18:49,470 --> 08:18:54,250
그래서 매치되는 거를 검사하려고 하니까
요게 이제 띄어쓰기로 인식이 되는 거죠

7141
08:18:54,390 --> 08:18:58,150
그래서 의도한 대로 하려면
역슬래시를 하나 더 써줘야 됩니다

7142
08:18:58,350 --> 08:19:02,470
그래서 두 개를 사용해서 escape 처리를 해야 되는데요

7143
08:19:02,590 --> 08:19:05,370
그런데 이렇게 하면 또 문제가 생깁니다

7144
08:19:05,470 --> 08:19:12,426
파이썬 문자열에서 역슬래시 문제를 해결하기
위해서 기본적으로 역슬래시 두 개를 쓰면 그게 됩니다

7145
08:19:12,450 --> 08:19:14,210
이게 하나의 역슬래시로 변경이 됩니다

7146
08:19:14,450 --> 08:19:21,890
그래서 요런 식으로 결국에 결과적으로 전달이 되는데 그러면
마찬가지로 이 화이트 스페이스로 인식이 되는 문제가 있겠죠

7147
08:19:22,050 --> 08:19:27,130
그래서 제대로 전달을 하려면 이렇게
역슬래시 네 개를 써야 되는 문제가 있습니다

7148
08:19:27,470 --> 08:19:33,530
그래서 이런 복잡한 문제를 해결하기 위해서
파이썬에서는 rowString이라는 표현법이 있습니다

7149
08:19:33,770 --> 08:19:41,770
이거는 뭐냐면 r이라고 써주고 문자열 안에
역슬래시를 써주게 되면 이거는 rowString 규칙에

7150
08:19:41,862 --> 08:19:48,230
따라서 역슬래시 두 개 대신에 한 개만 써도
두 개를 쓴 것과 동일한 의미를 가지게 됩니다

7151
08:19:48,390 --> 08:19:52,570
그래서 이거를 사용하면 조금
더 직관적으로 쓸 수가 있겠습니다

7152
08:19:52,910 --> 08:20:00,510
그러면 이제 r이 들어가는데 역슬래시를 사용하지 않는
정규식이라면 r 유무에 상관없이 이제 동일한 정규식이 됩니다

7153
08:20:00,770 --> 08:20:05,310
8-3 강력한 정규 표현식의 세계로를 나가보도록 하겠습니다

7154
08:20:05,830 --> 08:20:08,970
우선 약간 경고를 하자면 굉장히 어렵습니다

7155
08:20:09,150 --> 08:20:16,090
그래서 이 내용들은 사실 좀 난이도가 있고, 그리고
필요성에 대해서도 요즘에는 굉장히 좀 낮은 편입니다

7156
08:20:16,230 --> 08:20:16,770
왜냐?

7157
08:20:16,830 --> 08:20:20,470
채찍피티 같은 AI가 이런 걸 너무나 잘해줍니다

7158
08:20:20,610 --> 08:20:26,299
그래서 사람이 이거를 굳이 알 필요가
있나 싶을 정도로 잘 해석도 해주고, 만들어

7159
08:20:26,323 --> 08:20:31,030
달라면 만들어줘서 그냥 이런 게 있구나
정도로 가볍게 보시는 걸 추천드립니다

7160
08:20:31,390 --> 08:20:36,470
그러면 이제 문자열 소비가 없는
메타 문자부터 나가보도록 하겠습니다

7161
08:20:36,830 --> 08:20:39,927
우선 메타 문자는 이전 시간에도 배웠는데요

7162
08:20:39,951 --> 08:20:47,951
플러스 1번 이상 반복, 별표는 0번 이상 반복, 이런 메타 문자들은
매치가 성사가 되면 문자열을 탐색하는 시작 위치가 변경이 됩니다

7163
08:20:50,910 --> 08:20:58,910
보통 이제 소비된다라고 표현을 하는데, 예를 들어서 AAC라는 문자열에서
A플러스, 즉 A가 한 번 이상 반복이라는 패턴을 찾아야 된다고 했을 때,

7164
08:21:01,510 --> 08:21:09,267
이때 AAC 중에 AA가 매치가 되면 이제
AA가 소비가 되고 C가 시작 위치가 됩니다

7165
08:21:09,291 --> 08:21:15,110
그런데 이제 이 뒤에 나올 메타 문자들은 소비가
되는 건 아닌 그런 문자를 배워보도록 하겠습니다

7166
08:21:15,290 --> 08:21:17,830
먼저 이런 파이프 기호가 있습니다

7167
08:21:18,030 --> 08:21:21,250
파이프 문자는 OR와 동일한 의미로 사용이 되는데요

7168
08:21:21,430 --> 08:21:29,430
예를 들어서 예시를 보면, 이렇게 crow 하고 pipe, servo
이렇게 되어 있으면 crow 또는 servo랑 같은 의미입니다

7169
08:21:30,110 --> 08:21:38,030
그래서 실행을 해보면 이렇게 crowhello라고 되어
있어서 crow랑 일치해서 매치 객체가 나온 것을 볼 수가 있죠

7170
08:21:38,150 --> 08:21:39,266
그러면 OR의 객체가 이렇게 되어있습니다

7171
08:21:39,290 --> 08:21:45,290
이 객체가 이 뒤에 의미니까 이 뒤에 거가 crow
대신에 나와도 마찬가지로 매치 객체가 나오고요

7172
08:21:45,390 --> 08:21:48,230
이때 servo랑 매치가 된 것을 볼 수가 있죠

7173
08:21:48,350 --> 08:21:55,490
다음으로 메타문자 carrot을 소개해 드리면, 이것은 앞에서도
나왔는데 문자열의 맨 처음과 일치한다는 것을 의미합니다

7174
08:21:55,670 --> 08:22:03,590
그리고 compile-option을 multiline을 적용하게 되면,
그때는 여러 줄일 때도 각 줄의 처음과 일치하는 것을 의미합니다

7175
08:22:03,830 --> 08:22:09,266
간단하게 예시를 보면, 여기서는 좀 더 간편하게, Re-module에서
바로 search를 써서 compile 옵션을, 멀티라인을 적용하게 되면,

7176
08:22:09,290 --> 08:22:14,150
컴파일될 패턴, 그리고 설치를 할 문자열,
이렇게 표현한 것을 볼 수가 있습니다

7177
08:22:14,350 --> 08:22:18,730
이렇게 해서 실행을 해보면 이게
처음을 나타낸 거라고 말씀을 드렸죠

7178
08:22:18,830 --> 08:22:24,830
그래서 실행을 해봤을 때 life is to shot으로 처음
시작하게 되면 이게 매치가 돼서 매치 객체가 나오고요

7179
08:22:24,930 --> 08:22:28,990
그리고 my life하고 life가
뒤에 나오면 매치가 안 되겠죠

7180
08:22:29,150 --> 08:22:30,590
그래서 none으로 나옵니다

7181
08:22:30,690 --> 08:22:36,407
다음으로 달러 표시의 경우에는 반대로
문자열의 맨 끝과 매치되는 것을 의미합니다

7182
08:22:36,431 --> 08:22:42,194
마찬가지로 출력을 해보면 이렇게 life is
to shot 끝에 일치하는 것은 매치 객체가

7183
08:22:42,218 --> 08:22:46,610
나오고 파이썬으로 끝나는 건 매치가 안
되니까 none이 나오는 것을 볼 수가 있습니다

7184
08:22:46,730 --> 08:22:54,730
다음으로 백슬래시 대문자 a가 뭔지를 보면 이거는 캐럿
문자와 동일하게 문자열의 처음과 매치되는 것을 의미합니다

7185
08:22:54,990 --> 08:22:59,230
그런데 이때 멀티라인 옵션이
적용됐을 때 다르게 해석이 되는데요

7186
08:22:59,370 --> 08:23:02,810
캐럿은 멀티라인이 되면 각 줄의 처음을 의미하잖아요

7187
08:23:02,990 --> 08:23:07,690
근데 백슬래시 a는 줄과 상관없이
문자열을 처음하고만 매치가 됩니다

7188
08:23:07,890 --> 08:23:15,030
마찬가지로 백슬래시 대문자 z의 경우에는
문자열 끝과 매치가 되는데 달러랑 동일하잖아요

7189
08:23:15,150 --> 08:23:22,610
근데 여기서도 멀티라인 옵션이 적용될 경우 달러
메타 문자와는 다르게 전체 문자열의 끝과 매치가 됩니다

7190
08:23:22,950 --> 08:23:27,590
다음으로 백슬래시 b가 뭔지를 보면 얘는 단어 구분자입니다

7191
08:23:27,790 --> 08:23:35,790
보통 화이트 스페이스에 의해 구분이 되는데 어떤 건지 보면 이런 식으로
백슬래시 b, 백슬래시 b를 써주면 이게 공백인데 여기서 백슬래시가 들어가는

7192
08:23:39,211 --> 08:23:44,570
거니까 이렇게 r을 앞에 써줌으로써 이렇게
로우 스트링을 표현해준 걸 볼 수가 있죠

7193
08:23:44,690 --> 08:23:49,590
그러면 이렇게 공백이 포함된
이거, 이거랑 일치하는 게 나오겠죠

7194
08:23:49,770 --> 08:23:54,010
그래서 실행을 해보면 이렇게
클래스가 매치가 된 걸 볼 수가 있습니다

7195
08:23:54,210 --> 08:24:01,410
그러면 이렇게 클래스가 들어가지만 공백이 없는
경우에는 실행을 해보면 이렇게 none이 나오는 걸 볼 수가 있죠

7196
08:24:01,570 --> 08:24:03,670
이거는 공백을 의미합니다

7197
08:24:03,990 --> 08:24:07,870
다음으로 백슬래시 대문자 b 메타 문자도 있는데요

7198
08:24:08,130 --> 08:24:11,030
이거는 백슬래시 b 메타 문자와 반대의 경우입니다

7199
08:24:11,250 --> 08:24:15,990
즉, 화이트 스페이스로 구분된
단어가 아닌 경우에만 매치가 됩니다

7200
08:24:16,410 --> 08:24:24,410
이거는 백슬래시 소문자 b와 반대로 공백이 없는 경우에만 되기
때문에 실행을 해보면 이렇게 공백이 있는 거는 걸러지고 여기도 공백이 있죠

7201
08:24:27,750 --> 08:24:34,370
그래서 걸러지고 공백이 없는 클래스 이것만 매치가
돼서 두 번째 것만 매치가 나온 것을 볼 수가 있습니다

7202
08:24:34,610 --> 08:24:37,330
다음으로 그룹핑에 대해서 배워 보겠습니다

7203
08:24:37,510 --> 08:24:40,666
정규 표현식에서 그룹핑이라는 게 가능한데요

7204
08:24:40,690 --> 08:24:42,750
어떤 건지 예시로 보도록 하겠습니다

7205
08:24:43,030 --> 08:24:51,030
이렇게 a b c가 반복되는 거를 매치를 하고 싶다고 했을
때 a b c 플러스 이렇게 쓰게 되면 c가 한 번 이상 반복된다.

7206
08:24:53,250 --> 08:24:59,010
C만 해당되기 때문에 a b c가 반복되는
거를 찾으려면 그룹으로 묶어줘야 됩니다

7207
08:24:59,270 --> 08:25:07,270
그래서 어떻게 하냐면 이렇게 a b c를 소괄호로 감싸 주게 되면,
그러면 이 전체를 한 번 이상 반복의 뜻이 돼서 이런 것도 매치가 됩니다

7208
08:25:09,910 --> 08:25:14,050
실행을 해보면 이렇게 ABC, ABC,
ABC가 매치가 된 걸 볼 수가 있죠

7209
08:25:14,170 --> 08:25:16,310
그리고 또 다른 예시를 살펴보겠습니다

7210
08:25:16,910 --> 08:25:24,910
이런 정규 표현식이 있다고 했을 때 먼저 잠시 이거에 대한 해설을 해보자면
어떤 거냐면 이 backslash w 이거는 지난 시간에 잠시 넘어갔었는데

7211
08:25:27,751 --> 08:25:34,990
이 문자 클래스에서 자주 사용되는 것들은 이렇게
backslash 이용해서 축약 형태로 표현이 됩니다

7212
08:25:35,350 --> 08:25:42,310
예를 들어서 backslash w 이거는 문자 플러스
숫자와 매치가 되는 것으로 이것과 동일한 표현식입니다

7213
08:25:42,470 --> 08:25:48,890
이걸 기반으로 좀 해석을 해보자면 그러면 이게
문자가 나오는 거고 backslash s는 화이트 스페이스입니다

7214
08:25:49,050 --> 08:25:57,050
그래서 공백의 의미고 그러면 문자 반복하다가 공백이
반복되고 그 다음에 backslash d는 숫자를 의미합니다

7215
08:25:58,490 --> 08:26:06,490
그러면 문자 반복, 공백 반복 그 다음에 숫자 반복 그리고 이 슬래시와
일치하는 게 나오고 또 숫자 반복, 슬래시와 일치, 숫자 반복이니까 이거를

7216
08:26:09,031 --> 08:26:17,031
좀 풀어서 해석해보자면 이런 문자 이름이 나오고
공백 다음에 숫자, 슬래시, 숫자, 슬래시, 숫자니까

7217
08:26:17,282 --> 08:26:23,410
이게 이름 그리고 공백 뒤에 전화번호 이런
형식으로 나오는 것을 정규 표현식으로 표현한 겁니다

7218
08:26:23,590 --> 08:26:30,850
그러면 여기서 만약에 이름 부분만 뽑아내려고 한다면
어떤 식으로 할 수 있지 보면 그로핑을 이용하면 됩니다

7219
08:26:31,170 --> 08:26:36,830
그래서 이름에 해당하는 이 부분을 이렇게
소괄호로 감싸게 되면 그룹이 만들어지는 거고요

7220
08:26:36,910 --> 08:26:40,810
그룹을 하면 좋은 점이 매치 객체에서
그룹 메소드를 쓸 수가 있습니다

7221
08:26:41,030 --> 08:26:49,030
그래서 그룹 메소드 중에 매치 객체의 그룹 1번이라고 쓰면
이렇게 팍, 이 그룹 1번에 해당하는 그룹이 따로 출력이 되게 됩니다

7222
08:26:50,930 --> 08:26:58,930
그리고 인덱스에 따라서 0을 넣으면 매치된 전체 문자열이 나오고 1을 넣으면
첫 번째 그룹에 해당하는 문자열 지금 여기는 그룹이 하나밖에 없으니까 바로

7223
08:26:59,931 --> 08:27:06,895
이 팍이 나왔는데 두 번째 그룹까지 있다면
그룹하고 인덱스 2를 넣으면 두 번째 그룹 또 n번째

7224
08:27:06,919 --> 08:27:12,430
그룹이 있으면 n번째 그룹에 해당하는 문자열이
넣은 인덱스에 따라서 다르게 나오게 됩니다

7225
08:27:12,590 --> 08:27:20,010
그러면 예제에 이어서 그룹을 이름 말고 전화번호
쪽에도 소괄호로 묶어서 그룹 두 번째를 만들었습니다

7226
08:27:20,350 --> 08:27:27,010
그렇게 되면 매치 그룹에 그룹에 인덱스 2번을 넣게
되면 전화번호만 따로 출력돼서 나오는 걸 볼 수가 있죠

7227
08:27:27,150 --> 08:27:32,590
그런데 여기서 한 발 더 나아가서 이 그룹
안에서 국번, 만 뽑아내고 싶을 수 있잖아요

7228
08:27:32,730 --> 08:27:33,570
맨 앞에 있는 거

7229
08:27:33,630 --> 08:27:34,826
그렇다면 어떻게 해야 되냐

7230
08:27:34,850 --> 08:27:37,930
그룹 안에 그룹을 만들어서 중첩을 시킬 수도 있습니다

7231
08:27:38,170 --> 08:27:45,690
그러면 이렇게 그룹 안에 또 그룹을 만들어서
중첩을 시키면 인덱스 3으로 뽑을 수가 있는데요

7232
08:27:46,010 --> 08:27:49,690
그러면 이렇게 그 앞에 국번 쪽인 010이 나오게 되죠

7233
08:27:49,750 --> 08:27:57,750
그런데 이 순서가 어떻게 되냐라고 하면 이렇게 안쪽에 있는 게
있으면 바깥부터 세고 그다음 안쪽 이렇게 인덱스를 세게 됩니다

7234
08:27:58,930 --> 08:28:04,330
그래서 그룹이 중첩된 경우 바깥쪽에서 시작해
안쪽으로 들어갈수록 인덱스 값이 증가합니다

7235
08:28:04,430 --> 08:28:09,070
그다음에 그룹의 또 좋은 점이
그룹핑된 문자열 재참조가 가능합니다

7236
08:28:09,210 --> 08:28:13,150
예시를 통해 보면 우선 이렇게 하나의 그룹을 묶어 놨죠

7237
08:28:13,210 --> 08:28:21,210
그룹은 공백하고 문자가 한 번 이상 반복되는 이 그룹을
하나 묶었는데 이 뒤에 공백, 뒤에 백 슬래시 1을 넣게 됐는데요

7238
08:28:23,130 --> 08:28:26,850
이거는 뭐냐면 첫 번째 그룹을 의미합니다

7239
08:28:27,050 --> 08:28:30,207
즉 첫 번째 그룹이 공백 뒤에 한 번 더 나오는 거

7240
08:28:30,231 --> 08:28:37,370
이런 거를 이 패턴 안에서도 이 그룹을 다시 한 번
가져와서 첫 번째 그룹을 재참조를 할 수가 있습니다

7241
08:28:37,550 --> 08:28:45,350
즉 똑같은 단어 띄어쓰기 똑같은 단어 이렇게 나오는
거를 찾는 건데 그러면 여기 더 더가 이런 형태가 되겠죠

7242
08:28:45,490 --> 08:28:49,210
그래서 이런 식으로 재참조해가지고 찾을 수도 있습니다

7243
08:28:49,590 --> 08:28:54,150
여기에 인덱스를 넣어 주는 거니까 그룹이
두 개 있다면 백 슬래시 2를 넣어주면 되겠죠

7244
08:28:54,270 --> 08:28:59,070
그리고 그룹에서도 그룹핑된
문자열에 이름 붙이기도 가능합니다

7245
08:28:59,230 --> 08:29:00,206
정규 시간에 그룹이 2개 있다면
백 슬래시 2를 넣어주면 되겠죠

7246
08:29:00,230 --> 08:29:06,830
그룹이 무척 많아진다고 하면 한 10개 이상 된다고
하면 너무 복잡해서 몇 번 인덱스인지 찾기가 어려울 겁니다

7247
08:29:07,030 --> 08:29:10,170
그래서 그럴 때는 이름으로 참조할 수도 있는데요

7248
08:29:10,370 --> 08:29:11,490
이런 식으로 쓰면 됩니다

7249
08:29:11,750 --> 08:29:17,090
그룹 안에 물음표 대문자 p 하고
꺽쇠 안쪽에 이름을 적어주면 됩니다

7250
08:29:17,350 --> 08:29:23,560
그래서 예시를 보면 이렇게 아까 이름
전화번호 그 정규 표현식에서 여기 첫 번째 이름

7251
08:29:23,584 --> 08:29:29,347
그룹 안에 물음표 대문자 p 그리고 꺽쇠
안에 name이라는 이름을 지어줬습니다

7252
08:29:29,371 --> 08:29:31,570
그러면 이 그룹의 이름이 정해진 거고요

7253
08:29:31,630 --> 08:29:39,630
그래서 매치 객체 그룹 메소드를 쓸 때 1 이런 식으로 첫 번째로 불러와도
되지만 많다고 가정했을 때 특정 이름을 쓰는 게 더 직관적이니 그룹의 이름인

7254
08:29:42,551 --> 08:29:48,590
name을 가져서 name을 쓰게 되면 이렇게
name에 해당하는 이 그룹이 출력이 됩니다

7255
08:29:48,830 --> 08:29:52,870
그리고 추가로 이렇게 이름을
정해준 이 그룹도 재참조가 가능합니다

7256
08:29:52,990 --> 08:29:59,545
즉 이렇게 그룹을 지어준 거에서 공백
뒤에 다시 한번 그룹을 만들어주고 p, 는

7257
08:29:59,569 --> 08:30:05,550
world라고 작성을 해주면 앞에서 만든
이 그룹을 재참조해서 쓴 것이 됩니다

7258
08:30:05,730 --> 08:30:10,730
그래서 아까와 마찬가지로 동일한
단어가 반복되는 더더 이게 잡히게 되겠죠

7259
08:30:10,870 --> 08:30:14,110
그래서 출력해보면 이렇게 매치가 된 걸 볼 수가 있습니다

7260
08:30:14,470 --> 08:30:19,550
그리고 추가로 이렇게 괄호 안에 물음표로
표현하는 거는 정규 표현식의 확장 구문입니다

7261
08:30:19,950 --> 08:30:23,470
가독성은 안 좋지만 이런 식으로 강력한 기능들이 있습니다

7262
08:30:23,710 --> 08:30:27,190
다음으로 전방 탐색의 개념에 대해서 배워보겠습니다

7263
08:30:29,370 --> 08:30:30,650
예를 통해서 알아보도록 하겠습니다

7264
08:30:30,850 --> 08:30:37,950
이런 예제가 있다고 했을 때 그냥 실행을
해보면 이렇게 http 하고 콜론까지가 나오는데요

7265
08:30:38,130 --> 08:30:46,130
여기서 패턴을 보면 줄바꿈 제외한 모든 문자 한 번 이상
반복에 여기에 콜론 이렇게 나오니까 이렇게까지가 잡히는 거죠

7266
08:30:46,590 --> 08:30:52,470
근데 이때 이 콜론을 빼고
http까지만 매치를 하고 싶어요

7267
08:30:52,570 --> 08:30:54,490
그럴 때 어떻게 하냐

7268
08:30:54,550 --> 08:30:59,010
이 콜론을 검색에는 포함을 하지만 매치에는 포함되지 않는

7269
08:30:59,370 --> 08:31:00,450
그런 방법이 있습니다

7270
08:31:00,610 --> 08:31:02,890
이런 것이 바로 전방 탐색인데요

7271
08:31:03,130 --> 08:31:07,410
이제 전방 탐색에는 긍정과 부정 두 가지가 있습니다

7272
08:31:07,730 --> 08:31:15,730
그래서 먼저 긍정을 보면 이렇게 소괄호 안에 물음표하고
는 한 다음에 뒤에 매치되어야 하는 조건을 넣게 되는데요

7273
08:31:17,090 --> 08:31:22,707
이럴 때는 정규식과 매치가 되어야 하지만
조건이 통과되어도 문자율이 소비되지가 않습니다

7274
08:31:22,731 --> 08:31:29,670
즉 여기에 소괄호 안에 물음표는 이런 식으로
되면 매치는 되지만 소비가 되지 않습니다

7275
08:31:29,770 --> 08:31:35,250
즉 이렇게 하고 실행을 해보면 이제는
http까지만 나온 것을 볼 수가 있죠

7276
08:31:35,410 --> 08:31:39,230
그러면 부정형은 뭔지 보면 이
등호 대신에 느낌표가 들어갑니다

7277
08:31:39,430 --> 08:31:46,270
부정형은 반대로 정규식과 매치되지 않는 것을
의미하고 조건이 통과되어도 소비 되지도 않습니다

7278
08:31:46,410 --> 08:31:54,410
예시로 보자면 이런 식으로 여러 개의 확장자가 있을 때, 이때
특정 확장자를 매치하지 않고 보면, 그리고 찾고 싶다라고 한다면 예를

7279
08:31:54,871 --> 08:32:02,871
들어 BAT 이거를 제외하고 싶다라고 하면 이제 점 뒤에 확장자를 검사를
해야 되는데 이때 부정형을 사용하게 되면 이 괄호 안에 물음표 안쪽에 등호

7280
08:32:05,351 --> 08:32:13,351
대신에 느낌표를 쓴 다음에 BAT로 끝난다를 의미하는
BAT하고 달러를 쓰게 되면 이것이 제외되고 매치가 됩니다

7281
08:32:14,470 --> 08:32:17,727
이때 멀티라인 옵션이 되니까
각 줄마다를 검사하는 게 되겠죠

7282
08:32:17,751 --> 08:32:23,970
그래서 실행을 해보면 이렇게 EXE와
JPG만 매치가 된 것을 볼 수가 있습니다

7283
08:32:24,090 --> 08:32:31,792
여기에 조금 응용을 하자면 EXE까지도 제외를
하려면 파이프를 이용하면 EXE로 끝나는 이렇게

7284
08:32:31,816 --> 08:32:38,070
지정을 해주게 되면 이번에는 EXE도
제외해서 JPG만 매치가 된 것을 볼 수가 있습니다

7285
08:32:38,290 --> 08:32:41,190
다음으로 문자열 바꾸기를 배워보겠습니다

7286
08:32:41,650 --> 08:32:44,150
서브라는 메서드를 활용하면 되는데요

7287
08:32:44,270 --> 08:32:45,647
예제를 보도록 하겠습니다

7288
08:32:45,671 --> 08:32:53,550
이렇게 패턴 객체에서 블루 또는 화이트, 레드에
해당하는 패턴 객체를 만들고 그리고 p.sub라는 메서드를

7289
08:32:53,574 --> 08:33:01,574
이용하게 되면 첫 번째 인자는 매치하게 되면 바꿀 단어
그리고 두 번째 인자는 매치하는지를 검사하는 단어인데요

7290
08:33:02,170 --> 08:33:09,930
이렇게 실행을 해보면 이렇게 블루, 레드 이렇게
일치하는 것들이 다 컬러로 바뀐 것을 확인할 수가 있습니다

7291
08:33:10,190 --> 08:33:12,490
이때 횟수를 제한해 줄 수도 있습니다

7292
08:33:12,730 --> 08:33:20,730
예를 들어 블루, 레드 둘 다 바꾸고 싶지 않고 한 번만 바꾸고 싶다고
하면 세 번째 인수로 count라는 것을 주게 되면 이렇게 count1 이렇게

7293
08:33:22,811 --> 08:33:28,830
하면 실행을 했을 때 블루, 레드 중에 처음 거
블루만 컬러로 바뀐 것을 확인할 수가 있습니다

7294
08:33:28,990 --> 08:33:33,490
다음으로 서브 메서드 사용 시 참조
구문 사용하는 것도 해보도록 하겠습니다

7295
08:33:33,850 --> 08:33:40,130
아까 이름, 전화번호 예제에서 서브
안에서 그룹 이름을 참조할 수가 있습니다

7296
08:33:40,350 --> 08:33:41,270
어떤 식으로 하냐?

7297
08:33:41,310 --> 08:33:48,450
여기 위에 이 그룹은 네임이라고 지어놨고 이 뒤에
전화번호는 폰이라는 이름으로 그룹 이름을 정해놨는데요

7298
08:33:48,510 --> 08:33:55,021
여기서 서브를 이용해서 폰이라는 그룹을
써주고 그 다음에 네임이라는 그룹을 이렇게 써주게

7299
08:33:55,045 --> 08:34:01,606
되면 실행을 했을 때 뒤에 있는 이 문자열에서
이렇게 일치하는 그룹들이 찾아지고요

7300
08:34:01,630 --> 08:34:09,630
그 다음에 이 그룹이 여기에 해당하는 대로 이 폰은 여기 폰으로 들어가고
네임은 이렇게 네임으로 들어가서 결국에 이렇게 순서가 바뀌어서 나오게 됩니다

7301
08:34:12,490 --> 08:34:15,910
물론 이렇게 이름을 써도 되고 아니면 인덱스를 써도 됩니다

7302
08:34:16,070 --> 08:34:20,550
그래서 이 두 번째, 첫 번째 이렇게
쓰게 되면 똑같이 이렇게 나오게 됩니다

7303
08:34:20,790 --> 08:34:24,610
추가로 서브 메소드에 매개변수로 함수를 넣을 수도 있습니다

7304
08:34:24,810 --> 08:34:27,930
어떤 거냐면 네, 이렇게 함수를 정의를 하고요

7305
08:34:27,970 --> 08:34:35,970
이 함수는 매치 객체를 받게 해서 그 매치 객체를 인트형으로
매치된 것을 뽑아서 그거를 16진수로 변환하는 이런 함수입니다

7306
08:34:37,690 --> 08:34:45,690
그러면 서브 메소드랑 함께 활용했을 때 여기에 첫 번째 매개변수로 함수를
적어주게 되면 이 패턴과 일치하는 것의 매치 객체가 이 함수로 들어가게 됩니다

7307
08:34:48,750 --> 08:34:53,550
즉 여기서는 이제 숫자가 한 번
이상 반복되는 거 이거랑 이거죠

7308
08:34:53,630 --> 08:35:00,350
그래서 이게 매치된 매치 객체가 여기 함수로
들어가서 결과 값이 이 자리에서 리턴이 됩니다

7309
08:35:00,570 --> 08:35:08,570
즉 이거를 프린트로 찍어보면 이렇게 기존 문자열에서 숫자들이 다
이 함수의 리턴 값인 16진수로 변환이 된 것을 확인할 수가 있습니다

7310
08:35:10,570 --> 08:35:14,246
다음으로 greedy와 non-greedy를 배워보겠습니다

7311
08:35:14,270 --> 08:35:19,510
정규식에서 그리디, 탐욕스러운이라는
표현이 종종 사용이 되는데요

7312
08:35:19,610 --> 08:35:27,610
어떤 의미인지 보자면, 우선 이렇게 매치를 이용해서
꺽쇠 사이에 문자열이 별표가 0번 이상 반복이 되는 거죠

7313
08:35:28,410 --> 08:35:36,410
그래서 그냥 직관적으로 생각하면 꺽쇠 안쪽에 반복되는 문자가 들어가는 여기까지가
매치가 될 것 같은데 이거를 출력해보면 이 문자열 전체가 출력이 됩니다

7314
08:35:39,391 --> 08:35:47,391
이게 왜 그런지를 생각해보면 여기에 꺽쇠들이 이것도 해당이 되지만
좀 탐욕스럽게 보자면 이 전체 여는 꺽쇠, 닫는 꺽쇠 여기까지에서 이 안에

7315
08:35:51,271 --> 08:35:58,610
문자가 들어가는 것 즉 별표가 탐욕스러워서
반복이 이것까지 모두 다 포함하는 반복이 된 겁니다

7316
08:35:58,770 --> 08:36:05,372
이거를 처음 생각대로 여기 처음 태그만
소비하기엔 할 수 없을까를 생각해보면 이게 기본적으로

7317
08:36:05,396 --> 08:36:10,910
그리디하기 때문에 그리디한 걸 막으려면
넌그리디한 문자인 문자인 물음표를 추가해주면 됩니다

7318
08:36:11,070 --> 08:36:13,230
그래서 이 물음표를 추가하게 되면 어떻게 되냐?

7319
08:36:13,310 --> 08:36:15,930
이 별표가 non-greedy하게 동작을 합니다

7320
08:36:16,110 --> 08:36:22,890
즉, 이거를 실행해보면 이렇게 non-greedy하게
동작해서 이 HTML 부분까지만 소비를 하게 됩니다

7321
08:36:23,210 --> 08:36:29,205
그래서 이런 non-greedy 문자인 물음표는
이 별표뿐만 아니라 플러스 혹은 0, 1을

7322
08:36:29,229 --> 08:36:34,870
나타내는 물음표 혹은 반복, 최소 최대의
반복을 나타내는 이거와 같이 사용할 수도 있습니다

7323
08:36:35,070 --> 08:36:39,970
그래서 되도록 최소한 반복을 수행하도록
하는 물음표 문자까지 배워봤습니다

7324
08:36:40,050 --> 08:36:43,690
이렇게 해서 책에 나온 정규 표현식 단원까지 배워봤습니다

7325
08:36:43,790 --> 08:36:51,790
정규 표현식은 이 문법을 모두 다 외우기보다는 사실
요즘에 이런 채찍 PT와 같은 AI가 워낙에 잘해줍니다

7326
08:36:52,190 --> 08:37:00,190
그래서 샘플로 처음에 정규 표현식이 왜 필요한가에 나왔던 이 문제가
주어졌다고 했을 때 이렇게 문제를 붙여넣어주고 오늘 파이썬 정규 표현식을

7327
08:37:02,771 --> 08:37:10,771
활용해서 이 문제를 해결해줘 라고 이렇게 문제를 주고
샘플 데이터까지 제공을 해주면 AI가 이걸 기가 막히게 해줍니다

7328
08:37:12,910 --> 08:37:16,970
이렇게 정규 표현식을 잘 짜준 것을 볼 수가 있죠

7329
08:37:17,110 --> 08:37:19,970
심지어 이렇게 해설도 잘 해주고 있습니다

7330
08:37:20,270 --> 08:37:21,850
코드 실행 결과까지 나왔고요

7331
08:37:21,990 --> 08:37:27,703
그렇기 때문에 이 정규 표현식 안에
나와있는 이런 패턴들에 대해서 철저하게 잘

7332
08:37:27,727 --> 08:37:32,890
알지 않아도 AI에게 잘 시키기만 해도
충분히 이런 문제를 해결할 수가 있습니다

7333
08:37:33,130 --> 08:37:39,058
그래서 좀 난이도가 있는 그런 장이었는데
이것에 대해서 완벽하게 이해하지 못했다고 해서 너무

7334
08:37:39,082 --> 08:37:45,330
실망하지 마시고 AI가 이제는 도와줄 수 있다 라는
점 기억해 두시면서 희망을 가지시길 바라겠습니다

7335
08:37:45,510 --> 08:37:49,410
이렇게 해서 점프 투 파이썬
전체 과정을 한번 다 배워봤는데요

7336
08:37:49,690 --> 08:37:57,470
파이썬의 기초 과정을 다 공부를 하셨으니 이제 파이썬을
응용한 여러 가지 작업들을 좀 더 수월하게 하실 수 있을 것 같습니다

7337
08:37:57,670 --> 08:38:03,310
그래서 파이썬을 활용한 업무 자동화 혹은
파이썬을 활용한 웹 개발 파이썬을 활용한 주식

7338
08:38:03,334 --> 08:38:08,470
투자 비트코인 투자 자동화 이런 것들을
여러분들 손으로 손쉽게 해볼 수가 있겠습니다

7339
08:38:08,690 --> 08:38:11,390
이런 식으로 확장해 나갈 수도 있으니까요

7340
08:38:11,430 --> 08:38:16,170
파이썬 배우신 김에 여러 가지 파이썬을
활용하는 것도 해보시기를 추천드립니다

7341
08:38:16,370 --> 08:38:19,430
그러면 지금까지 수업 들어주셔서 감사드리고요

7342
08:38:19,490 --> 08:38:20,870
다음에 또 뵙도록 하겠습니다

7343
08:38:21,090 --> 08:38:23,570
조코딩 유튜브도 구독해 주시면 감사드리겠습니다

7344
08:38:23,870 --> 08:38:26,550
지금까지 긴 수업 수강해 주셔서 감사드립니다

7345
08:38:26,670 --> 08:38:27,670
감사합니다

7346
08:38:36,350 --> 08:38:37,830
디지털 러브

